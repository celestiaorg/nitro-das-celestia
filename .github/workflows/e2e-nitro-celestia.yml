name: e2e-nitro-celestia

on:
  workflow_dispatch:
    inputs:
      runner_label:
        description: Self-hosted runner label
        required: true
        default: self-hosted
      testnode_repo:
        description: Repo for OffchainLabs testnode
        required: true
        default: OffchainLabs/nitro-testnode
      testnode_ref:
        description: Ref/branch/tag for testnode (release recommended)
        required: true
        default: release
      celestia_network:
        description: Celestia p2p network for the light node
        required: true
        default: mocha-4
      das_image:
        description: Celestia DA server image tag
        required: true
        default: ghcr.io/celestiaorg/nitro-das-celestia:v0.5.3-mocha
      enforce_da_roundtrip:
        description: Fail if DA store/fetch can't be verified (true/false)
        required: true
        default: "true"

concurrency:
  group: e2e-nitro-celestia-${{ github.ref }}
  cancel-in-progress: true

jobs:
  e2e:
    runs-on: ${{ inputs.runner_label }}
    timeout-minutes: 60
    env:
      WORKDIR: ${{ github.workspace }}/.e2e
      COMPOSE_PROJECT_NAME: ndc-${{ github.run_id }}
      TESTNODE_REPO: ${{ inputs.testnode_repo }}
      TESTNODE_REF: ${{ inputs.testnode_ref }}
      CELESTIA_NET: ${{ inputs.celestia_network }}
      DAS_IMAGE: ${{ inputs.das_image }}
      ENFORCE_DA_ROUNDTRIP: ${{ inputs.enforce_da_roundtrip }}

    steps:
      - name: Checkout nitro-das-celestia (this repo)
        uses: actions/checkout@v4

      - name: Prep folders
        run: |
          mkdir -p "$WORKDIR"/{logs,artifacts}

      - name: Clone nitro-testnode
        run: |
          cd "$WORKDIR"
          git clone -b "$TESTNODE_REF" --recurse-submodules "https://github.com/$TESTNODE_REPO.git" nitro-testnode

      - name: Setup blockscout nitro.env
        run: |
          cd "$WORKDIR/nitro-testnode"
          # Download nitro.env file from blockscout repository
          curl -sL https://raw.githubusercontent.com/OffchainLabs/blockscout/aa73f57d06a297b2202dbb1dbcfa354f5b45b781/nitro.env \
            -o blockscout/nitro.env
          echo "Created nitro.env file in blockscout directory"
          ls -la blockscout/nitro.env

      - name: Docker info (pre)
        run: |
          docker info || true
          docker system df || true

      # ---------- 1) Bring up Nitro devnet via OffchainLabs testnode ----------
      - name: Start Nitro + Celestia + DA concurrently
        shell: bash
        run: |
          set -euo pipefail
      
          # Kick off Nitro testnode in background
          (
            cd "$WORKDIR/nitro-testnode" && ./test-node.bash --init 
          ) &
      
          # Start Celestia light node (RPC open, no auth) in background
          (
            docker rm -f celestia-light 2>/dev/null || true
            docker run -d --name celestia-light --restart unless-stopped \
              -p 26658:26658 \
              ghcr.io/celestiaorg/celestia-node:latest \
              celestia light start --rpc.skip-auth --p2p.network "${CELESTIA_NET}"
          ) &
      
          # Start DA server wired to the light node in background
          (
            docker rm -f celestia-da 2>/dev/null || true
            # Ensure Linux can reach the host as host.docker.internal
            HGI=$(docker info --format '{{.HostGateway}}' 2>/dev/null || echo "")
            ADD_HOST_ARG=""
            if [ -n "$HGI" ]; then
              ADD_HOST_ARG="--add-host=host.docker.internal:${HGI}"
            fi
            docker run -d --name celestia-da --restart unless-stopped \
              -p 9875:9875 \
              $ADD_HOST_ARG \
              "${DAS_IMAGE}" \
              --enable-rpc --rpc-addr 0.0.0.0 --rpc-port 9875 \
              --celestia.rpc http://host.docker.internal:26658
          ) &
      
          # Wait for all background startups before running health checks
          wait

      # ---------- Health gates ----------

      - name: Wait for Celestia RPC (26658)
        run: |
          set -e
          tries=90
          until curl -sf http://localhost:26658/health >/dev/null 2>&1 || \
                curl -sf http://localhost:26658 | head -c 1 >/dev/null 2>&1; do
            ((tries--)) || { echo "Celestia RPC not up"; exit 1; }
            sleep 5
          done

      - name: Wait for DA server (9875)
        run: |
          set -e
          tries=90
          until curl -sf http://localhost:9875/health >/dev/null 2>&1 || \
                curl -sf http://localhost:9875 | head -c 1 >/dev/null 2>&1; do
            ((tries--)) || { echo "DA server not up"; exit 1; }
            sleep 5
          done

      - name: Wait for L2 RPC (8547)
        run: |
          set -e
          tries=120
          echo "Waiting for L2 RPC to become available..."
          until response=$(curl --connect-timeout 5 --max-time 10 -H 'Content-Type: application/json' \
            --data '{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}' \
            http://localhost:8547 2>&1) && echo "$response" | grep -q "result"; do
            ((tries--)) || { 
              echo "L2 RPC not up after 120 attempts (10 minutes)"
            }
            if [ $((tries % 10)) -eq 0 ] || [ $tries -lt 5 ]; then
              echo "Attempt $((120 - tries + 1))/120: $response"
            fi
            sleep 5
          done
          echo "L2 RPC is now responding: $response"

      - name: Run system tests
        run: |
          set -e
          (cd "$WORKDIR/nitro-testnode" && ./test-node.bash script send-l2 --ethamount 2 --to user_l2user --wait;
          then
            echo "Sending l2 transaction succeeded"
          else
            echo "Sending l2 transaction failed"
            exit 1
          fi

      - name: Stop stacks
        if: always()
        run: |
          set -e
          (cd "$WORKDIR/nitro-testnode" && docker compose down -v) || true
          docker rm -f celestia-da celestia-light 2>/dev/null || true

      - name: Docker prune (post)
        if: always()
        run: |
          docker system prune -af || true
          docker volume prune -f || true