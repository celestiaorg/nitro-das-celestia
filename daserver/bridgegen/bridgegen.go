// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package bridgegen

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// BufferConfig is an auto generated low-level Go binding around an user-defined struct.
type BufferConfig struct {
	Threshold            uint64
	Max                  uint64
	ReplenishRateInBasis uint64
}

// DelayProof is an auto generated low-level Go binding around an user-defined struct.
type DelayProof struct {
	BeforeDelayedAcc [32]byte
	DelayedMessage   MessagesMessage
}

// IBridgeTimeBounds is an auto generated low-level Go binding around an user-defined struct.
type IBridgeTimeBounds struct {
	MinTimestamp   uint64
	MaxTimestamp   uint64
	MinBlockNumber uint64
	MaxBlockNumber uint64
}

// ISequencerInboxMaxTimeVariation is an auto generated low-level Go binding around an user-defined struct.
type ISequencerInboxMaxTimeVariation struct {
	DelayBlocks   *big.Int
	FutureBlocks  *big.Int
	DelaySeconds  *big.Int
	FutureSeconds *big.Int
}

// MessagesMessage is an auto generated low-level Go binding around an user-defined struct.
type MessagesMessage struct {
	Kind            uint8
	Sender          common.Address
	BlockNumber     uint64
	Timestamp       uint64
	InboxSeqNum     *big.Int
	BaseFeeL1       *big.Int
	MessageDataHash [32]byte
}

// AbsBridgeMetaData contains all meta data concerning the AbsBridge contract.
var AbsBridgeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stored\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"BadSequencerMessageNumber\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"}],\"name\":\"InvalidOutboxSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NotContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotOutbox\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotRollupOrOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotSequencerInbox\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BridgeCallTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"InboxToggle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beforeInboxAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"MessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OutboxToggle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"}],\"name\":\"RollupUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSequencerInbox\",\"type\":\"address\"}],\"name\":\"SequencerInboxUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptFundsFromOldBridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeOutbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedDelayedInboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"}],\"name\":\"allowedDelayedInboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedOutboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"}],\"name\":\"allowedOutboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"delayedInboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayedMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"}],\"name\":\"enqueueSequencerMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seqMessageIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"beforeAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"delayedAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"acc\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sequencerInboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerReportedSubMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setDelayedInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setOutbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"setSequencerInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMsgCount\",\"type\":\"uint256\"}],\"name\":\"setSequencerReportedSubMessageCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"name\":\"submitBatchSpendingReport\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"_rollup\",\"type\":\"address\"}],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// AbsBridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use AbsBridgeMetaData.ABI instead.
var AbsBridgeABI = AbsBridgeMetaData.ABI

// AbsBridge is an auto generated Go binding around an Ethereum contract.
type AbsBridge struct {
	AbsBridgeCaller     // Read-only binding to the contract
	AbsBridgeTransactor // Write-only binding to the contract
	AbsBridgeFilterer   // Log filterer for contract events
}

// AbsBridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type AbsBridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AbsBridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AbsBridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AbsBridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AbsBridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AbsBridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AbsBridgeSession struct {
	Contract     *AbsBridge        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AbsBridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AbsBridgeCallerSession struct {
	Contract *AbsBridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// AbsBridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AbsBridgeTransactorSession struct {
	Contract     *AbsBridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// AbsBridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type AbsBridgeRaw struct {
	Contract *AbsBridge // Generic contract binding to access the raw methods on
}

// AbsBridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AbsBridgeCallerRaw struct {
	Contract *AbsBridgeCaller // Generic read-only contract binding to access the raw methods on
}

// AbsBridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AbsBridgeTransactorRaw struct {
	Contract *AbsBridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAbsBridge creates a new instance of AbsBridge, bound to a specific deployed contract.
func NewAbsBridge(address common.Address, backend bind.ContractBackend) (*AbsBridge, error) {
	contract, err := bindAbsBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AbsBridge{AbsBridgeCaller: AbsBridgeCaller{contract: contract}, AbsBridgeTransactor: AbsBridgeTransactor{contract: contract}, AbsBridgeFilterer: AbsBridgeFilterer{contract: contract}}, nil
}

// NewAbsBridgeCaller creates a new read-only instance of AbsBridge, bound to a specific deployed contract.
func NewAbsBridgeCaller(address common.Address, caller bind.ContractCaller) (*AbsBridgeCaller, error) {
	contract, err := bindAbsBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AbsBridgeCaller{contract: contract}, nil
}

// NewAbsBridgeTransactor creates a new write-only instance of AbsBridge, bound to a specific deployed contract.
func NewAbsBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*AbsBridgeTransactor, error) {
	contract, err := bindAbsBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AbsBridgeTransactor{contract: contract}, nil
}

// NewAbsBridgeFilterer creates a new log filterer instance of AbsBridge, bound to a specific deployed contract.
func NewAbsBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*AbsBridgeFilterer, error) {
	contract, err := bindAbsBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AbsBridgeFilterer{contract: contract}, nil
}

// bindAbsBridge binds a generic wrapper to an already deployed contract.
func bindAbsBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AbsBridgeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AbsBridge *AbsBridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AbsBridge.Contract.AbsBridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AbsBridge *AbsBridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AbsBridge.Contract.AbsBridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AbsBridge *AbsBridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AbsBridge.Contract.AbsBridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AbsBridge *AbsBridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AbsBridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AbsBridge *AbsBridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AbsBridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AbsBridge *AbsBridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AbsBridge.Contract.contract.Transact(opts, method, params...)
}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_AbsBridge *AbsBridgeCaller) ActiveOutbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AbsBridge.contract.Call(opts, &out, "activeOutbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_AbsBridge *AbsBridgeSession) ActiveOutbox() (common.Address, error) {
	return _AbsBridge.Contract.ActiveOutbox(&_AbsBridge.CallOpts)
}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_AbsBridge *AbsBridgeCallerSession) ActiveOutbox() (common.Address, error) {
	return _AbsBridge.Contract.ActiveOutbox(&_AbsBridge.CallOpts)
}

// AllowedDelayedInboxList is a free data retrieval call binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) view returns(address)
func (_AbsBridge *AbsBridgeCaller) AllowedDelayedInboxList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _AbsBridge.contract.Call(opts, &out, "allowedDelayedInboxList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AllowedDelayedInboxList is a free data retrieval call binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) view returns(address)
func (_AbsBridge *AbsBridgeSession) AllowedDelayedInboxList(arg0 *big.Int) (common.Address, error) {
	return _AbsBridge.Contract.AllowedDelayedInboxList(&_AbsBridge.CallOpts, arg0)
}

// AllowedDelayedInboxList is a free data retrieval call binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) view returns(address)
func (_AbsBridge *AbsBridgeCallerSession) AllowedDelayedInboxList(arg0 *big.Int) (common.Address, error) {
	return _AbsBridge.Contract.AllowedDelayedInboxList(&_AbsBridge.CallOpts, arg0)
}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_AbsBridge *AbsBridgeCaller) AllowedDelayedInboxes(opts *bind.CallOpts, inbox common.Address) (bool, error) {
	var out []interface{}
	err := _AbsBridge.contract.Call(opts, &out, "allowedDelayedInboxes", inbox)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_AbsBridge *AbsBridgeSession) AllowedDelayedInboxes(inbox common.Address) (bool, error) {
	return _AbsBridge.Contract.AllowedDelayedInboxes(&_AbsBridge.CallOpts, inbox)
}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_AbsBridge *AbsBridgeCallerSession) AllowedDelayedInboxes(inbox common.Address) (bool, error) {
	return _AbsBridge.Contract.AllowedDelayedInboxes(&_AbsBridge.CallOpts, inbox)
}

// AllowedOutboxList is a free data retrieval call binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) view returns(address)
func (_AbsBridge *AbsBridgeCaller) AllowedOutboxList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _AbsBridge.contract.Call(opts, &out, "allowedOutboxList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AllowedOutboxList is a free data retrieval call binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) view returns(address)
func (_AbsBridge *AbsBridgeSession) AllowedOutboxList(arg0 *big.Int) (common.Address, error) {
	return _AbsBridge.Contract.AllowedOutboxList(&_AbsBridge.CallOpts, arg0)
}

// AllowedOutboxList is a free data retrieval call binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) view returns(address)
func (_AbsBridge *AbsBridgeCallerSession) AllowedOutboxList(arg0 *big.Int) (common.Address, error) {
	return _AbsBridge.Contract.AllowedOutboxList(&_AbsBridge.CallOpts, arg0)
}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_AbsBridge *AbsBridgeCaller) AllowedOutboxes(opts *bind.CallOpts, outbox common.Address) (bool, error) {
	var out []interface{}
	err := _AbsBridge.contract.Call(opts, &out, "allowedOutboxes", outbox)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_AbsBridge *AbsBridgeSession) AllowedOutboxes(outbox common.Address) (bool, error) {
	return _AbsBridge.Contract.AllowedOutboxes(&_AbsBridge.CallOpts, outbox)
}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_AbsBridge *AbsBridgeCallerSession) AllowedOutboxes(outbox common.Address) (bool, error) {
	return _AbsBridge.Contract.AllowedOutboxes(&_AbsBridge.CallOpts, outbox)
}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_AbsBridge *AbsBridgeCaller) DelayedInboxAccs(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _AbsBridge.contract.Call(opts, &out, "delayedInboxAccs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_AbsBridge *AbsBridgeSession) DelayedInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _AbsBridge.Contract.DelayedInboxAccs(&_AbsBridge.CallOpts, arg0)
}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_AbsBridge *AbsBridgeCallerSession) DelayedInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _AbsBridge.Contract.DelayedInboxAccs(&_AbsBridge.CallOpts, arg0)
}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_AbsBridge *AbsBridgeCaller) DelayedMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AbsBridge.contract.Call(opts, &out, "delayedMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_AbsBridge *AbsBridgeSession) DelayedMessageCount() (*big.Int, error) {
	return _AbsBridge.Contract.DelayedMessageCount(&_AbsBridge.CallOpts)
}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_AbsBridge *AbsBridgeCallerSession) DelayedMessageCount() (*big.Int, error) {
	return _AbsBridge.Contract.DelayedMessageCount(&_AbsBridge.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_AbsBridge *AbsBridgeCaller) Rollup(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AbsBridge.contract.Call(opts, &out, "rollup")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_AbsBridge *AbsBridgeSession) Rollup() (common.Address, error) {
	return _AbsBridge.Contract.Rollup(&_AbsBridge.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_AbsBridge *AbsBridgeCallerSession) Rollup() (common.Address, error) {
	return _AbsBridge.Contract.Rollup(&_AbsBridge.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_AbsBridge *AbsBridgeCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AbsBridge.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_AbsBridge *AbsBridgeSession) SequencerInbox() (common.Address, error) {
	return _AbsBridge.Contract.SequencerInbox(&_AbsBridge.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_AbsBridge *AbsBridgeCallerSession) SequencerInbox() (common.Address, error) {
	return _AbsBridge.Contract.SequencerInbox(&_AbsBridge.CallOpts)
}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_AbsBridge *AbsBridgeCaller) SequencerInboxAccs(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _AbsBridge.contract.Call(opts, &out, "sequencerInboxAccs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_AbsBridge *AbsBridgeSession) SequencerInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _AbsBridge.Contract.SequencerInboxAccs(&_AbsBridge.CallOpts, arg0)
}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_AbsBridge *AbsBridgeCallerSession) SequencerInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _AbsBridge.Contract.SequencerInboxAccs(&_AbsBridge.CallOpts, arg0)
}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_AbsBridge *AbsBridgeCaller) SequencerMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AbsBridge.contract.Call(opts, &out, "sequencerMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_AbsBridge *AbsBridgeSession) SequencerMessageCount() (*big.Int, error) {
	return _AbsBridge.Contract.SequencerMessageCount(&_AbsBridge.CallOpts)
}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_AbsBridge *AbsBridgeCallerSession) SequencerMessageCount() (*big.Int, error) {
	return _AbsBridge.Contract.SequencerMessageCount(&_AbsBridge.CallOpts)
}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_AbsBridge *AbsBridgeCaller) SequencerReportedSubMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AbsBridge.contract.Call(opts, &out, "sequencerReportedSubMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_AbsBridge *AbsBridgeSession) SequencerReportedSubMessageCount() (*big.Int, error) {
	return _AbsBridge.Contract.SequencerReportedSubMessageCount(&_AbsBridge.CallOpts)
}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_AbsBridge *AbsBridgeCallerSession) SequencerReportedSubMessageCount() (*big.Int, error) {
	return _AbsBridge.Contract.SequencerReportedSubMessageCount(&_AbsBridge.CallOpts)
}

// AcceptFundsFromOldBridge is a paid mutator transaction binding the contract method 0xe77145f4.
//
// Solidity: function acceptFundsFromOldBridge() payable returns()
func (_AbsBridge *AbsBridgeTransactor) AcceptFundsFromOldBridge(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AbsBridge.contract.Transact(opts, "acceptFundsFromOldBridge")
}

// AcceptFundsFromOldBridge is a paid mutator transaction binding the contract method 0xe77145f4.
//
// Solidity: function acceptFundsFromOldBridge() payable returns()
func (_AbsBridge *AbsBridgeSession) AcceptFundsFromOldBridge() (*types.Transaction, error) {
	return _AbsBridge.Contract.AcceptFundsFromOldBridge(&_AbsBridge.TransactOpts)
}

// AcceptFundsFromOldBridge is a paid mutator transaction binding the contract method 0xe77145f4.
//
// Solidity: function acceptFundsFromOldBridge() payable returns()
func (_AbsBridge *AbsBridgeTransactorSession) AcceptFundsFromOldBridge() (*types.Transaction, error) {
	return _AbsBridge.Contract.AcceptFundsFromOldBridge(&_AbsBridge.TransactOpts)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_AbsBridge *AbsBridgeTransactor) EnqueueSequencerMessage(opts *bind.TransactOpts, dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _AbsBridge.contract.Transact(opts, "enqueueSequencerMessage", dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_AbsBridge *AbsBridgeSession) EnqueueSequencerMessage(dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _AbsBridge.Contract.EnqueueSequencerMessage(&_AbsBridge.TransactOpts, dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_AbsBridge *AbsBridgeTransactorSession) EnqueueSequencerMessage(dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _AbsBridge.Contract.EnqueueSequencerMessage(&_AbsBridge.TransactOpts, dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_AbsBridge *AbsBridgeTransactor) ExecuteCall(opts *bind.TransactOpts, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsBridge.contract.Transact(opts, "executeCall", to, value, data)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_AbsBridge *AbsBridgeSession) ExecuteCall(to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsBridge.Contract.ExecuteCall(&_AbsBridge.TransactOpts, to, value, data)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_AbsBridge *AbsBridgeTransactorSession) ExecuteCall(to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsBridge.Contract.ExecuteCall(&_AbsBridge.TransactOpts, to, value, data)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_AbsBridge *AbsBridgeTransactor) SetDelayedInbox(opts *bind.TransactOpts, inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _AbsBridge.contract.Transact(opts, "setDelayedInbox", inbox, enabled)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_AbsBridge *AbsBridgeSession) SetDelayedInbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _AbsBridge.Contract.SetDelayedInbox(&_AbsBridge.TransactOpts, inbox, enabled)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_AbsBridge *AbsBridgeTransactorSession) SetDelayedInbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _AbsBridge.Contract.SetDelayedInbox(&_AbsBridge.TransactOpts, inbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address outbox, bool enabled) returns()
func (_AbsBridge *AbsBridgeTransactor) SetOutbox(opts *bind.TransactOpts, outbox common.Address, enabled bool) (*types.Transaction, error) {
	return _AbsBridge.contract.Transact(opts, "setOutbox", outbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address outbox, bool enabled) returns()
func (_AbsBridge *AbsBridgeSession) SetOutbox(outbox common.Address, enabled bool) (*types.Transaction, error) {
	return _AbsBridge.Contract.SetOutbox(&_AbsBridge.TransactOpts, outbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address outbox, bool enabled) returns()
func (_AbsBridge *AbsBridgeTransactorSession) SetOutbox(outbox common.Address, enabled bool) (*types.Transaction, error) {
	return _AbsBridge.Contract.SetOutbox(&_AbsBridge.TransactOpts, outbox, enabled)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_AbsBridge *AbsBridgeTransactor) SetSequencerInbox(opts *bind.TransactOpts, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _AbsBridge.contract.Transact(opts, "setSequencerInbox", _sequencerInbox)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_AbsBridge *AbsBridgeSession) SetSequencerInbox(_sequencerInbox common.Address) (*types.Transaction, error) {
	return _AbsBridge.Contract.SetSequencerInbox(&_AbsBridge.TransactOpts, _sequencerInbox)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_AbsBridge *AbsBridgeTransactorSession) SetSequencerInbox(_sequencerInbox common.Address) (*types.Transaction, error) {
	return _AbsBridge.Contract.SetSequencerInbox(&_AbsBridge.TransactOpts, _sequencerInbox)
}

// SetSequencerReportedSubMessageCount is a paid mutator transaction binding the contract method 0xf81ff3b3.
//
// Solidity: function setSequencerReportedSubMessageCount(uint256 newMsgCount) returns()
func (_AbsBridge *AbsBridgeTransactor) SetSequencerReportedSubMessageCount(opts *bind.TransactOpts, newMsgCount *big.Int) (*types.Transaction, error) {
	return _AbsBridge.contract.Transact(opts, "setSequencerReportedSubMessageCount", newMsgCount)
}

// SetSequencerReportedSubMessageCount is a paid mutator transaction binding the contract method 0xf81ff3b3.
//
// Solidity: function setSequencerReportedSubMessageCount(uint256 newMsgCount) returns()
func (_AbsBridge *AbsBridgeSession) SetSequencerReportedSubMessageCount(newMsgCount *big.Int) (*types.Transaction, error) {
	return _AbsBridge.Contract.SetSequencerReportedSubMessageCount(&_AbsBridge.TransactOpts, newMsgCount)
}

// SetSequencerReportedSubMessageCount is a paid mutator transaction binding the contract method 0xf81ff3b3.
//
// Solidity: function setSequencerReportedSubMessageCount(uint256 newMsgCount) returns()
func (_AbsBridge *AbsBridgeTransactorSession) SetSequencerReportedSubMessageCount(newMsgCount *big.Int) (*types.Transaction, error) {
	return _AbsBridge.Contract.SetSequencerReportedSubMessageCount(&_AbsBridge.TransactOpts, newMsgCount)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address sender, bytes32 messageDataHash) returns(uint256)
func (_AbsBridge *AbsBridgeTransactor) SubmitBatchSpendingReport(opts *bind.TransactOpts, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _AbsBridge.contract.Transact(opts, "submitBatchSpendingReport", sender, messageDataHash)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address sender, bytes32 messageDataHash) returns(uint256)
func (_AbsBridge *AbsBridgeSession) SubmitBatchSpendingReport(sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _AbsBridge.Contract.SubmitBatchSpendingReport(&_AbsBridge.TransactOpts, sender, messageDataHash)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address sender, bytes32 messageDataHash) returns(uint256)
func (_AbsBridge *AbsBridgeTransactorSession) SubmitBatchSpendingReport(sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _AbsBridge.Contract.SubmitBatchSpendingReport(&_AbsBridge.TransactOpts, sender, messageDataHash)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_AbsBridge *AbsBridgeTransactor) UpdateRollupAddress(opts *bind.TransactOpts, _rollup common.Address) (*types.Transaction, error) {
	return _AbsBridge.contract.Transact(opts, "updateRollupAddress", _rollup)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_AbsBridge *AbsBridgeSession) UpdateRollupAddress(_rollup common.Address) (*types.Transaction, error) {
	return _AbsBridge.Contract.UpdateRollupAddress(&_AbsBridge.TransactOpts, _rollup)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_AbsBridge *AbsBridgeTransactorSession) UpdateRollupAddress(_rollup common.Address) (*types.Transaction, error) {
	return _AbsBridge.Contract.UpdateRollupAddress(&_AbsBridge.TransactOpts, _rollup)
}

// AbsBridgeBridgeCallTriggeredIterator is returned from FilterBridgeCallTriggered and is used to iterate over the raw logs and unpacked data for BridgeCallTriggered events raised by the AbsBridge contract.
type AbsBridgeBridgeCallTriggeredIterator struct {
	Event *AbsBridgeBridgeCallTriggered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsBridgeBridgeCallTriggeredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsBridgeBridgeCallTriggered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsBridgeBridgeCallTriggered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsBridgeBridgeCallTriggeredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsBridgeBridgeCallTriggeredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsBridgeBridgeCallTriggered represents a BridgeCallTriggered event raised by the AbsBridge contract.
type AbsBridgeBridgeCallTriggered struct {
	Outbox common.Address
	To     common.Address
	Value  *big.Int
	Data   []byte
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBridgeCallTriggered is a free log retrieval operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_AbsBridge *AbsBridgeFilterer) FilterBridgeCallTriggered(opts *bind.FilterOpts, outbox []common.Address, to []common.Address) (*AbsBridgeBridgeCallTriggeredIterator, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _AbsBridge.contract.FilterLogs(opts, "BridgeCallTriggered", outboxRule, toRule)
	if err != nil {
		return nil, err
	}
	return &AbsBridgeBridgeCallTriggeredIterator{contract: _AbsBridge.contract, event: "BridgeCallTriggered", logs: logs, sub: sub}, nil
}

// WatchBridgeCallTriggered is a free log subscription operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_AbsBridge *AbsBridgeFilterer) WatchBridgeCallTriggered(opts *bind.WatchOpts, sink chan<- *AbsBridgeBridgeCallTriggered, outbox []common.Address, to []common.Address) (event.Subscription, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _AbsBridge.contract.WatchLogs(opts, "BridgeCallTriggered", outboxRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsBridgeBridgeCallTriggered)
				if err := _AbsBridge.contract.UnpackLog(event, "BridgeCallTriggered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBridgeCallTriggered is a log parse operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_AbsBridge *AbsBridgeFilterer) ParseBridgeCallTriggered(log types.Log) (*AbsBridgeBridgeCallTriggered, error) {
	event := new(AbsBridgeBridgeCallTriggered)
	if err := _AbsBridge.contract.UnpackLog(event, "BridgeCallTriggered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsBridgeInboxToggleIterator is returned from FilterInboxToggle and is used to iterate over the raw logs and unpacked data for InboxToggle events raised by the AbsBridge contract.
type AbsBridgeInboxToggleIterator struct {
	Event *AbsBridgeInboxToggle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsBridgeInboxToggleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsBridgeInboxToggle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsBridgeInboxToggle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsBridgeInboxToggleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsBridgeInboxToggleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsBridgeInboxToggle represents a InboxToggle event raised by the AbsBridge contract.
type AbsBridgeInboxToggle struct {
	Inbox   common.Address
	Enabled bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInboxToggle is a free log retrieval operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_AbsBridge *AbsBridgeFilterer) FilterInboxToggle(opts *bind.FilterOpts, inbox []common.Address) (*AbsBridgeInboxToggleIterator, error) {

	var inboxRule []interface{}
	for _, inboxItem := range inbox {
		inboxRule = append(inboxRule, inboxItem)
	}

	logs, sub, err := _AbsBridge.contract.FilterLogs(opts, "InboxToggle", inboxRule)
	if err != nil {
		return nil, err
	}
	return &AbsBridgeInboxToggleIterator{contract: _AbsBridge.contract, event: "InboxToggle", logs: logs, sub: sub}, nil
}

// WatchInboxToggle is a free log subscription operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_AbsBridge *AbsBridgeFilterer) WatchInboxToggle(opts *bind.WatchOpts, sink chan<- *AbsBridgeInboxToggle, inbox []common.Address) (event.Subscription, error) {

	var inboxRule []interface{}
	for _, inboxItem := range inbox {
		inboxRule = append(inboxRule, inboxItem)
	}

	logs, sub, err := _AbsBridge.contract.WatchLogs(opts, "InboxToggle", inboxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsBridgeInboxToggle)
				if err := _AbsBridge.contract.UnpackLog(event, "InboxToggle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxToggle is a log parse operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_AbsBridge *AbsBridgeFilterer) ParseInboxToggle(log types.Log) (*AbsBridgeInboxToggle, error) {
	event := new(AbsBridgeInboxToggle)
	if err := _AbsBridge.contract.UnpackLog(event, "InboxToggle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsBridgeInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the AbsBridge contract.
type AbsBridgeInitializedIterator struct {
	Event *AbsBridgeInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsBridgeInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsBridgeInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsBridgeInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsBridgeInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsBridgeInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsBridgeInitialized represents a Initialized event raised by the AbsBridge contract.
type AbsBridgeInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_AbsBridge *AbsBridgeFilterer) FilterInitialized(opts *bind.FilterOpts) (*AbsBridgeInitializedIterator, error) {

	logs, sub, err := _AbsBridge.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &AbsBridgeInitializedIterator{contract: _AbsBridge.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_AbsBridge *AbsBridgeFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *AbsBridgeInitialized) (event.Subscription, error) {

	logs, sub, err := _AbsBridge.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsBridgeInitialized)
				if err := _AbsBridge.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_AbsBridge *AbsBridgeFilterer) ParseInitialized(log types.Log) (*AbsBridgeInitialized, error) {
	event := new(AbsBridgeInitialized)
	if err := _AbsBridge.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsBridgeMessageDeliveredIterator is returned from FilterMessageDelivered and is used to iterate over the raw logs and unpacked data for MessageDelivered events raised by the AbsBridge contract.
type AbsBridgeMessageDeliveredIterator struct {
	Event *AbsBridgeMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsBridgeMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsBridgeMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsBridgeMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsBridgeMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsBridgeMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsBridgeMessageDelivered represents a MessageDelivered event raised by the AbsBridge contract.
type AbsBridgeMessageDelivered struct {
	MessageIndex    *big.Int
	BeforeInboxAcc  [32]byte
	Inbox           common.Address
	Kind            uint8
	Sender          common.Address
	MessageDataHash [32]byte
	BaseFeeL1       *big.Int
	Timestamp       uint64
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterMessageDelivered is a free log retrieval operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_AbsBridge *AbsBridgeFilterer) FilterMessageDelivered(opts *bind.FilterOpts, messageIndex []*big.Int, beforeInboxAcc [][32]byte) (*AbsBridgeMessageDeliveredIterator, error) {

	var messageIndexRule []interface{}
	for _, messageIndexItem := range messageIndex {
		messageIndexRule = append(messageIndexRule, messageIndexItem)
	}
	var beforeInboxAccRule []interface{}
	for _, beforeInboxAccItem := range beforeInboxAcc {
		beforeInboxAccRule = append(beforeInboxAccRule, beforeInboxAccItem)
	}

	logs, sub, err := _AbsBridge.contract.FilterLogs(opts, "MessageDelivered", messageIndexRule, beforeInboxAccRule)
	if err != nil {
		return nil, err
	}
	return &AbsBridgeMessageDeliveredIterator{contract: _AbsBridge.contract, event: "MessageDelivered", logs: logs, sub: sub}, nil
}

// WatchMessageDelivered is a free log subscription operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_AbsBridge *AbsBridgeFilterer) WatchMessageDelivered(opts *bind.WatchOpts, sink chan<- *AbsBridgeMessageDelivered, messageIndex []*big.Int, beforeInboxAcc [][32]byte) (event.Subscription, error) {

	var messageIndexRule []interface{}
	for _, messageIndexItem := range messageIndex {
		messageIndexRule = append(messageIndexRule, messageIndexItem)
	}
	var beforeInboxAccRule []interface{}
	for _, beforeInboxAccItem := range beforeInboxAcc {
		beforeInboxAccRule = append(beforeInboxAccRule, beforeInboxAccItem)
	}

	logs, sub, err := _AbsBridge.contract.WatchLogs(opts, "MessageDelivered", messageIndexRule, beforeInboxAccRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsBridgeMessageDelivered)
				if err := _AbsBridge.contract.UnpackLog(event, "MessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageDelivered is a log parse operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_AbsBridge *AbsBridgeFilterer) ParseMessageDelivered(log types.Log) (*AbsBridgeMessageDelivered, error) {
	event := new(AbsBridgeMessageDelivered)
	if err := _AbsBridge.contract.UnpackLog(event, "MessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsBridgeOutboxToggleIterator is returned from FilterOutboxToggle and is used to iterate over the raw logs and unpacked data for OutboxToggle events raised by the AbsBridge contract.
type AbsBridgeOutboxToggleIterator struct {
	Event *AbsBridgeOutboxToggle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsBridgeOutboxToggleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsBridgeOutboxToggle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsBridgeOutboxToggle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsBridgeOutboxToggleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsBridgeOutboxToggleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsBridgeOutboxToggle represents a OutboxToggle event raised by the AbsBridge contract.
type AbsBridgeOutboxToggle struct {
	Outbox  common.Address
	Enabled bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterOutboxToggle is a free log retrieval operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_AbsBridge *AbsBridgeFilterer) FilterOutboxToggle(opts *bind.FilterOpts, outbox []common.Address) (*AbsBridgeOutboxToggleIterator, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}

	logs, sub, err := _AbsBridge.contract.FilterLogs(opts, "OutboxToggle", outboxRule)
	if err != nil {
		return nil, err
	}
	return &AbsBridgeOutboxToggleIterator{contract: _AbsBridge.contract, event: "OutboxToggle", logs: logs, sub: sub}, nil
}

// WatchOutboxToggle is a free log subscription operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_AbsBridge *AbsBridgeFilterer) WatchOutboxToggle(opts *bind.WatchOpts, sink chan<- *AbsBridgeOutboxToggle, outbox []common.Address) (event.Subscription, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}

	logs, sub, err := _AbsBridge.contract.WatchLogs(opts, "OutboxToggle", outboxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsBridgeOutboxToggle)
				if err := _AbsBridge.contract.UnpackLog(event, "OutboxToggle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOutboxToggle is a log parse operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_AbsBridge *AbsBridgeFilterer) ParseOutboxToggle(log types.Log) (*AbsBridgeOutboxToggle, error) {
	event := new(AbsBridgeOutboxToggle)
	if err := _AbsBridge.contract.UnpackLog(event, "OutboxToggle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsBridgeRollupUpdatedIterator is returned from FilterRollupUpdated and is used to iterate over the raw logs and unpacked data for RollupUpdated events raised by the AbsBridge contract.
type AbsBridgeRollupUpdatedIterator struct {
	Event *AbsBridgeRollupUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsBridgeRollupUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsBridgeRollupUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsBridgeRollupUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsBridgeRollupUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsBridgeRollupUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsBridgeRollupUpdated represents a RollupUpdated event raised by the AbsBridge contract.
type AbsBridgeRollupUpdated struct {
	Rollup common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRollupUpdated is a free log retrieval operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_AbsBridge *AbsBridgeFilterer) FilterRollupUpdated(opts *bind.FilterOpts) (*AbsBridgeRollupUpdatedIterator, error) {

	logs, sub, err := _AbsBridge.contract.FilterLogs(opts, "RollupUpdated")
	if err != nil {
		return nil, err
	}
	return &AbsBridgeRollupUpdatedIterator{contract: _AbsBridge.contract, event: "RollupUpdated", logs: logs, sub: sub}, nil
}

// WatchRollupUpdated is a free log subscription operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_AbsBridge *AbsBridgeFilterer) WatchRollupUpdated(opts *bind.WatchOpts, sink chan<- *AbsBridgeRollupUpdated) (event.Subscription, error) {

	logs, sub, err := _AbsBridge.contract.WatchLogs(opts, "RollupUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsBridgeRollupUpdated)
				if err := _AbsBridge.contract.UnpackLog(event, "RollupUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupUpdated is a log parse operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_AbsBridge *AbsBridgeFilterer) ParseRollupUpdated(log types.Log) (*AbsBridgeRollupUpdated, error) {
	event := new(AbsBridgeRollupUpdated)
	if err := _AbsBridge.contract.UnpackLog(event, "RollupUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsBridgeSequencerInboxUpdatedIterator is returned from FilterSequencerInboxUpdated and is used to iterate over the raw logs and unpacked data for SequencerInboxUpdated events raised by the AbsBridge contract.
type AbsBridgeSequencerInboxUpdatedIterator struct {
	Event *AbsBridgeSequencerInboxUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsBridgeSequencerInboxUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsBridgeSequencerInboxUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsBridgeSequencerInboxUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsBridgeSequencerInboxUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsBridgeSequencerInboxUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsBridgeSequencerInboxUpdated represents a SequencerInboxUpdated event raised by the AbsBridge contract.
type AbsBridgeSequencerInboxUpdated struct {
	NewSequencerInbox common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterSequencerInboxUpdated is a free log retrieval operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_AbsBridge *AbsBridgeFilterer) FilterSequencerInboxUpdated(opts *bind.FilterOpts) (*AbsBridgeSequencerInboxUpdatedIterator, error) {

	logs, sub, err := _AbsBridge.contract.FilterLogs(opts, "SequencerInboxUpdated")
	if err != nil {
		return nil, err
	}
	return &AbsBridgeSequencerInboxUpdatedIterator{contract: _AbsBridge.contract, event: "SequencerInboxUpdated", logs: logs, sub: sub}, nil
}

// WatchSequencerInboxUpdated is a free log subscription operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_AbsBridge *AbsBridgeFilterer) WatchSequencerInboxUpdated(opts *bind.WatchOpts, sink chan<- *AbsBridgeSequencerInboxUpdated) (event.Subscription, error) {

	logs, sub, err := _AbsBridge.contract.WatchLogs(opts, "SequencerInboxUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsBridgeSequencerInboxUpdated)
				if err := _AbsBridge.contract.UnpackLog(event, "SequencerInboxUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSequencerInboxUpdated is a log parse operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_AbsBridge *AbsBridgeFilterer) ParseSequencerInboxUpdated(log types.Log) (*AbsBridgeSequencerInboxUpdated, error) {
	event := new(AbsBridgeSequencerInboxUpdated)
	if err := _AbsBridge.contract.UnpackLog(event, "SequencerInboxUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsInboxMetaData contains all meta data concerning the AbsInbox contract.
var AbsInboxMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDataLength\",\"type\":\"uint256\"}],\"name\":\"DataTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GasLimitTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"L1Forked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"}],\"name\":\"NotAllowedOrigin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotCodelessOrigin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotRollupOrOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"AllowListAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"AllowListEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowListEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"}],\"name\":\"calculateRetryableSubmissionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"contractISequencerInbox\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDataSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendContractTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2Message\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2MessageFromOrigin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendUnsignedTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"contractISequencerInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"val\",\"type\":\"bool[]\"}],\"name\":\"setAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowListEnabled\",\"type\":\"bool\"}],\"name\":\"setAllowListEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// AbsInboxABI is the input ABI used to generate the binding from.
// Deprecated: Use AbsInboxMetaData.ABI instead.
var AbsInboxABI = AbsInboxMetaData.ABI

// AbsInbox is an auto generated Go binding around an Ethereum contract.
type AbsInbox struct {
	AbsInboxCaller     // Read-only binding to the contract
	AbsInboxTransactor // Write-only binding to the contract
	AbsInboxFilterer   // Log filterer for contract events
}

// AbsInboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type AbsInboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AbsInboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AbsInboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AbsInboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AbsInboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AbsInboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AbsInboxSession struct {
	Contract     *AbsInbox         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AbsInboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AbsInboxCallerSession struct {
	Contract *AbsInboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// AbsInboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AbsInboxTransactorSession struct {
	Contract     *AbsInboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// AbsInboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type AbsInboxRaw struct {
	Contract *AbsInbox // Generic contract binding to access the raw methods on
}

// AbsInboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AbsInboxCallerRaw struct {
	Contract *AbsInboxCaller // Generic read-only contract binding to access the raw methods on
}

// AbsInboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AbsInboxTransactorRaw struct {
	Contract *AbsInboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAbsInbox creates a new instance of AbsInbox, bound to a specific deployed contract.
func NewAbsInbox(address common.Address, backend bind.ContractBackend) (*AbsInbox, error) {
	contract, err := bindAbsInbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AbsInbox{AbsInboxCaller: AbsInboxCaller{contract: contract}, AbsInboxTransactor: AbsInboxTransactor{contract: contract}, AbsInboxFilterer: AbsInboxFilterer{contract: contract}}, nil
}

// NewAbsInboxCaller creates a new read-only instance of AbsInbox, bound to a specific deployed contract.
func NewAbsInboxCaller(address common.Address, caller bind.ContractCaller) (*AbsInboxCaller, error) {
	contract, err := bindAbsInbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AbsInboxCaller{contract: contract}, nil
}

// NewAbsInboxTransactor creates a new write-only instance of AbsInbox, bound to a specific deployed contract.
func NewAbsInboxTransactor(address common.Address, transactor bind.ContractTransactor) (*AbsInboxTransactor, error) {
	contract, err := bindAbsInbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AbsInboxTransactor{contract: contract}, nil
}

// NewAbsInboxFilterer creates a new log filterer instance of AbsInbox, bound to a specific deployed contract.
func NewAbsInboxFilterer(address common.Address, filterer bind.ContractFilterer) (*AbsInboxFilterer, error) {
	contract, err := bindAbsInbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AbsInboxFilterer{contract: contract}, nil
}

// bindAbsInbox binds a generic wrapper to an already deployed contract.
func bindAbsInbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AbsInboxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AbsInbox *AbsInboxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AbsInbox.Contract.AbsInboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AbsInbox *AbsInboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AbsInbox.Contract.AbsInboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AbsInbox *AbsInboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AbsInbox.Contract.AbsInboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AbsInbox *AbsInboxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AbsInbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AbsInbox *AbsInboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AbsInbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AbsInbox *AbsInboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AbsInbox.Contract.contract.Transact(opts, method, params...)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_AbsInbox *AbsInboxCaller) AllowListEnabled(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _AbsInbox.contract.Call(opts, &out, "allowListEnabled")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_AbsInbox *AbsInboxSession) AllowListEnabled() (bool, error) {
	return _AbsInbox.Contract.AllowListEnabled(&_AbsInbox.CallOpts)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_AbsInbox *AbsInboxCallerSession) AllowListEnabled() (bool, error) {
	return _AbsInbox.Contract.AllowListEnabled(&_AbsInbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_AbsInbox *AbsInboxCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AbsInbox.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_AbsInbox *AbsInboxSession) Bridge() (common.Address, error) {
	return _AbsInbox.Contract.Bridge(&_AbsInbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_AbsInbox *AbsInboxCallerSession) Bridge() (common.Address, error) {
	return _AbsInbox.Contract.Bridge(&_AbsInbox.CallOpts)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_AbsInbox *AbsInboxCaller) CalculateRetryableSubmissionFee(opts *bind.CallOpts, dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _AbsInbox.contract.Call(opts, &out, "calculateRetryableSubmissionFee", dataLength, baseFee)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_AbsInbox *AbsInboxSession) CalculateRetryableSubmissionFee(dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	return _AbsInbox.Contract.CalculateRetryableSubmissionFee(&_AbsInbox.CallOpts, dataLength, baseFee)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_AbsInbox *AbsInboxCallerSession) CalculateRetryableSubmissionFee(dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	return _AbsInbox.Contract.CalculateRetryableSubmissionFee(&_AbsInbox.CallOpts, dataLength, baseFee)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_AbsInbox *AbsInboxCaller) GetProxyAdmin(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AbsInbox.contract.Call(opts, &out, "getProxyAdmin")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_AbsInbox *AbsInboxSession) GetProxyAdmin() (common.Address, error) {
	return _AbsInbox.Contract.GetProxyAdmin(&_AbsInbox.CallOpts)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_AbsInbox *AbsInboxCallerSession) GetProxyAdmin() (common.Address, error) {
	return _AbsInbox.Contract.GetProxyAdmin(&_AbsInbox.CallOpts)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address ) view returns(bool)
func (_AbsInbox *AbsInboxCaller) IsAllowed(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _AbsInbox.contract.Call(opts, &out, "isAllowed", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address ) view returns(bool)
func (_AbsInbox *AbsInboxSession) IsAllowed(arg0 common.Address) (bool, error) {
	return _AbsInbox.Contract.IsAllowed(&_AbsInbox.CallOpts, arg0)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address ) view returns(bool)
func (_AbsInbox *AbsInboxCallerSession) IsAllowed(arg0 common.Address) (bool, error) {
	return _AbsInbox.Contract.IsAllowed(&_AbsInbox.CallOpts, arg0)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_AbsInbox *AbsInboxCaller) MaxDataSize(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AbsInbox.contract.Call(opts, &out, "maxDataSize")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_AbsInbox *AbsInboxSession) MaxDataSize() (*big.Int, error) {
	return _AbsInbox.Contract.MaxDataSize(&_AbsInbox.CallOpts)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_AbsInbox *AbsInboxCallerSession) MaxDataSize() (*big.Int, error) {
	return _AbsInbox.Contract.MaxDataSize(&_AbsInbox.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_AbsInbox *AbsInboxCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _AbsInbox.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_AbsInbox *AbsInboxSession) Paused() (bool, error) {
	return _AbsInbox.Contract.Paused(&_AbsInbox.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_AbsInbox *AbsInboxCallerSession) Paused() (bool, error) {
	return _AbsInbox.Contract.Paused(&_AbsInbox.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_AbsInbox *AbsInboxCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AbsInbox.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_AbsInbox *AbsInboxSession) SequencerInbox() (common.Address, error) {
	return _AbsInbox.Contract.SequencerInbox(&_AbsInbox.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_AbsInbox *AbsInboxCallerSession) SequencerInbox() (common.Address, error) {
	return _AbsInbox.Contract.SequencerInbox(&_AbsInbox.CallOpts)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_AbsInbox *AbsInboxTransactor) Initialize(opts *bind.TransactOpts, _bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _AbsInbox.contract.Transact(opts, "initialize", _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_AbsInbox *AbsInboxSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _AbsInbox.Contract.Initialize(&_AbsInbox.TransactOpts, _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_AbsInbox *AbsInboxTransactorSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _AbsInbox.Contract.Initialize(&_AbsInbox.TransactOpts, _bridge, _sequencerInbox)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_AbsInbox *AbsInboxTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AbsInbox.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_AbsInbox *AbsInboxSession) Pause() (*types.Transaction, error) {
	return _AbsInbox.Contract.Pause(&_AbsInbox.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_AbsInbox *AbsInboxTransactorSession) Pause() (*types.Transaction, error) {
	return _AbsInbox.Contract.Pause(&_AbsInbox.TransactOpts)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_AbsInbox *AbsInboxTransactor) SendContractTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsInbox.contract.Transact(opts, "sendContractTransaction", gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_AbsInbox *AbsInboxSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsInbox.Contract.SendContractTransaction(&_AbsInbox.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_AbsInbox *AbsInboxTransactorSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsInbox.Contract.SendContractTransaction(&_AbsInbox.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_AbsInbox *AbsInboxTransactor) SendL2Message(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _AbsInbox.contract.Transact(opts, "sendL2Message", messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_AbsInbox *AbsInboxSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _AbsInbox.Contract.SendL2Message(&_AbsInbox.TransactOpts, messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_AbsInbox *AbsInboxTransactorSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _AbsInbox.Contract.SendL2Message(&_AbsInbox.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_AbsInbox *AbsInboxTransactor) SendL2MessageFromOrigin(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _AbsInbox.contract.Transact(opts, "sendL2MessageFromOrigin", messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_AbsInbox *AbsInboxSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _AbsInbox.Contract.SendL2MessageFromOrigin(&_AbsInbox.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_AbsInbox *AbsInboxTransactorSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _AbsInbox.Contract.SendL2MessageFromOrigin(&_AbsInbox.TransactOpts, messageData)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_AbsInbox *AbsInboxTransactor) SendUnsignedTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsInbox.contract.Transact(opts, "sendUnsignedTransaction", gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_AbsInbox *AbsInboxSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsInbox.Contract.SendUnsignedTransaction(&_AbsInbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_AbsInbox *AbsInboxTransactorSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsInbox.Contract.SendUnsignedTransaction(&_AbsInbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_AbsInbox *AbsInboxTransactor) SetAllowList(opts *bind.TransactOpts, user []common.Address, val []bool) (*types.Transaction, error) {
	return _AbsInbox.contract.Transact(opts, "setAllowList", user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_AbsInbox *AbsInboxSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _AbsInbox.Contract.SetAllowList(&_AbsInbox.TransactOpts, user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_AbsInbox *AbsInboxTransactorSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _AbsInbox.Contract.SetAllowList(&_AbsInbox.TransactOpts, user, val)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_AbsInbox *AbsInboxTransactor) SetAllowListEnabled(opts *bind.TransactOpts, _allowListEnabled bool) (*types.Transaction, error) {
	return _AbsInbox.contract.Transact(opts, "setAllowListEnabled", _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_AbsInbox *AbsInboxSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _AbsInbox.Contract.SetAllowListEnabled(&_AbsInbox.TransactOpts, _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_AbsInbox *AbsInboxTransactorSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _AbsInbox.Contract.SetAllowListEnabled(&_AbsInbox.TransactOpts, _allowListEnabled)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_AbsInbox *AbsInboxTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AbsInbox.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_AbsInbox *AbsInboxSession) Unpause() (*types.Transaction, error) {
	return _AbsInbox.Contract.Unpause(&_AbsInbox.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_AbsInbox *AbsInboxTransactorSession) Unpause() (*types.Transaction, error) {
	return _AbsInbox.Contract.Unpause(&_AbsInbox.TransactOpts)
}

// AbsInboxAllowListAddressSetIterator is returned from FilterAllowListAddressSet and is used to iterate over the raw logs and unpacked data for AllowListAddressSet events raised by the AbsInbox contract.
type AbsInboxAllowListAddressSetIterator struct {
	Event *AbsInboxAllowListAddressSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsInboxAllowListAddressSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsInboxAllowListAddressSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsInboxAllowListAddressSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsInboxAllowListAddressSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsInboxAllowListAddressSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsInboxAllowListAddressSet represents a AllowListAddressSet event raised by the AbsInbox contract.
type AbsInboxAllowListAddressSet struct {
	User common.Address
	Val  bool
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterAllowListAddressSet is a free log retrieval operation binding the contract event 0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a.
//
// Solidity: event AllowListAddressSet(address indexed user, bool val)
func (_AbsInbox *AbsInboxFilterer) FilterAllowListAddressSet(opts *bind.FilterOpts, user []common.Address) (*AbsInboxAllowListAddressSetIterator, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	logs, sub, err := _AbsInbox.contract.FilterLogs(opts, "AllowListAddressSet", userRule)
	if err != nil {
		return nil, err
	}
	return &AbsInboxAllowListAddressSetIterator{contract: _AbsInbox.contract, event: "AllowListAddressSet", logs: logs, sub: sub}, nil
}

// WatchAllowListAddressSet is a free log subscription operation binding the contract event 0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a.
//
// Solidity: event AllowListAddressSet(address indexed user, bool val)
func (_AbsInbox *AbsInboxFilterer) WatchAllowListAddressSet(opts *bind.WatchOpts, sink chan<- *AbsInboxAllowListAddressSet, user []common.Address) (event.Subscription, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	logs, sub, err := _AbsInbox.contract.WatchLogs(opts, "AllowListAddressSet", userRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsInboxAllowListAddressSet)
				if err := _AbsInbox.contract.UnpackLog(event, "AllowListAddressSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAllowListAddressSet is a log parse operation binding the contract event 0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a.
//
// Solidity: event AllowListAddressSet(address indexed user, bool val)
func (_AbsInbox *AbsInboxFilterer) ParseAllowListAddressSet(log types.Log) (*AbsInboxAllowListAddressSet, error) {
	event := new(AbsInboxAllowListAddressSet)
	if err := _AbsInbox.contract.UnpackLog(event, "AllowListAddressSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsInboxAllowListEnabledUpdatedIterator is returned from FilterAllowListEnabledUpdated and is used to iterate over the raw logs and unpacked data for AllowListEnabledUpdated events raised by the AbsInbox contract.
type AbsInboxAllowListEnabledUpdatedIterator struct {
	Event *AbsInboxAllowListEnabledUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsInboxAllowListEnabledUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsInboxAllowListEnabledUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsInboxAllowListEnabledUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsInboxAllowListEnabledUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsInboxAllowListEnabledUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsInboxAllowListEnabledUpdated represents a AllowListEnabledUpdated event raised by the AbsInbox contract.
type AbsInboxAllowListEnabledUpdated struct {
	IsEnabled bool
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterAllowListEnabledUpdated is a free log retrieval operation binding the contract event 0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3.
//
// Solidity: event AllowListEnabledUpdated(bool isEnabled)
func (_AbsInbox *AbsInboxFilterer) FilterAllowListEnabledUpdated(opts *bind.FilterOpts) (*AbsInboxAllowListEnabledUpdatedIterator, error) {

	logs, sub, err := _AbsInbox.contract.FilterLogs(opts, "AllowListEnabledUpdated")
	if err != nil {
		return nil, err
	}
	return &AbsInboxAllowListEnabledUpdatedIterator{contract: _AbsInbox.contract, event: "AllowListEnabledUpdated", logs: logs, sub: sub}, nil
}

// WatchAllowListEnabledUpdated is a free log subscription operation binding the contract event 0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3.
//
// Solidity: event AllowListEnabledUpdated(bool isEnabled)
func (_AbsInbox *AbsInboxFilterer) WatchAllowListEnabledUpdated(opts *bind.WatchOpts, sink chan<- *AbsInboxAllowListEnabledUpdated) (event.Subscription, error) {

	logs, sub, err := _AbsInbox.contract.WatchLogs(opts, "AllowListEnabledUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsInboxAllowListEnabledUpdated)
				if err := _AbsInbox.contract.UnpackLog(event, "AllowListEnabledUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAllowListEnabledUpdated is a log parse operation binding the contract event 0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3.
//
// Solidity: event AllowListEnabledUpdated(bool isEnabled)
func (_AbsInbox *AbsInboxFilterer) ParseAllowListEnabledUpdated(log types.Log) (*AbsInboxAllowListEnabledUpdated, error) {
	event := new(AbsInboxAllowListEnabledUpdated)
	if err := _AbsInbox.contract.UnpackLog(event, "AllowListEnabledUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsInboxInboxMessageDeliveredIterator is returned from FilterInboxMessageDelivered and is used to iterate over the raw logs and unpacked data for InboxMessageDelivered events raised by the AbsInbox contract.
type AbsInboxInboxMessageDeliveredIterator struct {
	Event *AbsInboxInboxMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsInboxInboxMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsInboxInboxMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsInboxInboxMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsInboxInboxMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsInboxInboxMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsInboxInboxMessageDelivered represents a InboxMessageDelivered event raised by the AbsInbox contract.
type AbsInboxInboxMessageDelivered struct {
	MessageNum *big.Int
	Data       []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDelivered is a free log retrieval operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_AbsInbox *AbsInboxFilterer) FilterInboxMessageDelivered(opts *bind.FilterOpts, messageNum []*big.Int) (*AbsInboxInboxMessageDeliveredIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _AbsInbox.contract.FilterLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &AbsInboxInboxMessageDeliveredIterator{contract: _AbsInbox.contract, event: "InboxMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDelivered is a free log subscription operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_AbsInbox *AbsInboxFilterer) WatchInboxMessageDelivered(opts *bind.WatchOpts, sink chan<- *AbsInboxInboxMessageDelivered, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _AbsInbox.contract.WatchLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsInboxInboxMessageDelivered)
				if err := _AbsInbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDelivered is a log parse operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_AbsInbox *AbsInboxFilterer) ParseInboxMessageDelivered(log types.Log) (*AbsInboxInboxMessageDelivered, error) {
	event := new(AbsInboxInboxMessageDelivered)
	if err := _AbsInbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsInboxInboxMessageDeliveredFromOriginIterator is returned from FilterInboxMessageDeliveredFromOrigin and is used to iterate over the raw logs and unpacked data for InboxMessageDeliveredFromOrigin events raised by the AbsInbox contract.
type AbsInboxInboxMessageDeliveredFromOriginIterator struct {
	Event *AbsInboxInboxMessageDeliveredFromOrigin // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsInboxInboxMessageDeliveredFromOriginIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsInboxInboxMessageDeliveredFromOrigin)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsInboxInboxMessageDeliveredFromOrigin)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsInboxInboxMessageDeliveredFromOriginIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsInboxInboxMessageDeliveredFromOriginIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsInboxInboxMessageDeliveredFromOrigin represents a InboxMessageDeliveredFromOrigin event raised by the AbsInbox contract.
type AbsInboxInboxMessageDeliveredFromOrigin struct {
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDeliveredFromOrigin is a free log retrieval operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_AbsInbox *AbsInboxFilterer) FilterInboxMessageDeliveredFromOrigin(opts *bind.FilterOpts, messageNum []*big.Int) (*AbsInboxInboxMessageDeliveredFromOriginIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _AbsInbox.contract.FilterLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &AbsInboxInboxMessageDeliveredFromOriginIterator{contract: _AbsInbox.contract, event: "InboxMessageDeliveredFromOrigin", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDeliveredFromOrigin is a free log subscription operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_AbsInbox *AbsInboxFilterer) WatchInboxMessageDeliveredFromOrigin(opts *bind.WatchOpts, sink chan<- *AbsInboxInboxMessageDeliveredFromOrigin, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _AbsInbox.contract.WatchLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsInboxInboxMessageDeliveredFromOrigin)
				if err := _AbsInbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDeliveredFromOrigin is a log parse operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_AbsInbox *AbsInboxFilterer) ParseInboxMessageDeliveredFromOrigin(log types.Log) (*AbsInboxInboxMessageDeliveredFromOrigin, error) {
	event := new(AbsInboxInboxMessageDeliveredFromOrigin)
	if err := _AbsInbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsInboxInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the AbsInbox contract.
type AbsInboxInitializedIterator struct {
	Event *AbsInboxInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsInboxInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsInboxInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsInboxInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsInboxInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsInboxInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsInboxInitialized represents a Initialized event raised by the AbsInbox contract.
type AbsInboxInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_AbsInbox *AbsInboxFilterer) FilterInitialized(opts *bind.FilterOpts) (*AbsInboxInitializedIterator, error) {

	logs, sub, err := _AbsInbox.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &AbsInboxInitializedIterator{contract: _AbsInbox.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_AbsInbox *AbsInboxFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *AbsInboxInitialized) (event.Subscription, error) {

	logs, sub, err := _AbsInbox.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsInboxInitialized)
				if err := _AbsInbox.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_AbsInbox *AbsInboxFilterer) ParseInitialized(log types.Log) (*AbsInboxInitialized, error) {
	event := new(AbsInboxInitialized)
	if err := _AbsInbox.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsInboxPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the AbsInbox contract.
type AbsInboxPausedIterator struct {
	Event *AbsInboxPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsInboxPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsInboxPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsInboxPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsInboxPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsInboxPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsInboxPaused represents a Paused event raised by the AbsInbox contract.
type AbsInboxPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_AbsInbox *AbsInboxFilterer) FilterPaused(opts *bind.FilterOpts) (*AbsInboxPausedIterator, error) {

	logs, sub, err := _AbsInbox.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &AbsInboxPausedIterator{contract: _AbsInbox.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_AbsInbox *AbsInboxFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *AbsInboxPaused) (event.Subscription, error) {

	logs, sub, err := _AbsInbox.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsInboxPaused)
				if err := _AbsInbox.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_AbsInbox *AbsInboxFilterer) ParsePaused(log types.Log) (*AbsInboxPaused, error) {
	event := new(AbsInboxPaused)
	if err := _AbsInbox.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsInboxUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the AbsInbox contract.
type AbsInboxUnpausedIterator struct {
	Event *AbsInboxUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsInboxUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsInboxUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsInboxUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsInboxUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsInboxUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsInboxUnpaused represents a Unpaused event raised by the AbsInbox contract.
type AbsInboxUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_AbsInbox *AbsInboxFilterer) FilterUnpaused(opts *bind.FilterOpts) (*AbsInboxUnpausedIterator, error) {

	logs, sub, err := _AbsInbox.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &AbsInboxUnpausedIterator{contract: _AbsInbox.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_AbsInbox *AbsInboxFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *AbsInboxUnpaused) (event.Subscription, error) {

	logs, sub, err := _AbsInbox.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsInboxUnpaused)
				if err := _AbsInbox.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_AbsInbox *AbsInboxFilterer) ParseUnpaused(log types.Log) (*AbsInboxUnpaused, error) {
	event := new(AbsInboxUnpaused)
	if err := _AbsInbox.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsOutboxMetaData contains all meta data concerning the AbsOutbox contract.
var AbsOutboxMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"AlreadyInit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"AlreadySpent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadPostUpgradeInit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BridgeCallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HadZeroInit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxProofLength\",\"type\":\"uint256\"}],\"name\":\"MerkleProofTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"}],\"name\":\"NotRollup\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxIndex\",\"type\":\"uint256\"}],\"name\":\"PathNotMinimal\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proofLength\",\"type\":\"uint256\"}],\"name\":\"ProofTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RollupNotChanged\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SimulationOnlyEntrypoint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"UnknownRoot\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"zero\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionIndex\",\"type\":\"uint256\"}],\"name\":\"OutBoxTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"outputRoot\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"l2BlockHash\",\"type\":\"bytes32\"}],\"name\":\"SendRootUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OUTBOX_VERSION\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"calculateItemHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"path\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"item\",\"type\":\"bytes32\"}],\"name\":\"calculateMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeTransactionSimulation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isSpent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1BatchNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Block\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1EthBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1OutputId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Sender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"postUpgradeInit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"roots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spent\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2BlockHash\",\"type\":\"bytes32\"}],\"name\":\"updateSendRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// AbsOutboxABI is the input ABI used to generate the binding from.
// Deprecated: Use AbsOutboxMetaData.ABI instead.
var AbsOutboxABI = AbsOutboxMetaData.ABI

// AbsOutbox is an auto generated Go binding around an Ethereum contract.
type AbsOutbox struct {
	AbsOutboxCaller     // Read-only binding to the contract
	AbsOutboxTransactor // Write-only binding to the contract
	AbsOutboxFilterer   // Log filterer for contract events
}

// AbsOutboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type AbsOutboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AbsOutboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type AbsOutboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AbsOutboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type AbsOutboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// AbsOutboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type AbsOutboxSession struct {
	Contract     *AbsOutbox        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// AbsOutboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type AbsOutboxCallerSession struct {
	Contract *AbsOutboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// AbsOutboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type AbsOutboxTransactorSession struct {
	Contract     *AbsOutboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// AbsOutboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type AbsOutboxRaw struct {
	Contract *AbsOutbox // Generic contract binding to access the raw methods on
}

// AbsOutboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type AbsOutboxCallerRaw struct {
	Contract *AbsOutboxCaller // Generic read-only contract binding to access the raw methods on
}

// AbsOutboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type AbsOutboxTransactorRaw struct {
	Contract *AbsOutboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewAbsOutbox creates a new instance of AbsOutbox, bound to a specific deployed contract.
func NewAbsOutbox(address common.Address, backend bind.ContractBackend) (*AbsOutbox, error) {
	contract, err := bindAbsOutbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &AbsOutbox{AbsOutboxCaller: AbsOutboxCaller{contract: contract}, AbsOutboxTransactor: AbsOutboxTransactor{contract: contract}, AbsOutboxFilterer: AbsOutboxFilterer{contract: contract}}, nil
}

// NewAbsOutboxCaller creates a new read-only instance of AbsOutbox, bound to a specific deployed contract.
func NewAbsOutboxCaller(address common.Address, caller bind.ContractCaller) (*AbsOutboxCaller, error) {
	contract, err := bindAbsOutbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &AbsOutboxCaller{contract: contract}, nil
}

// NewAbsOutboxTransactor creates a new write-only instance of AbsOutbox, bound to a specific deployed contract.
func NewAbsOutboxTransactor(address common.Address, transactor bind.ContractTransactor) (*AbsOutboxTransactor, error) {
	contract, err := bindAbsOutbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &AbsOutboxTransactor{contract: contract}, nil
}

// NewAbsOutboxFilterer creates a new log filterer instance of AbsOutbox, bound to a specific deployed contract.
func NewAbsOutboxFilterer(address common.Address, filterer bind.ContractFilterer) (*AbsOutboxFilterer, error) {
	contract, err := bindAbsOutbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &AbsOutboxFilterer{contract: contract}, nil
}

// bindAbsOutbox binds a generic wrapper to an already deployed contract.
func bindAbsOutbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := AbsOutboxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AbsOutbox *AbsOutboxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AbsOutbox.Contract.AbsOutboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AbsOutbox *AbsOutboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AbsOutbox.Contract.AbsOutboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AbsOutbox *AbsOutboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AbsOutbox.Contract.AbsOutboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_AbsOutbox *AbsOutboxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _AbsOutbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_AbsOutbox *AbsOutboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AbsOutbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_AbsOutbox *AbsOutboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _AbsOutbox.Contract.contract.Transact(opts, method, params...)
}

// OUTBOXVERSION is a free data retrieval call binding the contract method 0xc75184df.
//
// Solidity: function OUTBOX_VERSION() view returns(uint128)
func (_AbsOutbox *AbsOutboxCaller) OUTBOXVERSION(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "OUTBOX_VERSION")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// OUTBOXVERSION is a free data retrieval call binding the contract method 0xc75184df.
//
// Solidity: function OUTBOX_VERSION() view returns(uint128)
func (_AbsOutbox *AbsOutboxSession) OUTBOXVERSION() (*big.Int, error) {
	return _AbsOutbox.Contract.OUTBOXVERSION(&_AbsOutbox.CallOpts)
}

// OUTBOXVERSION is a free data retrieval call binding the contract method 0xc75184df.
//
// Solidity: function OUTBOX_VERSION() view returns(uint128)
func (_AbsOutbox *AbsOutboxCallerSession) OUTBOXVERSION() (*big.Int, error) {
	return _AbsOutbox.Contract.OUTBOXVERSION(&_AbsOutbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_AbsOutbox *AbsOutboxCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_AbsOutbox *AbsOutboxSession) Bridge() (common.Address, error) {
	return _AbsOutbox.Contract.Bridge(&_AbsOutbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_AbsOutbox *AbsOutboxCallerSession) Bridge() (common.Address, error) {
	return _AbsOutbox.Contract.Bridge(&_AbsOutbox.CallOpts)
}

// CalculateItemHash is a free data retrieval call binding the contract method 0x9f0c04bf.
//
// Solidity: function calculateItemHash(address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) pure returns(bytes32)
func (_AbsOutbox *AbsOutboxCaller) CalculateItemHash(opts *bind.CallOpts, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) ([32]byte, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "calculateItemHash", l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CalculateItemHash is a free data retrieval call binding the contract method 0x9f0c04bf.
//
// Solidity: function calculateItemHash(address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) pure returns(bytes32)
func (_AbsOutbox *AbsOutboxSession) CalculateItemHash(l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) ([32]byte, error) {
	return _AbsOutbox.Contract.CalculateItemHash(&_AbsOutbox.CallOpts, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// CalculateItemHash is a free data retrieval call binding the contract method 0x9f0c04bf.
//
// Solidity: function calculateItemHash(address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) pure returns(bytes32)
func (_AbsOutbox *AbsOutboxCallerSession) CalculateItemHash(l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) ([32]byte, error) {
	return _AbsOutbox.Contract.CalculateItemHash(&_AbsOutbox.CallOpts, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// CalculateMerkleRoot is a free data retrieval call binding the contract method 0x007436d3.
//
// Solidity: function calculateMerkleRoot(bytes32[] proof, uint256 path, bytes32 item) pure returns(bytes32)
func (_AbsOutbox *AbsOutboxCaller) CalculateMerkleRoot(opts *bind.CallOpts, proof [][32]byte, path *big.Int, item [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "calculateMerkleRoot", proof, path, item)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CalculateMerkleRoot is a free data retrieval call binding the contract method 0x007436d3.
//
// Solidity: function calculateMerkleRoot(bytes32[] proof, uint256 path, bytes32 item) pure returns(bytes32)
func (_AbsOutbox *AbsOutboxSession) CalculateMerkleRoot(proof [][32]byte, path *big.Int, item [32]byte) ([32]byte, error) {
	return _AbsOutbox.Contract.CalculateMerkleRoot(&_AbsOutbox.CallOpts, proof, path, item)
}

// CalculateMerkleRoot is a free data retrieval call binding the contract method 0x007436d3.
//
// Solidity: function calculateMerkleRoot(bytes32[] proof, uint256 path, bytes32 item) pure returns(bytes32)
func (_AbsOutbox *AbsOutboxCallerSession) CalculateMerkleRoot(proof [][32]byte, path *big.Int, item [32]byte) ([32]byte, error) {
	return _AbsOutbox.Contract.CalculateMerkleRoot(&_AbsOutbox.CallOpts, proof, path, item)
}

// IsSpent is a free data retrieval call binding the contract method 0x5a129efe.
//
// Solidity: function isSpent(uint256 index) view returns(bool)
func (_AbsOutbox *AbsOutboxCaller) IsSpent(opts *bind.CallOpts, index *big.Int) (bool, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "isSpent", index)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSpent is a free data retrieval call binding the contract method 0x5a129efe.
//
// Solidity: function isSpent(uint256 index) view returns(bool)
func (_AbsOutbox *AbsOutboxSession) IsSpent(index *big.Int) (bool, error) {
	return _AbsOutbox.Contract.IsSpent(&_AbsOutbox.CallOpts, index)
}

// IsSpent is a free data retrieval call binding the contract method 0x5a129efe.
//
// Solidity: function isSpent(uint256 index) view returns(bool)
func (_AbsOutbox *AbsOutboxCallerSession) IsSpent(index *big.Int) (bool, error) {
	return _AbsOutbox.Contract.IsSpent(&_AbsOutbox.CallOpts, index)
}

// L2ToL1BatchNum is a free data retrieval call binding the contract method 0x11985271.
//
// Solidity: function l2ToL1BatchNum() pure returns(uint256)
func (_AbsOutbox *AbsOutboxCaller) L2ToL1BatchNum(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "l2ToL1BatchNum")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1BatchNum is a free data retrieval call binding the contract method 0x11985271.
//
// Solidity: function l2ToL1BatchNum() pure returns(uint256)
func (_AbsOutbox *AbsOutboxSession) L2ToL1BatchNum() (*big.Int, error) {
	return _AbsOutbox.Contract.L2ToL1BatchNum(&_AbsOutbox.CallOpts)
}

// L2ToL1BatchNum is a free data retrieval call binding the contract method 0x11985271.
//
// Solidity: function l2ToL1BatchNum() pure returns(uint256)
func (_AbsOutbox *AbsOutboxCallerSession) L2ToL1BatchNum() (*big.Int, error) {
	return _AbsOutbox.Contract.L2ToL1BatchNum(&_AbsOutbox.CallOpts)
}

// L2ToL1Block is a free data retrieval call binding the contract method 0x46547790.
//
// Solidity: function l2ToL1Block() view returns(uint256)
func (_AbsOutbox *AbsOutboxCaller) L2ToL1Block(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "l2ToL1Block")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1Block is a free data retrieval call binding the contract method 0x46547790.
//
// Solidity: function l2ToL1Block() view returns(uint256)
func (_AbsOutbox *AbsOutboxSession) L2ToL1Block() (*big.Int, error) {
	return _AbsOutbox.Contract.L2ToL1Block(&_AbsOutbox.CallOpts)
}

// L2ToL1Block is a free data retrieval call binding the contract method 0x46547790.
//
// Solidity: function l2ToL1Block() view returns(uint256)
func (_AbsOutbox *AbsOutboxCallerSession) L2ToL1Block() (*big.Int, error) {
	return _AbsOutbox.Contract.L2ToL1Block(&_AbsOutbox.CallOpts)
}

// L2ToL1EthBlock is a free data retrieval call binding the contract method 0x8515bc6a.
//
// Solidity: function l2ToL1EthBlock() view returns(uint256)
func (_AbsOutbox *AbsOutboxCaller) L2ToL1EthBlock(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "l2ToL1EthBlock")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1EthBlock is a free data retrieval call binding the contract method 0x8515bc6a.
//
// Solidity: function l2ToL1EthBlock() view returns(uint256)
func (_AbsOutbox *AbsOutboxSession) L2ToL1EthBlock() (*big.Int, error) {
	return _AbsOutbox.Contract.L2ToL1EthBlock(&_AbsOutbox.CallOpts)
}

// L2ToL1EthBlock is a free data retrieval call binding the contract method 0x8515bc6a.
//
// Solidity: function l2ToL1EthBlock() view returns(uint256)
func (_AbsOutbox *AbsOutboxCallerSession) L2ToL1EthBlock() (*big.Int, error) {
	return _AbsOutbox.Contract.L2ToL1EthBlock(&_AbsOutbox.CallOpts)
}

// L2ToL1OutputId is a free data retrieval call binding the contract method 0x72f2a8c7.
//
// Solidity: function l2ToL1OutputId() view returns(bytes32)
func (_AbsOutbox *AbsOutboxCaller) L2ToL1OutputId(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "l2ToL1OutputId")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// L2ToL1OutputId is a free data retrieval call binding the contract method 0x72f2a8c7.
//
// Solidity: function l2ToL1OutputId() view returns(bytes32)
func (_AbsOutbox *AbsOutboxSession) L2ToL1OutputId() ([32]byte, error) {
	return _AbsOutbox.Contract.L2ToL1OutputId(&_AbsOutbox.CallOpts)
}

// L2ToL1OutputId is a free data retrieval call binding the contract method 0x72f2a8c7.
//
// Solidity: function l2ToL1OutputId() view returns(bytes32)
func (_AbsOutbox *AbsOutboxCallerSession) L2ToL1OutputId() ([32]byte, error) {
	return _AbsOutbox.Contract.L2ToL1OutputId(&_AbsOutbox.CallOpts)
}

// L2ToL1Sender is a free data retrieval call binding the contract method 0x80648b02.
//
// Solidity: function l2ToL1Sender() view returns(address)
func (_AbsOutbox *AbsOutboxCaller) L2ToL1Sender(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "l2ToL1Sender")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// L2ToL1Sender is a free data retrieval call binding the contract method 0x80648b02.
//
// Solidity: function l2ToL1Sender() view returns(address)
func (_AbsOutbox *AbsOutboxSession) L2ToL1Sender() (common.Address, error) {
	return _AbsOutbox.Contract.L2ToL1Sender(&_AbsOutbox.CallOpts)
}

// L2ToL1Sender is a free data retrieval call binding the contract method 0x80648b02.
//
// Solidity: function l2ToL1Sender() view returns(address)
func (_AbsOutbox *AbsOutboxCallerSession) L2ToL1Sender() (common.Address, error) {
	return _AbsOutbox.Contract.L2ToL1Sender(&_AbsOutbox.CallOpts)
}

// L2ToL1Timestamp is a free data retrieval call binding the contract method 0xb0f30537.
//
// Solidity: function l2ToL1Timestamp() view returns(uint256)
func (_AbsOutbox *AbsOutboxCaller) L2ToL1Timestamp(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "l2ToL1Timestamp")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1Timestamp is a free data retrieval call binding the contract method 0xb0f30537.
//
// Solidity: function l2ToL1Timestamp() view returns(uint256)
func (_AbsOutbox *AbsOutboxSession) L2ToL1Timestamp() (*big.Int, error) {
	return _AbsOutbox.Contract.L2ToL1Timestamp(&_AbsOutbox.CallOpts)
}

// L2ToL1Timestamp is a free data retrieval call binding the contract method 0xb0f30537.
//
// Solidity: function l2ToL1Timestamp() view returns(uint256)
func (_AbsOutbox *AbsOutboxCallerSession) L2ToL1Timestamp() (*big.Int, error) {
	return _AbsOutbox.Contract.L2ToL1Timestamp(&_AbsOutbox.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_AbsOutbox *AbsOutboxCaller) Rollup(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "rollup")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_AbsOutbox *AbsOutboxSession) Rollup() (common.Address, error) {
	return _AbsOutbox.Contract.Rollup(&_AbsOutbox.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_AbsOutbox *AbsOutboxCallerSession) Rollup() (common.Address, error) {
	return _AbsOutbox.Contract.Rollup(&_AbsOutbox.CallOpts)
}

// Roots is a free data retrieval call binding the contract method 0xae6dead7.
//
// Solidity: function roots(bytes32 ) view returns(bytes32)
func (_AbsOutbox *AbsOutboxCaller) Roots(opts *bind.CallOpts, arg0 [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "roots", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Roots is a free data retrieval call binding the contract method 0xae6dead7.
//
// Solidity: function roots(bytes32 ) view returns(bytes32)
func (_AbsOutbox *AbsOutboxSession) Roots(arg0 [32]byte) ([32]byte, error) {
	return _AbsOutbox.Contract.Roots(&_AbsOutbox.CallOpts, arg0)
}

// Roots is a free data retrieval call binding the contract method 0xae6dead7.
//
// Solidity: function roots(bytes32 ) view returns(bytes32)
func (_AbsOutbox *AbsOutboxCallerSession) Roots(arg0 [32]byte) ([32]byte, error) {
	return _AbsOutbox.Contract.Roots(&_AbsOutbox.CallOpts, arg0)
}

// Spent is a free data retrieval call binding the contract method 0xd5b5cc23.
//
// Solidity: function spent(uint256 ) view returns(bytes32)
func (_AbsOutbox *AbsOutboxCaller) Spent(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _AbsOutbox.contract.Call(opts, &out, "spent", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Spent is a free data retrieval call binding the contract method 0xd5b5cc23.
//
// Solidity: function spent(uint256 ) view returns(bytes32)
func (_AbsOutbox *AbsOutboxSession) Spent(arg0 *big.Int) ([32]byte, error) {
	return _AbsOutbox.Contract.Spent(&_AbsOutbox.CallOpts, arg0)
}

// Spent is a free data retrieval call binding the contract method 0xd5b5cc23.
//
// Solidity: function spent(uint256 ) view returns(bytes32)
func (_AbsOutbox *AbsOutboxCallerSession) Spent(arg0 *big.Int) ([32]byte, error) {
	return _AbsOutbox.Contract.Spent(&_AbsOutbox.CallOpts, arg0)
}

// ExecuteTransaction is a paid mutator transaction binding the contract method 0x08635a95.
//
// Solidity: function executeTransaction(bytes32[] proof, uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_AbsOutbox *AbsOutboxTransactor) ExecuteTransaction(opts *bind.TransactOpts, proof [][32]byte, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsOutbox.contract.Transact(opts, "executeTransaction", proof, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransaction is a paid mutator transaction binding the contract method 0x08635a95.
//
// Solidity: function executeTransaction(bytes32[] proof, uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_AbsOutbox *AbsOutboxSession) ExecuteTransaction(proof [][32]byte, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsOutbox.Contract.ExecuteTransaction(&_AbsOutbox.TransactOpts, proof, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransaction is a paid mutator transaction binding the contract method 0x08635a95.
//
// Solidity: function executeTransaction(bytes32[] proof, uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_AbsOutbox *AbsOutboxTransactorSession) ExecuteTransaction(proof [][32]byte, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsOutbox.Contract.ExecuteTransaction(&_AbsOutbox.TransactOpts, proof, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransactionSimulation is a paid mutator transaction binding the contract method 0x288e5b10.
//
// Solidity: function executeTransactionSimulation(uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_AbsOutbox *AbsOutboxTransactor) ExecuteTransactionSimulation(opts *bind.TransactOpts, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsOutbox.contract.Transact(opts, "executeTransactionSimulation", index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransactionSimulation is a paid mutator transaction binding the contract method 0x288e5b10.
//
// Solidity: function executeTransactionSimulation(uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_AbsOutbox *AbsOutboxSession) ExecuteTransactionSimulation(index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsOutbox.Contract.ExecuteTransactionSimulation(&_AbsOutbox.TransactOpts, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransactionSimulation is a paid mutator transaction binding the contract method 0x288e5b10.
//
// Solidity: function executeTransactionSimulation(uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_AbsOutbox *AbsOutboxTransactorSession) ExecuteTransactionSimulation(index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _AbsOutbox.Contract.ExecuteTransactionSimulation(&_AbsOutbox.TransactOpts, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _bridge) returns()
func (_AbsOutbox *AbsOutboxTransactor) Initialize(opts *bind.TransactOpts, _bridge common.Address) (*types.Transaction, error) {
	return _AbsOutbox.contract.Transact(opts, "initialize", _bridge)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _bridge) returns()
func (_AbsOutbox *AbsOutboxSession) Initialize(_bridge common.Address) (*types.Transaction, error) {
	return _AbsOutbox.Contract.Initialize(&_AbsOutbox.TransactOpts, _bridge)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _bridge) returns()
func (_AbsOutbox *AbsOutboxTransactorSession) Initialize(_bridge common.Address) (*types.Transaction, error) {
	return _AbsOutbox.Contract.Initialize(&_AbsOutbox.TransactOpts, _bridge)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0x95fcea78.
//
// Solidity: function postUpgradeInit() returns()
func (_AbsOutbox *AbsOutboxTransactor) PostUpgradeInit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AbsOutbox.contract.Transact(opts, "postUpgradeInit")
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0x95fcea78.
//
// Solidity: function postUpgradeInit() returns()
func (_AbsOutbox *AbsOutboxSession) PostUpgradeInit() (*types.Transaction, error) {
	return _AbsOutbox.Contract.PostUpgradeInit(&_AbsOutbox.TransactOpts)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0x95fcea78.
//
// Solidity: function postUpgradeInit() returns()
func (_AbsOutbox *AbsOutboxTransactorSession) PostUpgradeInit() (*types.Transaction, error) {
	return _AbsOutbox.Contract.PostUpgradeInit(&_AbsOutbox.TransactOpts)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_AbsOutbox *AbsOutboxTransactor) UpdateRollupAddress(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _AbsOutbox.contract.Transact(opts, "updateRollupAddress")
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_AbsOutbox *AbsOutboxSession) UpdateRollupAddress() (*types.Transaction, error) {
	return _AbsOutbox.Contract.UpdateRollupAddress(&_AbsOutbox.TransactOpts)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_AbsOutbox *AbsOutboxTransactorSession) UpdateRollupAddress() (*types.Transaction, error) {
	return _AbsOutbox.Contract.UpdateRollupAddress(&_AbsOutbox.TransactOpts)
}

// UpdateSendRoot is a paid mutator transaction binding the contract method 0xa04cee60.
//
// Solidity: function updateSendRoot(bytes32 root, bytes32 l2BlockHash) returns()
func (_AbsOutbox *AbsOutboxTransactor) UpdateSendRoot(opts *bind.TransactOpts, root [32]byte, l2BlockHash [32]byte) (*types.Transaction, error) {
	return _AbsOutbox.contract.Transact(opts, "updateSendRoot", root, l2BlockHash)
}

// UpdateSendRoot is a paid mutator transaction binding the contract method 0xa04cee60.
//
// Solidity: function updateSendRoot(bytes32 root, bytes32 l2BlockHash) returns()
func (_AbsOutbox *AbsOutboxSession) UpdateSendRoot(root [32]byte, l2BlockHash [32]byte) (*types.Transaction, error) {
	return _AbsOutbox.Contract.UpdateSendRoot(&_AbsOutbox.TransactOpts, root, l2BlockHash)
}

// UpdateSendRoot is a paid mutator transaction binding the contract method 0xa04cee60.
//
// Solidity: function updateSendRoot(bytes32 root, bytes32 l2BlockHash) returns()
func (_AbsOutbox *AbsOutboxTransactorSession) UpdateSendRoot(root [32]byte, l2BlockHash [32]byte) (*types.Transaction, error) {
	return _AbsOutbox.Contract.UpdateSendRoot(&_AbsOutbox.TransactOpts, root, l2BlockHash)
}

// AbsOutboxOutBoxTransactionExecutedIterator is returned from FilterOutBoxTransactionExecuted and is used to iterate over the raw logs and unpacked data for OutBoxTransactionExecuted events raised by the AbsOutbox contract.
type AbsOutboxOutBoxTransactionExecutedIterator struct {
	Event *AbsOutboxOutBoxTransactionExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsOutboxOutBoxTransactionExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsOutboxOutBoxTransactionExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsOutboxOutBoxTransactionExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsOutboxOutBoxTransactionExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsOutboxOutBoxTransactionExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsOutboxOutBoxTransactionExecuted represents a OutBoxTransactionExecuted event raised by the AbsOutbox contract.
type AbsOutboxOutBoxTransactionExecuted struct {
	To               common.Address
	L2Sender         common.Address
	Zero             *big.Int
	TransactionIndex *big.Int
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterOutBoxTransactionExecuted is a free log retrieval operation binding the contract event 0x20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab18964.
//
// Solidity: event OutBoxTransactionExecuted(address indexed to, address indexed l2Sender, uint256 indexed zero, uint256 transactionIndex)
func (_AbsOutbox *AbsOutboxFilterer) FilterOutBoxTransactionExecuted(opts *bind.FilterOpts, to []common.Address, l2Sender []common.Address, zero []*big.Int) (*AbsOutboxOutBoxTransactionExecutedIterator, error) {

	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var l2SenderRule []interface{}
	for _, l2SenderItem := range l2Sender {
		l2SenderRule = append(l2SenderRule, l2SenderItem)
	}
	var zeroRule []interface{}
	for _, zeroItem := range zero {
		zeroRule = append(zeroRule, zeroItem)
	}

	logs, sub, err := _AbsOutbox.contract.FilterLogs(opts, "OutBoxTransactionExecuted", toRule, l2SenderRule, zeroRule)
	if err != nil {
		return nil, err
	}
	return &AbsOutboxOutBoxTransactionExecutedIterator{contract: _AbsOutbox.contract, event: "OutBoxTransactionExecuted", logs: logs, sub: sub}, nil
}

// WatchOutBoxTransactionExecuted is a free log subscription operation binding the contract event 0x20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab18964.
//
// Solidity: event OutBoxTransactionExecuted(address indexed to, address indexed l2Sender, uint256 indexed zero, uint256 transactionIndex)
func (_AbsOutbox *AbsOutboxFilterer) WatchOutBoxTransactionExecuted(opts *bind.WatchOpts, sink chan<- *AbsOutboxOutBoxTransactionExecuted, to []common.Address, l2Sender []common.Address, zero []*big.Int) (event.Subscription, error) {

	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var l2SenderRule []interface{}
	for _, l2SenderItem := range l2Sender {
		l2SenderRule = append(l2SenderRule, l2SenderItem)
	}
	var zeroRule []interface{}
	for _, zeroItem := range zero {
		zeroRule = append(zeroRule, zeroItem)
	}

	logs, sub, err := _AbsOutbox.contract.WatchLogs(opts, "OutBoxTransactionExecuted", toRule, l2SenderRule, zeroRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsOutboxOutBoxTransactionExecuted)
				if err := _AbsOutbox.contract.UnpackLog(event, "OutBoxTransactionExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOutBoxTransactionExecuted is a log parse operation binding the contract event 0x20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab18964.
//
// Solidity: event OutBoxTransactionExecuted(address indexed to, address indexed l2Sender, uint256 indexed zero, uint256 transactionIndex)
func (_AbsOutbox *AbsOutboxFilterer) ParseOutBoxTransactionExecuted(log types.Log) (*AbsOutboxOutBoxTransactionExecuted, error) {
	event := new(AbsOutboxOutBoxTransactionExecuted)
	if err := _AbsOutbox.contract.UnpackLog(event, "OutBoxTransactionExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// AbsOutboxSendRootUpdatedIterator is returned from FilterSendRootUpdated and is used to iterate over the raw logs and unpacked data for SendRootUpdated events raised by the AbsOutbox contract.
type AbsOutboxSendRootUpdatedIterator struct {
	Event *AbsOutboxSendRootUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *AbsOutboxSendRootUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(AbsOutboxSendRootUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(AbsOutboxSendRootUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *AbsOutboxSendRootUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *AbsOutboxSendRootUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// AbsOutboxSendRootUpdated represents a SendRootUpdated event raised by the AbsOutbox contract.
type AbsOutboxSendRootUpdated struct {
	OutputRoot  [32]byte
	L2BlockHash [32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSendRootUpdated is a free log retrieval operation binding the contract event 0xb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f6748.
//
// Solidity: event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash)
func (_AbsOutbox *AbsOutboxFilterer) FilterSendRootUpdated(opts *bind.FilterOpts, outputRoot [][32]byte, l2BlockHash [][32]byte) (*AbsOutboxSendRootUpdatedIterator, error) {

	var outputRootRule []interface{}
	for _, outputRootItem := range outputRoot {
		outputRootRule = append(outputRootRule, outputRootItem)
	}
	var l2BlockHashRule []interface{}
	for _, l2BlockHashItem := range l2BlockHash {
		l2BlockHashRule = append(l2BlockHashRule, l2BlockHashItem)
	}

	logs, sub, err := _AbsOutbox.contract.FilterLogs(opts, "SendRootUpdated", outputRootRule, l2BlockHashRule)
	if err != nil {
		return nil, err
	}
	return &AbsOutboxSendRootUpdatedIterator{contract: _AbsOutbox.contract, event: "SendRootUpdated", logs: logs, sub: sub}, nil
}

// WatchSendRootUpdated is a free log subscription operation binding the contract event 0xb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f6748.
//
// Solidity: event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash)
func (_AbsOutbox *AbsOutboxFilterer) WatchSendRootUpdated(opts *bind.WatchOpts, sink chan<- *AbsOutboxSendRootUpdated, outputRoot [][32]byte, l2BlockHash [][32]byte) (event.Subscription, error) {

	var outputRootRule []interface{}
	for _, outputRootItem := range outputRoot {
		outputRootRule = append(outputRootRule, outputRootItem)
	}
	var l2BlockHashRule []interface{}
	for _, l2BlockHashItem := range l2BlockHash {
		l2BlockHashRule = append(l2BlockHashRule, l2BlockHashItem)
	}

	logs, sub, err := _AbsOutbox.contract.WatchLogs(opts, "SendRootUpdated", outputRootRule, l2BlockHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(AbsOutboxSendRootUpdated)
				if err := _AbsOutbox.contract.UnpackLog(event, "SendRootUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSendRootUpdated is a log parse operation binding the contract event 0xb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f6748.
//
// Solidity: event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash)
func (_AbsOutbox *AbsOutboxFilterer) ParseSendRootUpdated(log types.Log) (*AbsOutboxSendRootUpdated, error) {
	event := new(AbsOutboxSendRootUpdated)
	if err := _AbsOutbox.contract.UnpackLog(event, "SendRootUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BridgeMetaData contains all meta data concerning the Bridge contract.
var BridgeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stored\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"BadSequencerMessageNumber\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"}],\"name\":\"InvalidOutboxSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NotContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotDelayedInbox\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotOutbox\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotRollupOrOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotSequencerInbox\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BridgeCallTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"InboxToggle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beforeInboxAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"MessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OutboxToggle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"}],\"name\":\"RollupUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSequencerInbox\",\"type\":\"address\"}],\"name\":\"SequencerInboxUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptFundsFromOldBridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeOutbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedDelayedInboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"}],\"name\":\"allowedDelayedInboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedOutboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"}],\"name\":\"allowedOutboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"delayedInboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayedMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"name\":\"enqueueDelayedMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"}],\"name\":\"enqueueSequencerMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seqMessageIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"beforeAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"delayedAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"acc\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"rollup_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sequencerInboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerReportedSubMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setDelayedInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setOutbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"setSequencerInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMsgCount\",\"type\":\"uint256\"}],\"name\":\"setSequencerReportedSubMessageCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"name\":\"submitBatchSpendingReport\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"_rollup\",\"type\":\"address\"}],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a0806040523461002357306080526115b190816100298239608051816103e50152f35b600080fdfe608060408181526004908136101561001657600080fd5b600092833560e01c90816284120c14610fe65750806316bf557914610fbb578063413b35bd14610f7957806347fb24c514610edd5780634f61f85014610df15780635fca4a1614610dd25780637a88b10714610c5f57806386598a5614610a9d5780638db5993b146108ec578063919cc70614610801578063945e1147146107c15780639e5d4c49146105be578063ab5d894314610590578063ae60bd131461054f578063c4d66de814610389578063cb23bcb514610360578063cee3d728146102b7578063d5719dc21461027e578063e76f5c8d1461023d578063e77145f41461022b578063eca067ad1461020c578063ee35f327146101df5763f81ff3b31461012057600080fd5b346101db5760203660031901126101db576008546001600160a01b039081169133839003610153575b50505035600a5580f35b8051638da5cb5b60e01b8152916020838681875afa9283156101d15786936101a1575b5082163303156101495751630739600760e01b81529350839261019d929033908501611177565b0390fd5b6101c391935060203d81116101ca575b6101bb8183611135565b810190611158565b9138610176565b503d6101b1565b82513d88823e3d90fd5b8280fd5b83823461020857816003193601126102085760095490516001600160a01b039091168152602090f35b5080fd5b8382346102085781600319360112610208576020906006549051908152f35b838060031936011261023a5780f35b80fd5b5090346101db5760203660031901126101db57359160035483101561023a5750610268602092611069565b60018060a01b0391549060031b1c169051908152f35b5090346101db5760203660031901126101db57359160065483101561023a57506102a9602092611033565b91905490519160031b1c8152f35b50919034610208576102c83661109f565b9160018060a01b038060085416958633036102ec575b856102e986866113b9565b80f35b8051638da5cb5b60e01b81529160208385818b5afa928315610356578793610336575b5082163303156102de5751630739600760e01b815291829161019d91889033908501611177565b61034f91935060203d81116101ca576101bb8183611135565b913861030f565b82513d89823e3d90fd5b83823461020857816003193601126102085760085490516001600160a01b039091168152602090f35b5090346101db5760203660031901126101db5780356001600160a01b038181169182900361054b5784549260ff8460081c16159384809561053e575b8015610527575b156104cd5760ff1981166001178755846104bc575b50817f0000000000000000000000000000000000000000000000000000000000000000163014610464575060018060a01b031990816005541617600555600854161760085561042e575080f35b60207f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989161ff001984541684555160018152a180f35b608490602086519162461bcd60e51b8352820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201526b19195b1959d85d1958d85b1b60a21b6064820152fd5b61ffff1916610101178655386103e1565b855162461bcd60e51b8152602081840152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608490fd5b50303b1580156103cc5750600160ff8216146103cc565b50600160ff8216106103c5565b8480fd5b8382346102085760203660031901126102085760209160ff9060019083906001600160a01b0361057d611084565b1681528286522001541690519015158152f35b8382346102085781600319360112610208576020906105ad61119a565b90516001600160a01b039091168152f35b50823461023a5760609182600319360112610208576105db611084565b604435949092906024356001600160401b038088116107bd57366023890112156107bd57878301359081116107bd57602488019760248236920101116107bd573384526020926002845260ff6001878720015416156107a6578115158061079d575b61077b5750600580546001600160a01b03198082163317909255909291907f2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466908287808b8e888d610699610690886111de565b91519182611135565b868152868d8201938437848d888301015251925af19b3d1561076e573d966106c0886111de565b976106cd8c51998a611135565b88523d8a8a8a013e9c99979c9a98969a5b60018060a01b038094169060055416176005558751958652878d87015281888701528b860137848a8486010152601f19961692898188601f339601168101030190a381519687941515855282818601528551809386015281955b8387106107565750508394508582601f949501015201168101030190f35b86810182015189880189015295810195889550610738565b8b9a98969c99979c6106de565b855163b5cf5b8f60e01b81526001600160a01b03881691810191909152602490fd5b50863b1561063d565b6024908651906332ea82ab60e01b82523390820152fd5b8380fd5b50823461023a57602036600319011261023a578235925483101561023a57506107eb60209261104e565b905491519160018060a01b039160031b1c168152f35b50346101db5760203660031901126101db5781356001600160a01b03818116939184900361054b576008549181831691823303610879575b6001600160a01b031984168617600855845186815287907fae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a90602090a180f35b8451638da5cb5b60e01b8152906020828481875afa9182156108e25788926108c2575b5081163303156108395761019d908551938493630739600760e01b855233908501611177565b6108db91925060203d81116101ca576101bb8183611135565b903861089c565b86513d8a823e3d90fd5b50829060603660031901126102085782359160ff831680840361020857602435936001600160a01b0385168086036107bd5760443591338552600160205260ff600187872001541615610a8757600654865160f89290921b6001600160f81b0319166020830190815260609890981b6001600160601b03191660218301524360c090811b6001600160c01b031990811660358501524290911b16603d830152604582018190524860658301526085808301859052825296906109ad816110ff565b519020968487610a27575b5050859260008051602061155c8339815191529260c0926109f660209a89518c8101918a83528b8201528a81526109ee8161111a565b5190206111b8565b87513381528a810193909352828801526060820152486080820152426001600160401b031660a0820152a351908152f35b90979450600019870190878211610a745750602097509260008051602061155c8339815191529260c0926109f6610a5e8a97611033565b90549060031b1c979a50509250928194506109b8565b634e487b7160e01b815260118952602490fd5b855163b6c60ea360e01b815233818a0152602490fd5b5090346101db5760803660031901126101db57600954602493843593604435929091906001600160a01b03163303610c4a57808093600a548181141580610c41575b80610c38575b610c1d575050606435600a556007549586610be7575b80610baf575b508251602081018381528635828601526060808301879052825290608081016001600160401b03811182821017610b9d57855251902094600160401b871015610b8b575050608095506001850160075583610b75610b5e87611002565b819391549060031b91821b91600019901b19161790565b9055815194855260208501528301526060820152f35b634e487b7160e01b8252604190528690fd5b634e487b7160e01b8452604188528984fd5b9093506000198101908111610bd557610bc790611033565b90549060031b1c9238610b01565b634e487b7160e01b8452601185528684fd5b91506000198601868111610c0b57610bfe90611002565b90549060031b1c91610afb565b634e487b7160e01b8252601186528782fd5b60449189889287519363e2051feb60e01b8552840152820152fd5b50801515610ae5565b50811515610adf565b815163223e13c160e21b815233818601528690fd5b50829034610208578060031936011261020857610c7a611084565b6009546001600160a01b039391906024359085163303610dbc576006548451600d60f81b602082019081526001600160601b0319606086901b1660218301526001600160c01b03194360c090811b8216603585015242901b16603d830152604582018390524860658301526085808301859052825291969190610cfc816110ff565b519020968487610d6f575b5050859260008051602061155c8339815191529260c092610d3d60209a89518c8101918a83528b8201528a81526109ee8161111a565b8751338152600d8b8201529216828801526060820152486080820152426001600160401b031660a0820152a351908152f35b90979450600019870190878211610a745750602097509260008051602061155c8339815191529260c092610d3d610da68a97611033565b90549060031b1c979a5050925092819450610d07565b835163223e13c160e21b81523381880152602490fd5b838234610208578160031936011261020857602090600a549051908152f35b5090346101db5760203660031901126101db57610e0c611084565b6008546001600160a01b03929083169033829003610e67575b857f8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a602087878716908160018060a01b0319600954161760095551908152a180f35b8451638da5cb5b60e01b81526020818381865afa908115610ed3578791610eb5575b508481163303610e995750610e25565b61019d908651938493630739600760e01b855233908501611177565b610ecd915060203d81116101ca576101bb8183611135565b38610e89565b86513d89823e3d90fd5b5091903461020857610eee3661109f565b9160018060a01b03806008541695863303610f0f575b856102e98686611217565b8051638da5cb5b60e01b81529160208385818b5afa928315610356578793610f59575b508216330315610f045751630739600760e01b815291829161019d91889033908501611177565b610f7291935060203d81116101ca576101bb8183611135565b9138610f32565b8382346102085760203660031901126102085760209160ff9060019083906001600160a01b03610fa7611084565b168152600286522001541690519015158152f35b5090346101db5760203660031901126101db57359160075483101561023a57506102a9602092611002565b8490346102085781600319360112610208576020906007548152f35b60075481101561101d57600760005260206000200190600090565b634e487b7160e01b600052603260045260246000fd5b60065481101561101d57600660005260206000200190600090565b60045481101561101d57600460005260206000200190600090565b60035481101561101d57600360005260206000200190600090565b600435906001600160a01b038216820361109a57565b600080fd5b604090600319011261109a576004356001600160a01b038116810361109a5790602435801515810361109a5790565b604081019081106001600160401b038211176110e957604052565b634e487b7160e01b600052604160045260246000fd5b60c081019081106001600160401b038211176110e957604052565b606081019081106001600160401b038211176110e957604052565b601f909101601f19168101906001600160401b038211908210176110e957604052565b9081602091031261109a57516001600160a01b038116810361109a5790565b6001600160a01b0391821681529181166020830152909116604082015260600190565b6005546001600160a01b039081169081146111b25790565b50600090565b600654600160401b8110156110e957610b5e8160016111da9301600655611033565b9055565b6001600160401b0381116110e957601f01601f191660200190565b919082549060031b9160018060a01b03809116831b921b1916179055565b9060018060a01b038083166000928184526001926020918483526040918287209160ff8784015416845190877f6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf5218885151594858152a21515146113ae57156112f2575050908391826003549282519361128f856110ce565b845280840195828752885252852090518155019051151560ff8019835416911617905560035491600160401b8310156112de5750816112d6916112dc949301600355611069565b906111f9565b565b634e487b7160e01b81526041600452602490fd5b909194959650600393929354916000199283810190811161139a578261131a61132c92611069565b90549060031b1c166112d68354611069565b549061133782611069565b90549060031b1c16875285845284872055600354801561138657859392910161137761136282611069565b81549060018060a01b039060031b1b19169055565b60035585525282208281550155565b634e487b7160e01b87526031600452602487fd5b634e487b7160e01b89526011600452602489fd5b505050505050505050565b906001600160a01b03908183169081831461154257600092828452602091600283526040918286209160ff600184015416845190877f49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa8885151594858152a215151461153857156114845750509060019160026004549282519361143c856110ce565b845280840195858752875252842090518155019051151560ff8019835416911617905560045490600160401b8210156112de5750906112d68260016112dc940160045561104e565b90919495506004939293549160001992838101908111611524576114aa6114c59161104e565b9054846114b7855461104e565b92909360031b1c16916111f9565b54906114d08261104e565b90549060031b1c1686526002845284862055600454801561151057916001949391600293016115016113628261104e565b60045585525282208281550155565b634e487b7160e01b86526031600452602486fd5b634e487b7160e01b88526011600452602488fd5b5050505050505050565b60405163077abed160e41b815260048101839052602490fdfe5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1a26469706673582212205e42e73ecde95234f887c438520ffab2e35fa25cbd18d06eae61e4dc90639dab64736f6c63430008130033",
}

// BridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use BridgeMetaData.ABI instead.
var BridgeABI = BridgeMetaData.ABI

// BridgeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use BridgeMetaData.Bin instead.
var BridgeBin = BridgeMetaData.Bin

// DeployBridge deploys a new Ethereum contract, binding an instance of Bridge to it.
func DeployBridge(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Bridge, error) {
	parsed, err := BridgeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(BridgeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Bridge{BridgeCaller: BridgeCaller{contract: contract}, BridgeTransactor: BridgeTransactor{contract: contract}, BridgeFilterer: BridgeFilterer{contract: contract}}, nil
}

// Bridge is an auto generated Go binding around an Ethereum contract.
type Bridge struct {
	BridgeCaller     // Read-only binding to the contract
	BridgeTransactor // Write-only binding to the contract
	BridgeFilterer   // Log filterer for contract events
}

// BridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type BridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BridgeSession struct {
	Contract     *Bridge           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BridgeCallerSession struct {
	Contract *BridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// BridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BridgeTransactorSession struct {
	Contract     *BridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type BridgeRaw struct {
	Contract *Bridge // Generic contract binding to access the raw methods on
}

// BridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BridgeCallerRaw struct {
	Contract *BridgeCaller // Generic read-only contract binding to access the raw methods on
}

// BridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BridgeTransactorRaw struct {
	Contract *BridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBridge creates a new instance of Bridge, bound to a specific deployed contract.
func NewBridge(address common.Address, backend bind.ContractBackend) (*Bridge, error) {
	contract, err := bindBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Bridge{BridgeCaller: BridgeCaller{contract: contract}, BridgeTransactor: BridgeTransactor{contract: contract}, BridgeFilterer: BridgeFilterer{contract: contract}}, nil
}

// NewBridgeCaller creates a new read-only instance of Bridge, bound to a specific deployed contract.
func NewBridgeCaller(address common.Address, caller bind.ContractCaller) (*BridgeCaller, error) {
	contract, err := bindBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeCaller{contract: contract}, nil
}

// NewBridgeTransactor creates a new write-only instance of Bridge, bound to a specific deployed contract.
func NewBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*BridgeTransactor, error) {
	contract, err := bindBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BridgeTransactor{contract: contract}, nil
}

// NewBridgeFilterer creates a new log filterer instance of Bridge, bound to a specific deployed contract.
func NewBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*BridgeFilterer, error) {
	contract, err := bindBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BridgeFilterer{contract: contract}, nil
}

// bindBridge binds a generic wrapper to an already deployed contract.
func bindBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := BridgeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Bridge *BridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Bridge.Contract.BridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Bridge *BridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Bridge.Contract.BridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Bridge *BridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Bridge.Contract.BridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Bridge *BridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Bridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Bridge *BridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Bridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Bridge *BridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Bridge.Contract.contract.Transact(opts, method, params...)
}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_Bridge *BridgeCaller) ActiveOutbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Bridge.contract.Call(opts, &out, "activeOutbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_Bridge *BridgeSession) ActiveOutbox() (common.Address, error) {
	return _Bridge.Contract.ActiveOutbox(&_Bridge.CallOpts)
}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_Bridge *BridgeCallerSession) ActiveOutbox() (common.Address, error) {
	return _Bridge.Contract.ActiveOutbox(&_Bridge.CallOpts)
}

// AllowedDelayedInboxList is a free data retrieval call binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) view returns(address)
func (_Bridge *BridgeCaller) AllowedDelayedInboxList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _Bridge.contract.Call(opts, &out, "allowedDelayedInboxList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AllowedDelayedInboxList is a free data retrieval call binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) view returns(address)
func (_Bridge *BridgeSession) AllowedDelayedInboxList(arg0 *big.Int) (common.Address, error) {
	return _Bridge.Contract.AllowedDelayedInboxList(&_Bridge.CallOpts, arg0)
}

// AllowedDelayedInboxList is a free data retrieval call binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) view returns(address)
func (_Bridge *BridgeCallerSession) AllowedDelayedInboxList(arg0 *big.Int) (common.Address, error) {
	return _Bridge.Contract.AllowedDelayedInboxList(&_Bridge.CallOpts, arg0)
}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_Bridge *BridgeCaller) AllowedDelayedInboxes(opts *bind.CallOpts, inbox common.Address) (bool, error) {
	var out []interface{}
	err := _Bridge.contract.Call(opts, &out, "allowedDelayedInboxes", inbox)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_Bridge *BridgeSession) AllowedDelayedInboxes(inbox common.Address) (bool, error) {
	return _Bridge.Contract.AllowedDelayedInboxes(&_Bridge.CallOpts, inbox)
}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_Bridge *BridgeCallerSession) AllowedDelayedInboxes(inbox common.Address) (bool, error) {
	return _Bridge.Contract.AllowedDelayedInboxes(&_Bridge.CallOpts, inbox)
}

// AllowedOutboxList is a free data retrieval call binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) view returns(address)
func (_Bridge *BridgeCaller) AllowedOutboxList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _Bridge.contract.Call(opts, &out, "allowedOutboxList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AllowedOutboxList is a free data retrieval call binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) view returns(address)
func (_Bridge *BridgeSession) AllowedOutboxList(arg0 *big.Int) (common.Address, error) {
	return _Bridge.Contract.AllowedOutboxList(&_Bridge.CallOpts, arg0)
}

// AllowedOutboxList is a free data retrieval call binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) view returns(address)
func (_Bridge *BridgeCallerSession) AllowedOutboxList(arg0 *big.Int) (common.Address, error) {
	return _Bridge.Contract.AllowedOutboxList(&_Bridge.CallOpts, arg0)
}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_Bridge *BridgeCaller) AllowedOutboxes(opts *bind.CallOpts, outbox common.Address) (bool, error) {
	var out []interface{}
	err := _Bridge.contract.Call(opts, &out, "allowedOutboxes", outbox)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_Bridge *BridgeSession) AllowedOutboxes(outbox common.Address) (bool, error) {
	return _Bridge.Contract.AllowedOutboxes(&_Bridge.CallOpts, outbox)
}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_Bridge *BridgeCallerSession) AllowedOutboxes(outbox common.Address) (bool, error) {
	return _Bridge.Contract.AllowedOutboxes(&_Bridge.CallOpts, outbox)
}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_Bridge *BridgeCaller) DelayedInboxAccs(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _Bridge.contract.Call(opts, &out, "delayedInboxAccs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_Bridge *BridgeSession) DelayedInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _Bridge.Contract.DelayedInboxAccs(&_Bridge.CallOpts, arg0)
}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_Bridge *BridgeCallerSession) DelayedInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _Bridge.Contract.DelayedInboxAccs(&_Bridge.CallOpts, arg0)
}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_Bridge *BridgeCaller) DelayedMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Bridge.contract.Call(opts, &out, "delayedMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_Bridge *BridgeSession) DelayedMessageCount() (*big.Int, error) {
	return _Bridge.Contract.DelayedMessageCount(&_Bridge.CallOpts)
}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_Bridge *BridgeCallerSession) DelayedMessageCount() (*big.Int, error) {
	return _Bridge.Contract.DelayedMessageCount(&_Bridge.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_Bridge *BridgeCaller) Rollup(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Bridge.contract.Call(opts, &out, "rollup")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_Bridge *BridgeSession) Rollup() (common.Address, error) {
	return _Bridge.Contract.Rollup(&_Bridge.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_Bridge *BridgeCallerSession) Rollup() (common.Address, error) {
	return _Bridge.Contract.Rollup(&_Bridge.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_Bridge *BridgeCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Bridge.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_Bridge *BridgeSession) SequencerInbox() (common.Address, error) {
	return _Bridge.Contract.SequencerInbox(&_Bridge.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_Bridge *BridgeCallerSession) SequencerInbox() (common.Address, error) {
	return _Bridge.Contract.SequencerInbox(&_Bridge.CallOpts)
}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_Bridge *BridgeCaller) SequencerInboxAccs(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _Bridge.contract.Call(opts, &out, "sequencerInboxAccs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_Bridge *BridgeSession) SequencerInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _Bridge.Contract.SequencerInboxAccs(&_Bridge.CallOpts, arg0)
}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_Bridge *BridgeCallerSession) SequencerInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _Bridge.Contract.SequencerInboxAccs(&_Bridge.CallOpts, arg0)
}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_Bridge *BridgeCaller) SequencerMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Bridge.contract.Call(opts, &out, "sequencerMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_Bridge *BridgeSession) SequencerMessageCount() (*big.Int, error) {
	return _Bridge.Contract.SequencerMessageCount(&_Bridge.CallOpts)
}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_Bridge *BridgeCallerSession) SequencerMessageCount() (*big.Int, error) {
	return _Bridge.Contract.SequencerMessageCount(&_Bridge.CallOpts)
}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_Bridge *BridgeCaller) SequencerReportedSubMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Bridge.contract.Call(opts, &out, "sequencerReportedSubMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_Bridge *BridgeSession) SequencerReportedSubMessageCount() (*big.Int, error) {
	return _Bridge.Contract.SequencerReportedSubMessageCount(&_Bridge.CallOpts)
}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_Bridge *BridgeCallerSession) SequencerReportedSubMessageCount() (*big.Int, error) {
	return _Bridge.Contract.SequencerReportedSubMessageCount(&_Bridge.CallOpts)
}

// AcceptFundsFromOldBridge is a paid mutator transaction binding the contract method 0xe77145f4.
//
// Solidity: function acceptFundsFromOldBridge() payable returns()
func (_Bridge *BridgeTransactor) AcceptFundsFromOldBridge(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Bridge.contract.Transact(opts, "acceptFundsFromOldBridge")
}

// AcceptFundsFromOldBridge is a paid mutator transaction binding the contract method 0xe77145f4.
//
// Solidity: function acceptFundsFromOldBridge() payable returns()
func (_Bridge *BridgeSession) AcceptFundsFromOldBridge() (*types.Transaction, error) {
	return _Bridge.Contract.AcceptFundsFromOldBridge(&_Bridge.TransactOpts)
}

// AcceptFundsFromOldBridge is a paid mutator transaction binding the contract method 0xe77145f4.
//
// Solidity: function acceptFundsFromOldBridge() payable returns()
func (_Bridge *BridgeTransactorSession) AcceptFundsFromOldBridge() (*types.Transaction, error) {
	return _Bridge.Contract.AcceptFundsFromOldBridge(&_Bridge.TransactOpts)
}

// EnqueueDelayedMessage is a paid mutator transaction binding the contract method 0x8db5993b.
//
// Solidity: function enqueueDelayedMessage(uint8 kind, address sender, bytes32 messageDataHash) payable returns(uint256)
func (_Bridge *BridgeTransactor) EnqueueDelayedMessage(opts *bind.TransactOpts, kind uint8, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _Bridge.contract.Transact(opts, "enqueueDelayedMessage", kind, sender, messageDataHash)
}

// EnqueueDelayedMessage is a paid mutator transaction binding the contract method 0x8db5993b.
//
// Solidity: function enqueueDelayedMessage(uint8 kind, address sender, bytes32 messageDataHash) payable returns(uint256)
func (_Bridge *BridgeSession) EnqueueDelayedMessage(kind uint8, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _Bridge.Contract.EnqueueDelayedMessage(&_Bridge.TransactOpts, kind, sender, messageDataHash)
}

// EnqueueDelayedMessage is a paid mutator transaction binding the contract method 0x8db5993b.
//
// Solidity: function enqueueDelayedMessage(uint8 kind, address sender, bytes32 messageDataHash) payable returns(uint256)
func (_Bridge *BridgeTransactorSession) EnqueueDelayedMessage(kind uint8, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _Bridge.Contract.EnqueueDelayedMessage(&_Bridge.TransactOpts, kind, sender, messageDataHash)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_Bridge *BridgeTransactor) EnqueueSequencerMessage(opts *bind.TransactOpts, dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _Bridge.contract.Transact(opts, "enqueueSequencerMessage", dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_Bridge *BridgeSession) EnqueueSequencerMessage(dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _Bridge.Contract.EnqueueSequencerMessage(&_Bridge.TransactOpts, dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_Bridge *BridgeTransactorSession) EnqueueSequencerMessage(dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _Bridge.Contract.EnqueueSequencerMessage(&_Bridge.TransactOpts, dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_Bridge *BridgeTransactor) ExecuteCall(opts *bind.TransactOpts, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Bridge.contract.Transact(opts, "executeCall", to, value, data)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_Bridge *BridgeSession) ExecuteCall(to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Bridge.Contract.ExecuteCall(&_Bridge.TransactOpts, to, value, data)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_Bridge *BridgeTransactorSession) ExecuteCall(to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Bridge.Contract.ExecuteCall(&_Bridge.TransactOpts, to, value, data)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address rollup_) returns()
func (_Bridge *BridgeTransactor) Initialize(opts *bind.TransactOpts, rollup_ common.Address) (*types.Transaction, error) {
	return _Bridge.contract.Transact(opts, "initialize", rollup_)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address rollup_) returns()
func (_Bridge *BridgeSession) Initialize(rollup_ common.Address) (*types.Transaction, error) {
	return _Bridge.Contract.Initialize(&_Bridge.TransactOpts, rollup_)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address rollup_) returns()
func (_Bridge *BridgeTransactorSession) Initialize(rollup_ common.Address) (*types.Transaction, error) {
	return _Bridge.Contract.Initialize(&_Bridge.TransactOpts, rollup_)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_Bridge *BridgeTransactor) SetDelayedInbox(opts *bind.TransactOpts, inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _Bridge.contract.Transact(opts, "setDelayedInbox", inbox, enabled)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_Bridge *BridgeSession) SetDelayedInbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _Bridge.Contract.SetDelayedInbox(&_Bridge.TransactOpts, inbox, enabled)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_Bridge *BridgeTransactorSession) SetDelayedInbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _Bridge.Contract.SetDelayedInbox(&_Bridge.TransactOpts, inbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address outbox, bool enabled) returns()
func (_Bridge *BridgeTransactor) SetOutbox(opts *bind.TransactOpts, outbox common.Address, enabled bool) (*types.Transaction, error) {
	return _Bridge.contract.Transact(opts, "setOutbox", outbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address outbox, bool enabled) returns()
func (_Bridge *BridgeSession) SetOutbox(outbox common.Address, enabled bool) (*types.Transaction, error) {
	return _Bridge.Contract.SetOutbox(&_Bridge.TransactOpts, outbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address outbox, bool enabled) returns()
func (_Bridge *BridgeTransactorSession) SetOutbox(outbox common.Address, enabled bool) (*types.Transaction, error) {
	return _Bridge.Contract.SetOutbox(&_Bridge.TransactOpts, outbox, enabled)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_Bridge *BridgeTransactor) SetSequencerInbox(opts *bind.TransactOpts, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _Bridge.contract.Transact(opts, "setSequencerInbox", _sequencerInbox)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_Bridge *BridgeSession) SetSequencerInbox(_sequencerInbox common.Address) (*types.Transaction, error) {
	return _Bridge.Contract.SetSequencerInbox(&_Bridge.TransactOpts, _sequencerInbox)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_Bridge *BridgeTransactorSession) SetSequencerInbox(_sequencerInbox common.Address) (*types.Transaction, error) {
	return _Bridge.Contract.SetSequencerInbox(&_Bridge.TransactOpts, _sequencerInbox)
}

// SetSequencerReportedSubMessageCount is a paid mutator transaction binding the contract method 0xf81ff3b3.
//
// Solidity: function setSequencerReportedSubMessageCount(uint256 newMsgCount) returns()
func (_Bridge *BridgeTransactor) SetSequencerReportedSubMessageCount(opts *bind.TransactOpts, newMsgCount *big.Int) (*types.Transaction, error) {
	return _Bridge.contract.Transact(opts, "setSequencerReportedSubMessageCount", newMsgCount)
}

// SetSequencerReportedSubMessageCount is a paid mutator transaction binding the contract method 0xf81ff3b3.
//
// Solidity: function setSequencerReportedSubMessageCount(uint256 newMsgCount) returns()
func (_Bridge *BridgeSession) SetSequencerReportedSubMessageCount(newMsgCount *big.Int) (*types.Transaction, error) {
	return _Bridge.Contract.SetSequencerReportedSubMessageCount(&_Bridge.TransactOpts, newMsgCount)
}

// SetSequencerReportedSubMessageCount is a paid mutator transaction binding the contract method 0xf81ff3b3.
//
// Solidity: function setSequencerReportedSubMessageCount(uint256 newMsgCount) returns()
func (_Bridge *BridgeTransactorSession) SetSequencerReportedSubMessageCount(newMsgCount *big.Int) (*types.Transaction, error) {
	return _Bridge.Contract.SetSequencerReportedSubMessageCount(&_Bridge.TransactOpts, newMsgCount)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address sender, bytes32 messageDataHash) returns(uint256)
func (_Bridge *BridgeTransactor) SubmitBatchSpendingReport(opts *bind.TransactOpts, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _Bridge.contract.Transact(opts, "submitBatchSpendingReport", sender, messageDataHash)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address sender, bytes32 messageDataHash) returns(uint256)
func (_Bridge *BridgeSession) SubmitBatchSpendingReport(sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _Bridge.Contract.SubmitBatchSpendingReport(&_Bridge.TransactOpts, sender, messageDataHash)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address sender, bytes32 messageDataHash) returns(uint256)
func (_Bridge *BridgeTransactorSession) SubmitBatchSpendingReport(sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _Bridge.Contract.SubmitBatchSpendingReport(&_Bridge.TransactOpts, sender, messageDataHash)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_Bridge *BridgeTransactor) UpdateRollupAddress(opts *bind.TransactOpts, _rollup common.Address) (*types.Transaction, error) {
	return _Bridge.contract.Transact(opts, "updateRollupAddress", _rollup)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_Bridge *BridgeSession) UpdateRollupAddress(_rollup common.Address) (*types.Transaction, error) {
	return _Bridge.Contract.UpdateRollupAddress(&_Bridge.TransactOpts, _rollup)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_Bridge *BridgeTransactorSession) UpdateRollupAddress(_rollup common.Address) (*types.Transaction, error) {
	return _Bridge.Contract.UpdateRollupAddress(&_Bridge.TransactOpts, _rollup)
}

// BridgeBridgeCallTriggeredIterator is returned from FilterBridgeCallTriggered and is used to iterate over the raw logs and unpacked data for BridgeCallTriggered events raised by the Bridge contract.
type BridgeBridgeCallTriggeredIterator struct {
	Event *BridgeBridgeCallTriggered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeBridgeCallTriggeredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeBridgeCallTriggered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeBridgeCallTriggered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeBridgeCallTriggeredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeBridgeCallTriggeredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeBridgeCallTriggered represents a BridgeCallTriggered event raised by the Bridge contract.
type BridgeBridgeCallTriggered struct {
	Outbox common.Address
	To     common.Address
	Value  *big.Int
	Data   []byte
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBridgeCallTriggered is a free log retrieval operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_Bridge *BridgeFilterer) FilterBridgeCallTriggered(opts *bind.FilterOpts, outbox []common.Address, to []common.Address) (*BridgeBridgeCallTriggeredIterator, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _Bridge.contract.FilterLogs(opts, "BridgeCallTriggered", outboxRule, toRule)
	if err != nil {
		return nil, err
	}
	return &BridgeBridgeCallTriggeredIterator{contract: _Bridge.contract, event: "BridgeCallTriggered", logs: logs, sub: sub}, nil
}

// WatchBridgeCallTriggered is a free log subscription operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_Bridge *BridgeFilterer) WatchBridgeCallTriggered(opts *bind.WatchOpts, sink chan<- *BridgeBridgeCallTriggered, outbox []common.Address, to []common.Address) (event.Subscription, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _Bridge.contract.WatchLogs(opts, "BridgeCallTriggered", outboxRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeBridgeCallTriggered)
				if err := _Bridge.contract.UnpackLog(event, "BridgeCallTriggered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBridgeCallTriggered is a log parse operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_Bridge *BridgeFilterer) ParseBridgeCallTriggered(log types.Log) (*BridgeBridgeCallTriggered, error) {
	event := new(BridgeBridgeCallTriggered)
	if err := _Bridge.contract.UnpackLog(event, "BridgeCallTriggered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BridgeInboxToggleIterator is returned from FilterInboxToggle and is used to iterate over the raw logs and unpacked data for InboxToggle events raised by the Bridge contract.
type BridgeInboxToggleIterator struct {
	Event *BridgeInboxToggle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeInboxToggleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeInboxToggle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeInboxToggle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeInboxToggleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeInboxToggleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeInboxToggle represents a InboxToggle event raised by the Bridge contract.
type BridgeInboxToggle struct {
	Inbox   common.Address
	Enabled bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInboxToggle is a free log retrieval operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_Bridge *BridgeFilterer) FilterInboxToggle(opts *bind.FilterOpts, inbox []common.Address) (*BridgeInboxToggleIterator, error) {

	var inboxRule []interface{}
	for _, inboxItem := range inbox {
		inboxRule = append(inboxRule, inboxItem)
	}

	logs, sub, err := _Bridge.contract.FilterLogs(opts, "InboxToggle", inboxRule)
	if err != nil {
		return nil, err
	}
	return &BridgeInboxToggleIterator{contract: _Bridge.contract, event: "InboxToggle", logs: logs, sub: sub}, nil
}

// WatchInboxToggle is a free log subscription operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_Bridge *BridgeFilterer) WatchInboxToggle(opts *bind.WatchOpts, sink chan<- *BridgeInboxToggle, inbox []common.Address) (event.Subscription, error) {

	var inboxRule []interface{}
	for _, inboxItem := range inbox {
		inboxRule = append(inboxRule, inboxItem)
	}

	logs, sub, err := _Bridge.contract.WatchLogs(opts, "InboxToggle", inboxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeInboxToggle)
				if err := _Bridge.contract.UnpackLog(event, "InboxToggle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxToggle is a log parse operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_Bridge *BridgeFilterer) ParseInboxToggle(log types.Log) (*BridgeInboxToggle, error) {
	event := new(BridgeInboxToggle)
	if err := _Bridge.contract.UnpackLog(event, "InboxToggle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BridgeInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the Bridge contract.
type BridgeInitializedIterator struct {
	Event *BridgeInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeInitialized represents a Initialized event raised by the Bridge contract.
type BridgeInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Bridge *BridgeFilterer) FilterInitialized(opts *bind.FilterOpts) (*BridgeInitializedIterator, error) {

	logs, sub, err := _Bridge.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &BridgeInitializedIterator{contract: _Bridge.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Bridge *BridgeFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *BridgeInitialized) (event.Subscription, error) {

	logs, sub, err := _Bridge.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeInitialized)
				if err := _Bridge.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Bridge *BridgeFilterer) ParseInitialized(log types.Log) (*BridgeInitialized, error) {
	event := new(BridgeInitialized)
	if err := _Bridge.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BridgeMessageDeliveredIterator is returned from FilterMessageDelivered and is used to iterate over the raw logs and unpacked data for MessageDelivered events raised by the Bridge contract.
type BridgeMessageDeliveredIterator struct {
	Event *BridgeMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeMessageDelivered represents a MessageDelivered event raised by the Bridge contract.
type BridgeMessageDelivered struct {
	MessageIndex    *big.Int
	BeforeInboxAcc  [32]byte
	Inbox           common.Address
	Kind            uint8
	Sender          common.Address
	MessageDataHash [32]byte
	BaseFeeL1       *big.Int
	Timestamp       uint64
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterMessageDelivered is a free log retrieval operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_Bridge *BridgeFilterer) FilterMessageDelivered(opts *bind.FilterOpts, messageIndex []*big.Int, beforeInboxAcc [][32]byte) (*BridgeMessageDeliveredIterator, error) {

	var messageIndexRule []interface{}
	for _, messageIndexItem := range messageIndex {
		messageIndexRule = append(messageIndexRule, messageIndexItem)
	}
	var beforeInboxAccRule []interface{}
	for _, beforeInboxAccItem := range beforeInboxAcc {
		beforeInboxAccRule = append(beforeInboxAccRule, beforeInboxAccItem)
	}

	logs, sub, err := _Bridge.contract.FilterLogs(opts, "MessageDelivered", messageIndexRule, beforeInboxAccRule)
	if err != nil {
		return nil, err
	}
	return &BridgeMessageDeliveredIterator{contract: _Bridge.contract, event: "MessageDelivered", logs: logs, sub: sub}, nil
}

// WatchMessageDelivered is a free log subscription operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_Bridge *BridgeFilterer) WatchMessageDelivered(opts *bind.WatchOpts, sink chan<- *BridgeMessageDelivered, messageIndex []*big.Int, beforeInboxAcc [][32]byte) (event.Subscription, error) {

	var messageIndexRule []interface{}
	for _, messageIndexItem := range messageIndex {
		messageIndexRule = append(messageIndexRule, messageIndexItem)
	}
	var beforeInboxAccRule []interface{}
	for _, beforeInboxAccItem := range beforeInboxAcc {
		beforeInboxAccRule = append(beforeInboxAccRule, beforeInboxAccItem)
	}

	logs, sub, err := _Bridge.contract.WatchLogs(opts, "MessageDelivered", messageIndexRule, beforeInboxAccRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeMessageDelivered)
				if err := _Bridge.contract.UnpackLog(event, "MessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageDelivered is a log parse operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_Bridge *BridgeFilterer) ParseMessageDelivered(log types.Log) (*BridgeMessageDelivered, error) {
	event := new(BridgeMessageDelivered)
	if err := _Bridge.contract.UnpackLog(event, "MessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BridgeOutboxToggleIterator is returned from FilterOutboxToggle and is used to iterate over the raw logs and unpacked data for OutboxToggle events raised by the Bridge contract.
type BridgeOutboxToggleIterator struct {
	Event *BridgeOutboxToggle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeOutboxToggleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeOutboxToggle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeOutboxToggle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeOutboxToggleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeOutboxToggleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeOutboxToggle represents a OutboxToggle event raised by the Bridge contract.
type BridgeOutboxToggle struct {
	Outbox  common.Address
	Enabled bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterOutboxToggle is a free log retrieval operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_Bridge *BridgeFilterer) FilterOutboxToggle(opts *bind.FilterOpts, outbox []common.Address) (*BridgeOutboxToggleIterator, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}

	logs, sub, err := _Bridge.contract.FilterLogs(opts, "OutboxToggle", outboxRule)
	if err != nil {
		return nil, err
	}
	return &BridgeOutboxToggleIterator{contract: _Bridge.contract, event: "OutboxToggle", logs: logs, sub: sub}, nil
}

// WatchOutboxToggle is a free log subscription operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_Bridge *BridgeFilterer) WatchOutboxToggle(opts *bind.WatchOpts, sink chan<- *BridgeOutboxToggle, outbox []common.Address) (event.Subscription, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}

	logs, sub, err := _Bridge.contract.WatchLogs(opts, "OutboxToggle", outboxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeOutboxToggle)
				if err := _Bridge.contract.UnpackLog(event, "OutboxToggle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOutboxToggle is a log parse operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_Bridge *BridgeFilterer) ParseOutboxToggle(log types.Log) (*BridgeOutboxToggle, error) {
	event := new(BridgeOutboxToggle)
	if err := _Bridge.contract.UnpackLog(event, "OutboxToggle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BridgeRollupUpdatedIterator is returned from FilterRollupUpdated and is used to iterate over the raw logs and unpacked data for RollupUpdated events raised by the Bridge contract.
type BridgeRollupUpdatedIterator struct {
	Event *BridgeRollupUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeRollupUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeRollupUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeRollupUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeRollupUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeRollupUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeRollupUpdated represents a RollupUpdated event raised by the Bridge contract.
type BridgeRollupUpdated struct {
	Rollup common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRollupUpdated is a free log retrieval operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_Bridge *BridgeFilterer) FilterRollupUpdated(opts *bind.FilterOpts) (*BridgeRollupUpdatedIterator, error) {

	logs, sub, err := _Bridge.contract.FilterLogs(opts, "RollupUpdated")
	if err != nil {
		return nil, err
	}
	return &BridgeRollupUpdatedIterator{contract: _Bridge.contract, event: "RollupUpdated", logs: logs, sub: sub}, nil
}

// WatchRollupUpdated is a free log subscription operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_Bridge *BridgeFilterer) WatchRollupUpdated(opts *bind.WatchOpts, sink chan<- *BridgeRollupUpdated) (event.Subscription, error) {

	logs, sub, err := _Bridge.contract.WatchLogs(opts, "RollupUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeRollupUpdated)
				if err := _Bridge.contract.UnpackLog(event, "RollupUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupUpdated is a log parse operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_Bridge *BridgeFilterer) ParseRollupUpdated(log types.Log) (*BridgeRollupUpdated, error) {
	event := new(BridgeRollupUpdated)
	if err := _Bridge.contract.UnpackLog(event, "RollupUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// BridgeSequencerInboxUpdatedIterator is returned from FilterSequencerInboxUpdated and is used to iterate over the raw logs and unpacked data for SequencerInboxUpdated events raised by the Bridge contract.
type BridgeSequencerInboxUpdatedIterator struct {
	Event *BridgeSequencerInboxUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *BridgeSequencerInboxUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(BridgeSequencerInboxUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(BridgeSequencerInboxUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *BridgeSequencerInboxUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *BridgeSequencerInboxUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// BridgeSequencerInboxUpdated represents a SequencerInboxUpdated event raised by the Bridge contract.
type BridgeSequencerInboxUpdated struct {
	NewSequencerInbox common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterSequencerInboxUpdated is a free log retrieval operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_Bridge *BridgeFilterer) FilterSequencerInboxUpdated(opts *bind.FilterOpts) (*BridgeSequencerInboxUpdatedIterator, error) {

	logs, sub, err := _Bridge.contract.FilterLogs(opts, "SequencerInboxUpdated")
	if err != nil {
		return nil, err
	}
	return &BridgeSequencerInboxUpdatedIterator{contract: _Bridge.contract, event: "SequencerInboxUpdated", logs: logs, sub: sub}, nil
}

// WatchSequencerInboxUpdated is a free log subscription operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_Bridge *BridgeFilterer) WatchSequencerInboxUpdated(opts *bind.WatchOpts, sink chan<- *BridgeSequencerInboxUpdated) (event.Subscription, error) {

	logs, sub, err := _Bridge.contract.WatchLogs(opts, "SequencerInboxUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(BridgeSequencerInboxUpdated)
				if err := _Bridge.contract.UnpackLog(event, "SequencerInboxUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSequencerInboxUpdated is a log parse operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_Bridge *BridgeFilterer) ParseSequencerInboxUpdated(log types.Log) (*BridgeSequencerInboxUpdated, error) {
	event := new(BridgeSequencerInboxUpdated)
	if err := _Bridge.contract.UnpackLog(event, "SequencerInboxUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// DelayBufferMetaData contains all meta data concerning the DelayBuffer contract.
var DelayBufferMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"BASIS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
	Bin: "0x608080604052346018576076908161001e823930815050f35b600080fdfe6080806040526004361015601257600080fd5b60003560e01c63528cfa9814602657600080fd5b6000366003190112603b578061271060209252f35b600080fdfea2646970667358221220b2fcce061b0d93e39daad46f2a884d055017e3968f9b039be4ea9a95b4007b4764736f6c63430008130033",
}

// DelayBufferABI is the input ABI used to generate the binding from.
// Deprecated: Use DelayBufferMetaData.ABI instead.
var DelayBufferABI = DelayBufferMetaData.ABI

// DelayBufferBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use DelayBufferMetaData.Bin instead.
var DelayBufferBin = DelayBufferMetaData.Bin

// DeployDelayBuffer deploys a new Ethereum contract, binding an instance of DelayBuffer to it.
func DeployDelayBuffer(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *DelayBuffer, error) {
	parsed, err := DelayBufferMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(DelayBufferBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &DelayBuffer{DelayBufferCaller: DelayBufferCaller{contract: contract}, DelayBufferTransactor: DelayBufferTransactor{contract: contract}, DelayBufferFilterer: DelayBufferFilterer{contract: contract}}, nil
}

// DelayBuffer is an auto generated Go binding around an Ethereum contract.
type DelayBuffer struct {
	DelayBufferCaller     // Read-only binding to the contract
	DelayBufferTransactor // Write-only binding to the contract
	DelayBufferFilterer   // Log filterer for contract events
}

// DelayBufferCaller is an auto generated read-only Go binding around an Ethereum contract.
type DelayBufferCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DelayBufferTransactor is an auto generated write-only Go binding around an Ethereum contract.
type DelayBufferTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DelayBufferFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type DelayBufferFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// DelayBufferSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type DelayBufferSession struct {
	Contract     *DelayBuffer      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// DelayBufferCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type DelayBufferCallerSession struct {
	Contract *DelayBufferCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// DelayBufferTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type DelayBufferTransactorSession struct {
	Contract     *DelayBufferTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// DelayBufferRaw is an auto generated low-level Go binding around an Ethereum contract.
type DelayBufferRaw struct {
	Contract *DelayBuffer // Generic contract binding to access the raw methods on
}

// DelayBufferCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type DelayBufferCallerRaw struct {
	Contract *DelayBufferCaller // Generic read-only contract binding to access the raw methods on
}

// DelayBufferTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type DelayBufferTransactorRaw struct {
	Contract *DelayBufferTransactor // Generic write-only contract binding to access the raw methods on
}

// NewDelayBuffer creates a new instance of DelayBuffer, bound to a specific deployed contract.
func NewDelayBuffer(address common.Address, backend bind.ContractBackend) (*DelayBuffer, error) {
	contract, err := bindDelayBuffer(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &DelayBuffer{DelayBufferCaller: DelayBufferCaller{contract: contract}, DelayBufferTransactor: DelayBufferTransactor{contract: contract}, DelayBufferFilterer: DelayBufferFilterer{contract: contract}}, nil
}

// NewDelayBufferCaller creates a new read-only instance of DelayBuffer, bound to a specific deployed contract.
func NewDelayBufferCaller(address common.Address, caller bind.ContractCaller) (*DelayBufferCaller, error) {
	contract, err := bindDelayBuffer(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &DelayBufferCaller{contract: contract}, nil
}

// NewDelayBufferTransactor creates a new write-only instance of DelayBuffer, bound to a specific deployed contract.
func NewDelayBufferTransactor(address common.Address, transactor bind.ContractTransactor) (*DelayBufferTransactor, error) {
	contract, err := bindDelayBuffer(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &DelayBufferTransactor{contract: contract}, nil
}

// NewDelayBufferFilterer creates a new log filterer instance of DelayBuffer, bound to a specific deployed contract.
func NewDelayBufferFilterer(address common.Address, filterer bind.ContractFilterer) (*DelayBufferFilterer, error) {
	contract, err := bindDelayBuffer(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &DelayBufferFilterer{contract: contract}, nil
}

// bindDelayBuffer binds a generic wrapper to an already deployed contract.
func bindDelayBuffer(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := DelayBufferMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DelayBuffer *DelayBufferRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _DelayBuffer.Contract.DelayBufferCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DelayBuffer *DelayBufferRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DelayBuffer.Contract.DelayBufferTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DelayBuffer *DelayBufferRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DelayBuffer.Contract.DelayBufferTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_DelayBuffer *DelayBufferCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _DelayBuffer.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_DelayBuffer *DelayBufferTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _DelayBuffer.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_DelayBuffer *DelayBufferTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _DelayBuffer.Contract.contract.Transact(opts, method, params...)
}

// BASIS is a free data retrieval call binding the contract method 0x528cfa98.
//
// Solidity: function BASIS() view returns(uint256)
func (_DelayBuffer *DelayBufferCaller) BASIS(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _DelayBuffer.contract.Call(opts, &out, "BASIS")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BASIS is a free data retrieval call binding the contract method 0x528cfa98.
//
// Solidity: function BASIS() view returns(uint256)
func (_DelayBuffer *DelayBufferSession) BASIS() (*big.Int, error) {
	return _DelayBuffer.Contract.BASIS(&_DelayBuffer.CallOpts)
}

// BASIS is a free data retrieval call binding the contract method 0x528cfa98.
//
// Solidity: function BASIS() view returns(uint256)
func (_DelayBuffer *DelayBufferCallerSession) BASIS() (*big.Int, error) {
	return _DelayBuffer.Contract.BASIS(&_DelayBuffer.CallOpts)
}

// ERC20BridgeMetaData contains all meta data concerning the ERC20Bridge contract.
var ERC20BridgeMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stored\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"BadSequencerMessageNumber\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"CallTargetNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"}],\"name\":\"InvalidOutboxSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"InvalidTokenSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"decimals\",\"type\":\"uint256\"}],\"name\":\"NativeTokenDecimalsTooLarge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NotContract\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotDelayedInbox\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotOutbox\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotRollupOrOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotSequencerInbox\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BridgeCallTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"InboxToggle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beforeInboxAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"MessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OutboxToggle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"}],\"name\":\"RollupUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSequencerInbox\",\"type\":\"address\"}],\"name\":\"SequencerInboxUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptFundsFromOldBridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeOutbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedDelayedInboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"}],\"name\":\"allowedDelayedInboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedOutboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"}],\"name\":\"allowedOutboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"delayedInboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayedMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenFeeAmount\",\"type\":\"uint256\"}],\"name\":\"enqueueDelayedMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"}],\"name\":\"enqueueSequencerMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seqMessageIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"beforeAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"delayedAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"acc\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"rollup_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nativeToken_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeTokenDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sequencerInboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerReportedSubMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setDelayedInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setOutbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"setSequencerInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMsgCount\",\"type\":\"uint256\"}],\"name\":\"setSequencerReportedSubMessageCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"name\":\"submitBatchSpendingReport\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"_rollup\",\"type\":\"address\"}],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a080604052346100235730608052611a209081610029823960805181610ef00152f35b600080fdfe608080604052600436101561001357600080fd5b60003560e01c90816284120c1461124f5750806316bf557914611226578063413b35bd146111e457806347fb24c514611144578063485cc95514610e905780634f61f85014610dc95780635fca4a1614610dab57806375d81e2514610bb85780637a88b10714610a2857806386598a561461087a578063919cc706146107b1578063945e1147146107885780639e5d4c4914610449578063ab5d89431461041c578063ad48cb5e146103f8578063ae60bd13146103b6578063cb23bcb51461038d578063cee3d728146102eb578063d5719dc2146102b4578063e1758bd81461028b578063e76f5c8d14610249578063e77145f41461023b578063eca067ad1461021d578063ee35f327146101f45763f81ff3b31461013157600080fd5b346101ef5760203660031901126101ef576008546001600160a01b0390811633819003610161575b600435600a55005b604051638da5cb5b60e01b815291602083600481855afa9283156101e3576000936101b3575b508216330315610159575b6101af604051928392630739600760e01b84523360048501611435565b0390fd5b6101d591935060203d81116101dc575b6101cd81836113f3565b810190611416565b9138610187565b503d6101c3565b6040513d6000823e3d90fd5b600080fd5b346101ef5760003660031901126101ef576009546040516001600160a01b039091168152602090f35b346101ef5760003660031901126101ef576020600654604051908152f35b60003660031901126101ef57005b346101ef5760203660031901126101ef576004356003548110156101ef576102726020916112d1565b905460405160039290921b1c6001600160a01b03168152f35b346101ef5760003660031901126101ef576033546040516001600160a01b039091168152602090f35b346101ef5760203660031901126101ef576004356006548110156101ef576102dd60209161129b565b90546040519160031b1c8152f35b346101ef576102f936611318565b6008546001600160a01b03929083163381900361031d575b61031b8383611677565b005b604051638da5cb5b60e01b815293602085600481855afa9485156101e35760009561036d575b50841633031561031157604051630739600760e01b81529081906101af9086903360048501611435565b61038691955060203d81116101dc576101cd81836113f3565b9385610343565b346101ef5760003660031901126101ef576008546040516001600160a01b039091168152602090f35b346101ef5760203660031901126101ef576001600160a01b036103d76112ec565b166000526001602052602060ff600160406000200154166040519015158152f35b346101ef5760003660031901126101ef57602060ff60335460a01c16604051908152f35b346101ef5760003660031901126101ef576020610437611458565b6040516001600160a01b039091168152f35b346101ef5760603660031901126101ef576104626112ec565b6044356001600160401b038082116101ef57366023830112156101ef578160040135116101ef573660248260040135830101116101ef5733600052600260205260ff6001604060002001541615610770578060040135151580610767575b61074657600580546001600160a01b031981163317909155916104e6600483013561149c565b916104f460405193846113f3565b6004810135808452602482016020850137600060048201358401602001526033546060946001600160a01b039182169490918416851461072d576024356106ec575b60019481516105f1575b505060018060a01b031660018060a01b031960055416176005557f2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466604051926024358452604060208501528260040135604085015282600401356024840160608601376000606084600401358601015260018060a01b0316926060813394601f8019916004013501168101030190a36105ed60405192839215158352604060208401526040830190611347565b0390f35b6040516370a0823160e01b815230600482015296509450602086602481885afa9586156101e3576000966106b7575b506000816020829351910182875af1946024602061063c61195a565b9796604051928380926370a0823160e01b82523060048301525afa9081156101e357600091610685575b5010610673578580610540565b6040516315dace2d60e21b8152600490fd5b90506020813d6020116106af575b816106a0602093836113f3565b810103126101ef575187610666565b3d9150610693565b9095506020813d6020116106e4575b816106d3602093836113f3565b810103126101ef5751946000610620565b3d91506106c6565b61072860405163a9059cbb60e01b602082015260018060a01b0386166024820152602435604482015260448152610722816113d8565b86611819565b610536565b604051631c2d9a4160e31b815260048101869052602490fd5b60405163b5cf5b8f60e01b81526001600160a01b0383166004820152602490fd5b50813b156104c0565b6040516332ea82ab60e01b8152336004820152602490fd5b346101ef5760203660031901126101ef576004356004548110156101ef576102726020916112b6565b346101ef5760203660031901126101ef576107ca6112ec565b600854906001600160a01b039081831633819003610824575b8282166001600160a01b0319851681176008556040519081527fae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a90602090a1005b604051638da5cb5b60e01b815290602082600481845afa9182156101e35760009261085a575b50838216330361019257506107e3565b61087391925060203d81116101dc576101cd81836113f3565b908561084a565b346101ef5760803660031901126101ef57600954602490813590604435906001600160a01b03163303610a1157600090600090600a54908082141580610a08575b806109ff575b6109e2575050606435600a5560075492836109a9575b80610971575b506040516020810190838252600435604082015282606082015260608152610904816113d8565b51902091600160401b84101561095c5760809450600184016007558261094361092c8661126a565b819391549060031b91821b91600019901b19161790565b9055604051938452602084015260408301526060820152f35b84634e487b7160e01b60005260416004526000fd5b600019810191508111610994576109879061129b565b90549060031b1c846108dd565b83634e487b7160e01b60005260116004526000fd5b915060001983018381116109cd576109c09061126a565b90549060031b1c916108d7565b84634e487b7160e01b60005260116004526000fd5b60449250856040519263e2051feb60e01b84526004840152820152fd5b508115156108c1565b508015156108bb565b60405163223e13c160e21b81523360048201528390fd5b346101ef5760403660031901126101ef57610a416112ec565b600954602435906001600160a01b039081163303610ba057600654604051600d60f81b602082019081526001600160601b0319606087901b1660218301526001600160c01b03194360c090811b8216603585015242901b16603d830152604582018390524860658301526085808301869052825291939190610ac2816113a2565b5190209160009284610b43575b60209585936000805160206119cb83398151915293610b0e60c0946040518b8101918a8352604082015260408152610b06816113bd565b519020611476565b60405192338452600d8a850152166040830152606082015248608082015260018060401b03421660a0820152a3604051908152f35b92506000198401848111610b8a5760209585936000805160206119cb83398151915293610b0e610b7460c09561129b565b90549060031b1c97945050935093509550610acf565b634e487b7160e01b600052601160045260246000fd5b60405163223e13c160e21b8152336004820152602490fd5b346101ef5760803660031901126101ef5760043560ff8116908181036101ef57610be0611302565b916044359260643590336000526020946001865260ff6001604060002001541615610d935760065460405160f89690961b6001600160f81b031916878701908152606084901b6001600160601b03191660218801524360c090811b6001600160c01b031990811660358a01524290911b16603d8801526045870182905260006065880152608580880184905287529095610c79816113a2565b5190209060009186610d6a575b610ca69060405189810191858352604082015260408152610b06816113bd565b60408051338152888101969096526001600160a01b03938416908601526060850152600060808501526001600160401b0342811660a08601529385906000805160206119cb8339815191529060c090a381610d07575b505050604051908152f35b60335416604051916323b872dd60e01b8684015233602484015230604484015260648301526064825260a082019282841090841117610d5457610d4c92604052611819565b828080610cfc565b634e487b7160e01b600052604160045260246000fd5b91506000198601868111610b8a57610d84610ca69161129b565b90549060031b1c929050610c86565b60405163b6c60ea360e01b8152336004820152602490fd5b346101ef5760003660031901126101ef576020600a54604051908152f35b346101ef5760203660031901126101ef57610de26112ec565b6008546001600160a01b039190821633819003610e3a575b7f8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a60208484168060018060a01b03196009541617600955604051908152a1005b604051638da5cb5b60e01b815290602082600481845afa9182156101e357600092610e70575b5083821633036101925750610dfa565b610e8991925060203d81116101dc576101cd81836113f3565b9084610e60565b346101ef5760403660031901126101ef57610ea96112ec565b610eb1611302565b6000549160ff8360081c161592838094611137575b8015611120575b156110c45760ff198116600117600055836110b2575b506001600160a01b0391307f000000000000000000000000000000000000000000000000000000000000000084161461105857821690811561103f576033549260018060a01b0319918383861617603355818360055416176005551690600854161760085560405163313ce56760e01b8152602081600481855afa60009181611002575b50610fbb5750506033805460ff60a01b19169055505b610f8357005b61ff0019600054166000557f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498602060405160018152a1005b60ff811660248111610fea57506001600160a81b03199092161760a09190911b60ff60a01b1617603355610f7d565b6024906040519063070613b160e11b82526004820152fd5b9091506020813d8211611037575b8161101d602093836113f3565b810103126101ef575160ff811681036101ef579085610f67565b3d9150611010565b60405163036ffb6b60e11b815260048101839052602490fd5b60405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201526b19195b1959d85d1958d85b1b60a21b6064820152608490fd5b61ffff19166101011760005583610ee3565b60405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608490fd5b50303b158015610ecd5750600160ff821614610ecd565b50600160ff821610610ec6565b346101ef5761115236611318565b6008546001600160a01b039290831633819003611174575b61031b83836114d5565b604051638da5cb5b60e01b815293602085600481855afa9485156101e3576000956111c4575b50841633031561116a57604051630739600760e01b81529081906101af9086903360048501611435565b6111dd91955060203d81116101dc576101cd81836113f3565b938561119a565b346101ef5760203660031901126101ef576001600160a01b036112056112ec565b166000526002602052602060ff600160406000200154166040519015158152f35b346101ef5760203660031901126101ef576004356007548110156101ef576102dd60209161126a565b346101ef5760003660031901126101ef576020906007548152f35b60075481101561128557600760005260206000200190600090565b634e487b7160e01b600052603260045260246000fd5b60065481101561128557600660005260206000200190600090565b60045481101561128557600460005260206000200190600090565b60035481101561128557600360005260206000200190600090565b600435906001600160a01b03821682036101ef57565b602435906001600160a01b03821682036101ef57565b60409060031901126101ef576004356001600160a01b03811681036101ef579060243580151581036101ef5790565b919082519283825260005b848110611373575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201611352565b604081019081106001600160401b03821117610d5457604052565b60c081019081106001600160401b03821117610d5457604052565b606081019081106001600160401b03821117610d5457604052565b608081019081106001600160401b03821117610d5457604052565b601f909101601f19168101906001600160401b03821190821017610d5457604052565b908160209103126101ef57516001600160a01b03811681036101ef5790565b6001600160a01b0391821681529181166020830152909116604082015260600190565b6005546001600160a01b039081169081146114705790565b50600090565b600654600160401b811015610d545761092c816001611498930160065561129b565b9055565b6001600160401b038111610d5457601f01601f191660200190565b919082549060031b9160018060a01b03809116831b921b1916179055565b9060018060a01b038083166000928184526001926020918483526040918287209160ff8784015416845190877f6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf5218885151594858152a215151461166c57156115b0575050908391826003549282519361154d85611387565b845280840195828752885252852090518155019051151560ff8019835416911617905560035491600160401b83101561159c5750816115949161159a9493016003556112d1565b906114b7565b565b634e487b7160e01b81526041600452602490fd5b909194959650600393929354916000199283810190811161165857826115d86115ea926112d1565b90549060031b1c1661159483546112d1565b54906115f5826112d1565b90549060031b1c168752858452848720556003548015611644578593929101611635611620826112d1565b81549060018060a01b039060031b1b19169055565b60035585525282208281550155565b634e487b7160e01b87526031600452602487fd5b634e487b7160e01b89526011600452602489fd5b505050505050505050565b906001600160a01b03908183169081831461180057600092828452602091600283526040918286209160ff600184015416845190877f49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa8885151594858152a21515146117f65715611742575050906001916002600454928251936116fa85611387565b845280840195858752875252842090518155019051151560ff8019835416911617905560045490600160401b82101561159c57509061159482600161159a94016004556112b6565b909194955060049392935491600019928381019081116117e257611768611783916112b6565b90548461177585546112b6565b92909360031b1c16916114b7565b549061178e826112b6565b90549060031b1c168652600284528486205560045480156117ce57916001949391600293016117bf611620826112b6565b60045585525282208281550155565b634e487b7160e01b86526031600452602486fd5b634e487b7160e01b88526011600452602488fd5b5050505050505050565b60405163077abed160e41b815260048101839052602490fd5b60018060a01b03169060405161182e81611387565b6020928382527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656484830152803b1561191557906118839160008481959282888195519301915af161187d61195a565b9061198a565b805180611891575b50505050565b81849181010312611911578201519081159182150361190e57506118b75780808061188b565b6084906040519062461bcd60e51b82526004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152fd5b80fd5b5080fd5b60405162461bcd60e51b815260048101859052601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606490fd5b3d15611985573d9061196b8261149c565b9161197960405193846113f3565b82523d6000602084013e565b606090565b90919015611996575090565b8151156119a65750805190602001fd5b60405162461bcd60e51b8152602060048201529081906101af90602483019061134756fe5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1a264697066735822122007a828fb659fbb95ef9fbdff44677f15b2df91e5449547bce0d2c14ff39e08d764736f6c63430008130033",
}

// ERC20BridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC20BridgeMetaData.ABI instead.
var ERC20BridgeABI = ERC20BridgeMetaData.ABI

// ERC20BridgeBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ERC20BridgeMetaData.Bin instead.
var ERC20BridgeBin = ERC20BridgeMetaData.Bin

// DeployERC20Bridge deploys a new Ethereum contract, binding an instance of ERC20Bridge to it.
func DeployERC20Bridge(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ERC20Bridge, error) {
	parsed, err := ERC20BridgeMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ERC20BridgeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20Bridge{ERC20BridgeCaller: ERC20BridgeCaller{contract: contract}, ERC20BridgeTransactor: ERC20BridgeTransactor{contract: contract}, ERC20BridgeFilterer: ERC20BridgeFilterer{contract: contract}}, nil
}

// ERC20Bridge is an auto generated Go binding around an Ethereum contract.
type ERC20Bridge struct {
	ERC20BridgeCaller     // Read-only binding to the contract
	ERC20BridgeTransactor // Write-only binding to the contract
	ERC20BridgeFilterer   // Log filterer for contract events
}

// ERC20BridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20BridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20BridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20BridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20BridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20BridgeSession struct {
	Contract     *ERC20Bridge      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20BridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20BridgeCallerSession struct {
	Contract *ERC20BridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// ERC20BridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20BridgeTransactorSession struct {
	Contract     *ERC20BridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// ERC20BridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20BridgeRaw struct {
	Contract *ERC20Bridge // Generic contract binding to access the raw methods on
}

// ERC20BridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20BridgeCallerRaw struct {
	Contract *ERC20BridgeCaller // Generic read-only contract binding to access the raw methods on
}

// ERC20BridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20BridgeTransactorRaw struct {
	Contract *ERC20BridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20Bridge creates a new instance of ERC20Bridge, bound to a specific deployed contract.
func NewERC20Bridge(address common.Address, backend bind.ContractBackend) (*ERC20Bridge, error) {
	contract, err := bindERC20Bridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20Bridge{ERC20BridgeCaller: ERC20BridgeCaller{contract: contract}, ERC20BridgeTransactor: ERC20BridgeTransactor{contract: contract}, ERC20BridgeFilterer: ERC20BridgeFilterer{contract: contract}}, nil
}

// NewERC20BridgeCaller creates a new read-only instance of ERC20Bridge, bound to a specific deployed contract.
func NewERC20BridgeCaller(address common.Address, caller bind.ContractCaller) (*ERC20BridgeCaller, error) {
	contract, err := bindERC20Bridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20BridgeCaller{contract: contract}, nil
}

// NewERC20BridgeTransactor creates a new write-only instance of ERC20Bridge, bound to a specific deployed contract.
func NewERC20BridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC20BridgeTransactor, error) {
	contract, err := bindERC20Bridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20BridgeTransactor{contract: contract}, nil
}

// NewERC20BridgeFilterer creates a new log filterer instance of ERC20Bridge, bound to a specific deployed contract.
func NewERC20BridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC20BridgeFilterer, error) {
	contract, err := bindERC20Bridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20BridgeFilterer{contract: contract}, nil
}

// bindERC20Bridge binds a generic wrapper to an already deployed contract.
func bindERC20Bridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ERC20BridgeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Bridge *ERC20BridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Bridge.Contract.ERC20BridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Bridge *ERC20BridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.ERC20BridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Bridge *ERC20BridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.ERC20BridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Bridge *ERC20BridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Bridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Bridge *ERC20BridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Bridge *ERC20BridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.contract.Transact(opts, method, params...)
}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_ERC20Bridge *ERC20BridgeCaller) ActiveOutbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "activeOutbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_ERC20Bridge *ERC20BridgeSession) ActiveOutbox() (common.Address, error) {
	return _ERC20Bridge.Contract.ActiveOutbox(&_ERC20Bridge.CallOpts)
}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_ERC20Bridge *ERC20BridgeCallerSession) ActiveOutbox() (common.Address, error) {
	return _ERC20Bridge.Contract.ActiveOutbox(&_ERC20Bridge.CallOpts)
}

// AllowedDelayedInboxList is a free data retrieval call binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) view returns(address)
func (_ERC20Bridge *ERC20BridgeCaller) AllowedDelayedInboxList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "allowedDelayedInboxList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AllowedDelayedInboxList is a free data retrieval call binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) view returns(address)
func (_ERC20Bridge *ERC20BridgeSession) AllowedDelayedInboxList(arg0 *big.Int) (common.Address, error) {
	return _ERC20Bridge.Contract.AllowedDelayedInboxList(&_ERC20Bridge.CallOpts, arg0)
}

// AllowedDelayedInboxList is a free data retrieval call binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) view returns(address)
func (_ERC20Bridge *ERC20BridgeCallerSession) AllowedDelayedInboxList(arg0 *big.Int) (common.Address, error) {
	return _ERC20Bridge.Contract.AllowedDelayedInboxList(&_ERC20Bridge.CallOpts, arg0)
}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_ERC20Bridge *ERC20BridgeCaller) AllowedDelayedInboxes(opts *bind.CallOpts, inbox common.Address) (bool, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "allowedDelayedInboxes", inbox)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_ERC20Bridge *ERC20BridgeSession) AllowedDelayedInboxes(inbox common.Address) (bool, error) {
	return _ERC20Bridge.Contract.AllowedDelayedInboxes(&_ERC20Bridge.CallOpts, inbox)
}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_ERC20Bridge *ERC20BridgeCallerSession) AllowedDelayedInboxes(inbox common.Address) (bool, error) {
	return _ERC20Bridge.Contract.AllowedDelayedInboxes(&_ERC20Bridge.CallOpts, inbox)
}

// AllowedOutboxList is a free data retrieval call binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) view returns(address)
func (_ERC20Bridge *ERC20BridgeCaller) AllowedOutboxList(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "allowedOutboxList", arg0)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// AllowedOutboxList is a free data retrieval call binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) view returns(address)
func (_ERC20Bridge *ERC20BridgeSession) AllowedOutboxList(arg0 *big.Int) (common.Address, error) {
	return _ERC20Bridge.Contract.AllowedOutboxList(&_ERC20Bridge.CallOpts, arg0)
}

// AllowedOutboxList is a free data retrieval call binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) view returns(address)
func (_ERC20Bridge *ERC20BridgeCallerSession) AllowedOutboxList(arg0 *big.Int) (common.Address, error) {
	return _ERC20Bridge.Contract.AllowedOutboxList(&_ERC20Bridge.CallOpts, arg0)
}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_ERC20Bridge *ERC20BridgeCaller) AllowedOutboxes(opts *bind.CallOpts, outbox common.Address) (bool, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "allowedOutboxes", outbox)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_ERC20Bridge *ERC20BridgeSession) AllowedOutboxes(outbox common.Address) (bool, error) {
	return _ERC20Bridge.Contract.AllowedOutboxes(&_ERC20Bridge.CallOpts, outbox)
}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_ERC20Bridge *ERC20BridgeCallerSession) AllowedOutboxes(outbox common.Address) (bool, error) {
	return _ERC20Bridge.Contract.AllowedOutboxes(&_ERC20Bridge.CallOpts, outbox)
}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_ERC20Bridge *ERC20BridgeCaller) DelayedInboxAccs(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "delayedInboxAccs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_ERC20Bridge *ERC20BridgeSession) DelayedInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _ERC20Bridge.Contract.DelayedInboxAccs(&_ERC20Bridge.CallOpts, arg0)
}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_ERC20Bridge *ERC20BridgeCallerSession) DelayedInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _ERC20Bridge.Contract.DelayedInboxAccs(&_ERC20Bridge.CallOpts, arg0)
}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_ERC20Bridge *ERC20BridgeCaller) DelayedMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "delayedMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_ERC20Bridge *ERC20BridgeSession) DelayedMessageCount() (*big.Int, error) {
	return _ERC20Bridge.Contract.DelayedMessageCount(&_ERC20Bridge.CallOpts)
}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_ERC20Bridge *ERC20BridgeCallerSession) DelayedMessageCount() (*big.Int, error) {
	return _ERC20Bridge.Contract.DelayedMessageCount(&_ERC20Bridge.CallOpts)
}

// NativeToken is a free data retrieval call binding the contract method 0xe1758bd8.
//
// Solidity: function nativeToken() view returns(address)
func (_ERC20Bridge *ERC20BridgeCaller) NativeToken(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "nativeToken")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// NativeToken is a free data retrieval call binding the contract method 0xe1758bd8.
//
// Solidity: function nativeToken() view returns(address)
func (_ERC20Bridge *ERC20BridgeSession) NativeToken() (common.Address, error) {
	return _ERC20Bridge.Contract.NativeToken(&_ERC20Bridge.CallOpts)
}

// NativeToken is a free data retrieval call binding the contract method 0xe1758bd8.
//
// Solidity: function nativeToken() view returns(address)
func (_ERC20Bridge *ERC20BridgeCallerSession) NativeToken() (common.Address, error) {
	return _ERC20Bridge.Contract.NativeToken(&_ERC20Bridge.CallOpts)
}

// NativeTokenDecimals is a free data retrieval call binding the contract method 0xad48cb5e.
//
// Solidity: function nativeTokenDecimals() view returns(uint8)
func (_ERC20Bridge *ERC20BridgeCaller) NativeTokenDecimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "nativeTokenDecimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// NativeTokenDecimals is a free data retrieval call binding the contract method 0xad48cb5e.
//
// Solidity: function nativeTokenDecimals() view returns(uint8)
func (_ERC20Bridge *ERC20BridgeSession) NativeTokenDecimals() (uint8, error) {
	return _ERC20Bridge.Contract.NativeTokenDecimals(&_ERC20Bridge.CallOpts)
}

// NativeTokenDecimals is a free data retrieval call binding the contract method 0xad48cb5e.
//
// Solidity: function nativeTokenDecimals() view returns(uint8)
func (_ERC20Bridge *ERC20BridgeCallerSession) NativeTokenDecimals() (uint8, error) {
	return _ERC20Bridge.Contract.NativeTokenDecimals(&_ERC20Bridge.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_ERC20Bridge *ERC20BridgeCaller) Rollup(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "rollup")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_ERC20Bridge *ERC20BridgeSession) Rollup() (common.Address, error) {
	return _ERC20Bridge.Contract.Rollup(&_ERC20Bridge.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_ERC20Bridge *ERC20BridgeCallerSession) Rollup() (common.Address, error) {
	return _ERC20Bridge.Contract.Rollup(&_ERC20Bridge.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_ERC20Bridge *ERC20BridgeCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_ERC20Bridge *ERC20BridgeSession) SequencerInbox() (common.Address, error) {
	return _ERC20Bridge.Contract.SequencerInbox(&_ERC20Bridge.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_ERC20Bridge *ERC20BridgeCallerSession) SequencerInbox() (common.Address, error) {
	return _ERC20Bridge.Contract.SequencerInbox(&_ERC20Bridge.CallOpts)
}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_ERC20Bridge *ERC20BridgeCaller) SequencerInboxAccs(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "sequencerInboxAccs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_ERC20Bridge *ERC20BridgeSession) SequencerInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _ERC20Bridge.Contract.SequencerInboxAccs(&_ERC20Bridge.CallOpts, arg0)
}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_ERC20Bridge *ERC20BridgeCallerSession) SequencerInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _ERC20Bridge.Contract.SequencerInboxAccs(&_ERC20Bridge.CallOpts, arg0)
}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_ERC20Bridge *ERC20BridgeCaller) SequencerMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "sequencerMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_ERC20Bridge *ERC20BridgeSession) SequencerMessageCount() (*big.Int, error) {
	return _ERC20Bridge.Contract.SequencerMessageCount(&_ERC20Bridge.CallOpts)
}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_ERC20Bridge *ERC20BridgeCallerSession) SequencerMessageCount() (*big.Int, error) {
	return _ERC20Bridge.Contract.SequencerMessageCount(&_ERC20Bridge.CallOpts)
}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_ERC20Bridge *ERC20BridgeCaller) SequencerReportedSubMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Bridge.contract.Call(opts, &out, "sequencerReportedSubMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_ERC20Bridge *ERC20BridgeSession) SequencerReportedSubMessageCount() (*big.Int, error) {
	return _ERC20Bridge.Contract.SequencerReportedSubMessageCount(&_ERC20Bridge.CallOpts)
}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_ERC20Bridge *ERC20BridgeCallerSession) SequencerReportedSubMessageCount() (*big.Int, error) {
	return _ERC20Bridge.Contract.SequencerReportedSubMessageCount(&_ERC20Bridge.CallOpts)
}

// AcceptFundsFromOldBridge is a paid mutator transaction binding the contract method 0xe77145f4.
//
// Solidity: function acceptFundsFromOldBridge() payable returns()
func (_ERC20Bridge *ERC20BridgeTransactor) AcceptFundsFromOldBridge(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Bridge.contract.Transact(opts, "acceptFundsFromOldBridge")
}

// AcceptFundsFromOldBridge is a paid mutator transaction binding the contract method 0xe77145f4.
//
// Solidity: function acceptFundsFromOldBridge() payable returns()
func (_ERC20Bridge *ERC20BridgeSession) AcceptFundsFromOldBridge() (*types.Transaction, error) {
	return _ERC20Bridge.Contract.AcceptFundsFromOldBridge(&_ERC20Bridge.TransactOpts)
}

// AcceptFundsFromOldBridge is a paid mutator transaction binding the contract method 0xe77145f4.
//
// Solidity: function acceptFundsFromOldBridge() payable returns()
func (_ERC20Bridge *ERC20BridgeTransactorSession) AcceptFundsFromOldBridge() (*types.Transaction, error) {
	return _ERC20Bridge.Contract.AcceptFundsFromOldBridge(&_ERC20Bridge.TransactOpts)
}

// EnqueueDelayedMessage is a paid mutator transaction binding the contract method 0x75d81e25.
//
// Solidity: function enqueueDelayedMessage(uint8 kind, address sender, bytes32 messageDataHash, uint256 tokenFeeAmount) returns(uint256)
func (_ERC20Bridge *ERC20BridgeTransactor) EnqueueDelayedMessage(opts *bind.TransactOpts, kind uint8, sender common.Address, messageDataHash [32]byte, tokenFeeAmount *big.Int) (*types.Transaction, error) {
	return _ERC20Bridge.contract.Transact(opts, "enqueueDelayedMessage", kind, sender, messageDataHash, tokenFeeAmount)
}

// EnqueueDelayedMessage is a paid mutator transaction binding the contract method 0x75d81e25.
//
// Solidity: function enqueueDelayedMessage(uint8 kind, address sender, bytes32 messageDataHash, uint256 tokenFeeAmount) returns(uint256)
func (_ERC20Bridge *ERC20BridgeSession) EnqueueDelayedMessage(kind uint8, sender common.Address, messageDataHash [32]byte, tokenFeeAmount *big.Int) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.EnqueueDelayedMessage(&_ERC20Bridge.TransactOpts, kind, sender, messageDataHash, tokenFeeAmount)
}

// EnqueueDelayedMessage is a paid mutator transaction binding the contract method 0x75d81e25.
//
// Solidity: function enqueueDelayedMessage(uint8 kind, address sender, bytes32 messageDataHash, uint256 tokenFeeAmount) returns(uint256)
func (_ERC20Bridge *ERC20BridgeTransactorSession) EnqueueDelayedMessage(kind uint8, sender common.Address, messageDataHash [32]byte, tokenFeeAmount *big.Int) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.EnqueueDelayedMessage(&_ERC20Bridge.TransactOpts, kind, sender, messageDataHash, tokenFeeAmount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_ERC20Bridge *ERC20BridgeTransactor) EnqueueSequencerMessage(opts *bind.TransactOpts, dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _ERC20Bridge.contract.Transact(opts, "enqueueSequencerMessage", dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_ERC20Bridge *ERC20BridgeSession) EnqueueSequencerMessage(dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.EnqueueSequencerMessage(&_ERC20Bridge.TransactOpts, dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_ERC20Bridge *ERC20BridgeTransactorSession) EnqueueSequencerMessage(dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.EnqueueSequencerMessage(&_ERC20Bridge.TransactOpts, dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_ERC20Bridge *ERC20BridgeTransactor) ExecuteCall(opts *bind.TransactOpts, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Bridge.contract.Transact(opts, "executeCall", to, value, data)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_ERC20Bridge *ERC20BridgeSession) ExecuteCall(to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.ExecuteCall(&_ERC20Bridge.TransactOpts, to, value, data)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_ERC20Bridge *ERC20BridgeTransactorSession) ExecuteCall(to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.ExecuteCall(&_ERC20Bridge.TransactOpts, to, value, data)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address rollup_, address nativeToken_) returns()
func (_ERC20Bridge *ERC20BridgeTransactor) Initialize(opts *bind.TransactOpts, rollup_ common.Address, nativeToken_ common.Address) (*types.Transaction, error) {
	return _ERC20Bridge.contract.Transact(opts, "initialize", rollup_, nativeToken_)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address rollup_, address nativeToken_) returns()
func (_ERC20Bridge *ERC20BridgeSession) Initialize(rollup_ common.Address, nativeToken_ common.Address) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.Initialize(&_ERC20Bridge.TransactOpts, rollup_, nativeToken_)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address rollup_, address nativeToken_) returns()
func (_ERC20Bridge *ERC20BridgeTransactorSession) Initialize(rollup_ common.Address, nativeToken_ common.Address) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.Initialize(&_ERC20Bridge.TransactOpts, rollup_, nativeToken_)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_ERC20Bridge *ERC20BridgeTransactor) SetDelayedInbox(opts *bind.TransactOpts, inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _ERC20Bridge.contract.Transact(opts, "setDelayedInbox", inbox, enabled)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_ERC20Bridge *ERC20BridgeSession) SetDelayedInbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.SetDelayedInbox(&_ERC20Bridge.TransactOpts, inbox, enabled)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_ERC20Bridge *ERC20BridgeTransactorSession) SetDelayedInbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.SetDelayedInbox(&_ERC20Bridge.TransactOpts, inbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address outbox, bool enabled) returns()
func (_ERC20Bridge *ERC20BridgeTransactor) SetOutbox(opts *bind.TransactOpts, outbox common.Address, enabled bool) (*types.Transaction, error) {
	return _ERC20Bridge.contract.Transact(opts, "setOutbox", outbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address outbox, bool enabled) returns()
func (_ERC20Bridge *ERC20BridgeSession) SetOutbox(outbox common.Address, enabled bool) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.SetOutbox(&_ERC20Bridge.TransactOpts, outbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address outbox, bool enabled) returns()
func (_ERC20Bridge *ERC20BridgeTransactorSession) SetOutbox(outbox common.Address, enabled bool) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.SetOutbox(&_ERC20Bridge.TransactOpts, outbox, enabled)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_ERC20Bridge *ERC20BridgeTransactor) SetSequencerInbox(opts *bind.TransactOpts, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _ERC20Bridge.contract.Transact(opts, "setSequencerInbox", _sequencerInbox)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_ERC20Bridge *ERC20BridgeSession) SetSequencerInbox(_sequencerInbox common.Address) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.SetSequencerInbox(&_ERC20Bridge.TransactOpts, _sequencerInbox)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_ERC20Bridge *ERC20BridgeTransactorSession) SetSequencerInbox(_sequencerInbox common.Address) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.SetSequencerInbox(&_ERC20Bridge.TransactOpts, _sequencerInbox)
}

// SetSequencerReportedSubMessageCount is a paid mutator transaction binding the contract method 0xf81ff3b3.
//
// Solidity: function setSequencerReportedSubMessageCount(uint256 newMsgCount) returns()
func (_ERC20Bridge *ERC20BridgeTransactor) SetSequencerReportedSubMessageCount(opts *bind.TransactOpts, newMsgCount *big.Int) (*types.Transaction, error) {
	return _ERC20Bridge.contract.Transact(opts, "setSequencerReportedSubMessageCount", newMsgCount)
}

// SetSequencerReportedSubMessageCount is a paid mutator transaction binding the contract method 0xf81ff3b3.
//
// Solidity: function setSequencerReportedSubMessageCount(uint256 newMsgCount) returns()
func (_ERC20Bridge *ERC20BridgeSession) SetSequencerReportedSubMessageCount(newMsgCount *big.Int) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.SetSequencerReportedSubMessageCount(&_ERC20Bridge.TransactOpts, newMsgCount)
}

// SetSequencerReportedSubMessageCount is a paid mutator transaction binding the contract method 0xf81ff3b3.
//
// Solidity: function setSequencerReportedSubMessageCount(uint256 newMsgCount) returns()
func (_ERC20Bridge *ERC20BridgeTransactorSession) SetSequencerReportedSubMessageCount(newMsgCount *big.Int) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.SetSequencerReportedSubMessageCount(&_ERC20Bridge.TransactOpts, newMsgCount)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address sender, bytes32 messageDataHash) returns(uint256)
func (_ERC20Bridge *ERC20BridgeTransactor) SubmitBatchSpendingReport(opts *bind.TransactOpts, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _ERC20Bridge.contract.Transact(opts, "submitBatchSpendingReport", sender, messageDataHash)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address sender, bytes32 messageDataHash) returns(uint256)
func (_ERC20Bridge *ERC20BridgeSession) SubmitBatchSpendingReport(sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.SubmitBatchSpendingReport(&_ERC20Bridge.TransactOpts, sender, messageDataHash)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address sender, bytes32 messageDataHash) returns(uint256)
func (_ERC20Bridge *ERC20BridgeTransactorSession) SubmitBatchSpendingReport(sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.SubmitBatchSpendingReport(&_ERC20Bridge.TransactOpts, sender, messageDataHash)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_ERC20Bridge *ERC20BridgeTransactor) UpdateRollupAddress(opts *bind.TransactOpts, _rollup common.Address) (*types.Transaction, error) {
	return _ERC20Bridge.contract.Transact(opts, "updateRollupAddress", _rollup)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_ERC20Bridge *ERC20BridgeSession) UpdateRollupAddress(_rollup common.Address) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.UpdateRollupAddress(&_ERC20Bridge.TransactOpts, _rollup)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_ERC20Bridge *ERC20BridgeTransactorSession) UpdateRollupAddress(_rollup common.Address) (*types.Transaction, error) {
	return _ERC20Bridge.Contract.UpdateRollupAddress(&_ERC20Bridge.TransactOpts, _rollup)
}

// ERC20BridgeBridgeCallTriggeredIterator is returned from FilterBridgeCallTriggered and is used to iterate over the raw logs and unpacked data for BridgeCallTriggered events raised by the ERC20Bridge contract.
type ERC20BridgeBridgeCallTriggeredIterator struct {
	Event *ERC20BridgeBridgeCallTriggered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BridgeBridgeCallTriggeredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BridgeBridgeCallTriggered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BridgeBridgeCallTriggered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BridgeBridgeCallTriggeredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BridgeBridgeCallTriggeredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BridgeBridgeCallTriggered represents a BridgeCallTriggered event raised by the ERC20Bridge contract.
type ERC20BridgeBridgeCallTriggered struct {
	Outbox common.Address
	To     common.Address
	Value  *big.Int
	Data   []byte
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBridgeCallTriggered is a free log retrieval operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_ERC20Bridge *ERC20BridgeFilterer) FilterBridgeCallTriggered(opts *bind.FilterOpts, outbox []common.Address, to []common.Address) (*ERC20BridgeBridgeCallTriggeredIterator, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20Bridge.contract.FilterLogs(opts, "BridgeCallTriggered", outboxRule, toRule)
	if err != nil {
		return nil, err
	}
	return &ERC20BridgeBridgeCallTriggeredIterator{contract: _ERC20Bridge.contract, event: "BridgeCallTriggered", logs: logs, sub: sub}, nil
}

// WatchBridgeCallTriggered is a free log subscription operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_ERC20Bridge *ERC20BridgeFilterer) WatchBridgeCallTriggered(opts *bind.WatchOpts, sink chan<- *ERC20BridgeBridgeCallTriggered, outbox []common.Address, to []common.Address) (event.Subscription, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _ERC20Bridge.contract.WatchLogs(opts, "BridgeCallTriggered", outboxRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BridgeBridgeCallTriggered)
				if err := _ERC20Bridge.contract.UnpackLog(event, "BridgeCallTriggered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBridgeCallTriggered is a log parse operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_ERC20Bridge *ERC20BridgeFilterer) ParseBridgeCallTriggered(log types.Log) (*ERC20BridgeBridgeCallTriggered, error) {
	event := new(ERC20BridgeBridgeCallTriggered)
	if err := _ERC20Bridge.contract.UnpackLog(event, "BridgeCallTriggered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20BridgeInboxToggleIterator is returned from FilterInboxToggle and is used to iterate over the raw logs and unpacked data for InboxToggle events raised by the ERC20Bridge contract.
type ERC20BridgeInboxToggleIterator struct {
	Event *ERC20BridgeInboxToggle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BridgeInboxToggleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BridgeInboxToggle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BridgeInboxToggle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BridgeInboxToggleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BridgeInboxToggleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BridgeInboxToggle represents a InboxToggle event raised by the ERC20Bridge contract.
type ERC20BridgeInboxToggle struct {
	Inbox   common.Address
	Enabled bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInboxToggle is a free log retrieval operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_ERC20Bridge *ERC20BridgeFilterer) FilterInboxToggle(opts *bind.FilterOpts, inbox []common.Address) (*ERC20BridgeInboxToggleIterator, error) {

	var inboxRule []interface{}
	for _, inboxItem := range inbox {
		inboxRule = append(inboxRule, inboxItem)
	}

	logs, sub, err := _ERC20Bridge.contract.FilterLogs(opts, "InboxToggle", inboxRule)
	if err != nil {
		return nil, err
	}
	return &ERC20BridgeInboxToggleIterator{contract: _ERC20Bridge.contract, event: "InboxToggle", logs: logs, sub: sub}, nil
}

// WatchInboxToggle is a free log subscription operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_ERC20Bridge *ERC20BridgeFilterer) WatchInboxToggle(opts *bind.WatchOpts, sink chan<- *ERC20BridgeInboxToggle, inbox []common.Address) (event.Subscription, error) {

	var inboxRule []interface{}
	for _, inboxItem := range inbox {
		inboxRule = append(inboxRule, inboxItem)
	}

	logs, sub, err := _ERC20Bridge.contract.WatchLogs(opts, "InboxToggle", inboxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BridgeInboxToggle)
				if err := _ERC20Bridge.contract.UnpackLog(event, "InboxToggle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxToggle is a log parse operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_ERC20Bridge *ERC20BridgeFilterer) ParseInboxToggle(log types.Log) (*ERC20BridgeInboxToggle, error) {
	event := new(ERC20BridgeInboxToggle)
	if err := _ERC20Bridge.contract.UnpackLog(event, "InboxToggle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20BridgeInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the ERC20Bridge contract.
type ERC20BridgeInitializedIterator struct {
	Event *ERC20BridgeInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BridgeInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BridgeInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BridgeInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BridgeInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BridgeInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BridgeInitialized represents a Initialized event raised by the ERC20Bridge contract.
type ERC20BridgeInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_ERC20Bridge *ERC20BridgeFilterer) FilterInitialized(opts *bind.FilterOpts) (*ERC20BridgeInitializedIterator, error) {

	logs, sub, err := _ERC20Bridge.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &ERC20BridgeInitializedIterator{contract: _ERC20Bridge.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_ERC20Bridge *ERC20BridgeFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *ERC20BridgeInitialized) (event.Subscription, error) {

	logs, sub, err := _ERC20Bridge.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BridgeInitialized)
				if err := _ERC20Bridge.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_ERC20Bridge *ERC20BridgeFilterer) ParseInitialized(log types.Log) (*ERC20BridgeInitialized, error) {
	event := new(ERC20BridgeInitialized)
	if err := _ERC20Bridge.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20BridgeMessageDeliveredIterator is returned from FilterMessageDelivered and is used to iterate over the raw logs and unpacked data for MessageDelivered events raised by the ERC20Bridge contract.
type ERC20BridgeMessageDeliveredIterator struct {
	Event *ERC20BridgeMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BridgeMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BridgeMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BridgeMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BridgeMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BridgeMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BridgeMessageDelivered represents a MessageDelivered event raised by the ERC20Bridge contract.
type ERC20BridgeMessageDelivered struct {
	MessageIndex    *big.Int
	BeforeInboxAcc  [32]byte
	Inbox           common.Address
	Kind            uint8
	Sender          common.Address
	MessageDataHash [32]byte
	BaseFeeL1       *big.Int
	Timestamp       uint64
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterMessageDelivered is a free log retrieval operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_ERC20Bridge *ERC20BridgeFilterer) FilterMessageDelivered(opts *bind.FilterOpts, messageIndex []*big.Int, beforeInboxAcc [][32]byte) (*ERC20BridgeMessageDeliveredIterator, error) {

	var messageIndexRule []interface{}
	for _, messageIndexItem := range messageIndex {
		messageIndexRule = append(messageIndexRule, messageIndexItem)
	}
	var beforeInboxAccRule []interface{}
	for _, beforeInboxAccItem := range beforeInboxAcc {
		beforeInboxAccRule = append(beforeInboxAccRule, beforeInboxAccItem)
	}

	logs, sub, err := _ERC20Bridge.contract.FilterLogs(opts, "MessageDelivered", messageIndexRule, beforeInboxAccRule)
	if err != nil {
		return nil, err
	}
	return &ERC20BridgeMessageDeliveredIterator{contract: _ERC20Bridge.contract, event: "MessageDelivered", logs: logs, sub: sub}, nil
}

// WatchMessageDelivered is a free log subscription operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_ERC20Bridge *ERC20BridgeFilterer) WatchMessageDelivered(opts *bind.WatchOpts, sink chan<- *ERC20BridgeMessageDelivered, messageIndex []*big.Int, beforeInboxAcc [][32]byte) (event.Subscription, error) {

	var messageIndexRule []interface{}
	for _, messageIndexItem := range messageIndex {
		messageIndexRule = append(messageIndexRule, messageIndexItem)
	}
	var beforeInboxAccRule []interface{}
	for _, beforeInboxAccItem := range beforeInboxAcc {
		beforeInboxAccRule = append(beforeInboxAccRule, beforeInboxAccItem)
	}

	logs, sub, err := _ERC20Bridge.contract.WatchLogs(opts, "MessageDelivered", messageIndexRule, beforeInboxAccRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BridgeMessageDelivered)
				if err := _ERC20Bridge.contract.UnpackLog(event, "MessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageDelivered is a log parse operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_ERC20Bridge *ERC20BridgeFilterer) ParseMessageDelivered(log types.Log) (*ERC20BridgeMessageDelivered, error) {
	event := new(ERC20BridgeMessageDelivered)
	if err := _ERC20Bridge.contract.UnpackLog(event, "MessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20BridgeOutboxToggleIterator is returned from FilterOutboxToggle and is used to iterate over the raw logs and unpacked data for OutboxToggle events raised by the ERC20Bridge contract.
type ERC20BridgeOutboxToggleIterator struct {
	Event *ERC20BridgeOutboxToggle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BridgeOutboxToggleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BridgeOutboxToggle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BridgeOutboxToggle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BridgeOutboxToggleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BridgeOutboxToggleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BridgeOutboxToggle represents a OutboxToggle event raised by the ERC20Bridge contract.
type ERC20BridgeOutboxToggle struct {
	Outbox  common.Address
	Enabled bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterOutboxToggle is a free log retrieval operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_ERC20Bridge *ERC20BridgeFilterer) FilterOutboxToggle(opts *bind.FilterOpts, outbox []common.Address) (*ERC20BridgeOutboxToggleIterator, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}

	logs, sub, err := _ERC20Bridge.contract.FilterLogs(opts, "OutboxToggle", outboxRule)
	if err != nil {
		return nil, err
	}
	return &ERC20BridgeOutboxToggleIterator{contract: _ERC20Bridge.contract, event: "OutboxToggle", logs: logs, sub: sub}, nil
}

// WatchOutboxToggle is a free log subscription operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_ERC20Bridge *ERC20BridgeFilterer) WatchOutboxToggle(opts *bind.WatchOpts, sink chan<- *ERC20BridgeOutboxToggle, outbox []common.Address) (event.Subscription, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}

	logs, sub, err := _ERC20Bridge.contract.WatchLogs(opts, "OutboxToggle", outboxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BridgeOutboxToggle)
				if err := _ERC20Bridge.contract.UnpackLog(event, "OutboxToggle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOutboxToggle is a log parse operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_ERC20Bridge *ERC20BridgeFilterer) ParseOutboxToggle(log types.Log) (*ERC20BridgeOutboxToggle, error) {
	event := new(ERC20BridgeOutboxToggle)
	if err := _ERC20Bridge.contract.UnpackLog(event, "OutboxToggle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20BridgeRollupUpdatedIterator is returned from FilterRollupUpdated and is used to iterate over the raw logs and unpacked data for RollupUpdated events raised by the ERC20Bridge contract.
type ERC20BridgeRollupUpdatedIterator struct {
	Event *ERC20BridgeRollupUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BridgeRollupUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BridgeRollupUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BridgeRollupUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BridgeRollupUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BridgeRollupUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BridgeRollupUpdated represents a RollupUpdated event raised by the ERC20Bridge contract.
type ERC20BridgeRollupUpdated struct {
	Rollup common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRollupUpdated is a free log retrieval operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_ERC20Bridge *ERC20BridgeFilterer) FilterRollupUpdated(opts *bind.FilterOpts) (*ERC20BridgeRollupUpdatedIterator, error) {

	logs, sub, err := _ERC20Bridge.contract.FilterLogs(opts, "RollupUpdated")
	if err != nil {
		return nil, err
	}
	return &ERC20BridgeRollupUpdatedIterator{contract: _ERC20Bridge.contract, event: "RollupUpdated", logs: logs, sub: sub}, nil
}

// WatchRollupUpdated is a free log subscription operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_ERC20Bridge *ERC20BridgeFilterer) WatchRollupUpdated(opts *bind.WatchOpts, sink chan<- *ERC20BridgeRollupUpdated) (event.Subscription, error) {

	logs, sub, err := _ERC20Bridge.contract.WatchLogs(opts, "RollupUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BridgeRollupUpdated)
				if err := _ERC20Bridge.contract.UnpackLog(event, "RollupUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupUpdated is a log parse operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_ERC20Bridge *ERC20BridgeFilterer) ParseRollupUpdated(log types.Log) (*ERC20BridgeRollupUpdated, error) {
	event := new(ERC20BridgeRollupUpdated)
	if err := _ERC20Bridge.contract.UnpackLog(event, "RollupUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20BridgeSequencerInboxUpdatedIterator is returned from FilterSequencerInboxUpdated and is used to iterate over the raw logs and unpacked data for SequencerInboxUpdated events raised by the ERC20Bridge contract.
type ERC20BridgeSequencerInboxUpdatedIterator struct {
	Event *ERC20BridgeSequencerInboxUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20BridgeSequencerInboxUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20BridgeSequencerInboxUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20BridgeSequencerInboxUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20BridgeSequencerInboxUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20BridgeSequencerInboxUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20BridgeSequencerInboxUpdated represents a SequencerInboxUpdated event raised by the ERC20Bridge contract.
type ERC20BridgeSequencerInboxUpdated struct {
	NewSequencerInbox common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterSequencerInboxUpdated is a free log retrieval operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_ERC20Bridge *ERC20BridgeFilterer) FilterSequencerInboxUpdated(opts *bind.FilterOpts) (*ERC20BridgeSequencerInboxUpdatedIterator, error) {

	logs, sub, err := _ERC20Bridge.contract.FilterLogs(opts, "SequencerInboxUpdated")
	if err != nil {
		return nil, err
	}
	return &ERC20BridgeSequencerInboxUpdatedIterator{contract: _ERC20Bridge.contract, event: "SequencerInboxUpdated", logs: logs, sub: sub}, nil
}

// WatchSequencerInboxUpdated is a free log subscription operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_ERC20Bridge *ERC20BridgeFilterer) WatchSequencerInboxUpdated(opts *bind.WatchOpts, sink chan<- *ERC20BridgeSequencerInboxUpdated) (event.Subscription, error) {

	logs, sub, err := _ERC20Bridge.contract.WatchLogs(opts, "SequencerInboxUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20BridgeSequencerInboxUpdated)
				if err := _ERC20Bridge.contract.UnpackLog(event, "SequencerInboxUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSequencerInboxUpdated is a log parse operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_ERC20Bridge *ERC20BridgeFilterer) ParseSequencerInboxUpdated(log types.Log) (*ERC20BridgeSequencerInboxUpdated, error) {
	event := new(ERC20BridgeSequencerInboxUpdated)
	if err := _ERC20Bridge.contract.UnpackLog(event, "SequencerInboxUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20InboxMetaData contains all meta data concerning the ERC20Inbox contract.
var ERC20InboxMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDataSize\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AmountTooLarge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDataLength\",\"type\":\"uint256\"}],\"name\":\"DataTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GasLimitTooLarge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InsufficientSubmissionCost\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InsufficientValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"L1Forked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"}],\"name\":\"NotAllowedOrigin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotCodelessOrigin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotRollupOrOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"RetryableData\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"AllowListAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"AllowListEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowListEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"calculateRetryableSubmissionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenTotalFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createRetryableTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"contractISequencerInbox\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDataSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendContractTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2Message\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2MessageFromOrigin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendUnsignedTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"contractISequencerInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"val\",\"type\":\"bool[]\"}],\"name\":\"setAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowListEnabled\",\"type\":\"bool\"}],\"name\":\"setAllowListEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenTotalFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unsafeCreateRetryableTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60e03461009757601f61237038819003918201601f19168301916001600160401b0383118484101761009c578084926020946040528339810103126100975751306080524660c05260a0526040516122bd90816100b3823960805181611008015260a0518181816102e00152818161074a0152818161150e0152818161197a0152611e43015260c051818181610a5f01526114da0152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe60406080815260048036101561001457600080fd5b600090813560e01c80631fe927cf1461148a57806322bd5c1c146114635780633f4ba83a14611304578063485cc95514610f9b5780635075788b14610ebf578063549e842614610d8b5780635c975abb14610d675780638456cb5914610c365780638a631aa614610b3a5780638b3240a014610af2578063a66b327d14610ad7578063b75436bb14610a09578063b79092fd146106bc578063b9b9a68814610634578063babcc539146105f4578063e3de72a51461032c578063e78cea9214610303578063e8eb1dc3146102c8578063ee35f3271461029f5763efeadb6d146100fc57600080fd5b3461029b57602090816003193601126102975780359081151580920361029357606554855163cb23bcb560e01b81526001600160a01b0391859082908590829086165afa90811561028957908291879161026c575b5016908133036101e7575b50506066549060ff8260a01c16151583146101b6575060ff60a01b191660a082901b60ff60a01b1617606655925192835290917f16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb39190a180f35b855162461bcd60e51b8152908101849052600b60248201526a1053149150511657d4d15560aa1b6044820152606490fd5b8651638da5cb5b60e01b81529085828581865afa918215610262578792610233575b50811633031561015c578651630739600760e01b815291829161022f9133848701611852565b0390fd5b610254919250863d881161025b575b61024c81836117f9565b810190611833565b9038610209565b503d610242565b88513d89823e3d90fd5b6102839150863d881161025b5761024c81836117f9565b38610151565b87513d88823e3d90fd5b8380fd5b8280fd5b5080fd5b82843461029b578160031936011261029b5760665490516001600160a01b039091168152602090f35b82843461029b578160031936011261029b57602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b82843461029b578160031936011261029b5760655490516001600160a01b039091168152602090f35b509190346105f157816003193601126105f1578235926001600160401b03808511610297573660238601121561029757848201359461036a8661181c565b94610377815196876117f9565b8686526020918287016024809960051b830101913683116105ca578901905b8282106105d25750505086359283116105ce57366023840112156105ce5782840135926103c28461181c565b936103cf835195866117f9565b808552888486019160051b830101913683116105ca578901905b8282106105ae575050606554825163cb23bcb560e01b81526001600160a01b03925090849082908890829086165afa9081156105a4579082918891610587575b5016803303610513575b5086518451036104e157855b87518110156104dd576104528186611875565b51151582610460838b611875565b51168852606785528388209060ff8019835416911617905581610483828a611875565b51167fd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a856104b18489611875565b5115158651908152a260001981146104cb5760010161043f565b634e487b7160e01b8752601186528887fd5b8680f35b815162461bcd60e51b8152808601849052600d818a01526c1253959053125117d253941555609a1b6044820152606490fd5b8251638da5cb5b60e01b815284818881855afa90811561057d578891610560575b5082811633036105445750610433565b8351630739600760e01b815291829161022f9133848b01611852565b6105779150853d871161025b5761024c81836117f9565b38610534565b84513d8a823e3d90fd5b61059e9150853d871161025b5761024c81836117f9565b38610429565b83513d89823e3d90fd5b813580151581036105c65781529084019084016103e9565b8880fd5b8780fd5b8480fd5b81356001600160a01b03811681036105c6578152908401908401610396565b80fd5b5082903461029757602036600319011261029757356001600160a01b0381169081900361029757818360ff92602095526067855220541690519015158152f35b5090346105f15761064436611753565b9a909961065b99929998939897949796959661189f565b8c60ff60665460a01c1691826106a5575b505061068e5760208c6106878d8d8d8d8d8d8d8d8d8d611d99565b9051908152f35b6024908c5190630f51ed7160e41b82523290820152fd5b60ff92503281526067602052205416158c3861066c565b50913461029b57602092836003193601126102975780356106db61189f565b60ff60665460a01c16806109f4575b6109dd573391823b158015906109d3575b6109b7575b61070982612108565b8451606094851b6001600160601b031916888201908152603480830193909352918152938401906001600160401b038211858310176109a4578186528451917f0000000000000000000000000000000000000000000000000000000000000000808411610988575050206065548551631c2eb17b60e31b81526001600160a01b039491899082908690829089165afa90811561097e579085918991610961575b501686516370a0823160e01b815230858201528981602481855afa90811561095757918993918b969593859161091f575b508281106108b0575b505091600c93916084938760655416918a5198899788966375d81e2560e01b88528701526111118060901b013301166024860152604485015260648401525af19384156108a5578094610861575b50506000805160206122488339815191526108588492845191829188835288830190611935565b0390a251908152f35b909480945085813d831161089e575b61087a81836117f9565b810103126105f1575060008051602061224883398151915261085893945193610831565b503d610870565b8351903d90823e3d90fd5b9193509193945082039082821161090c57600c936084936109018c97948c948c51916323b872dd60e01b8b8401523360248401523060448401526064830152606482526108fc826117c8565b611b50565b9193819395506107e3565b634e487b7160e01b895260118552602489fd5b9294505091939481813d8311610950575b61093a81836117f9565b810103126105c6579189949391899351386107da565b503d610930565b88513d8b823e3d90fd5b61097891508a3d8c1161025b5761024c81836117f9565b386107a9565b87513d8a823e3d90fd5b634634691b60e01b825260648701849052608487015260449150fd5b634e487b7160e01b875260418352602487fd5b61111161111160901b019092016001600160a01b031691610700565b50823214156106fb565b506024915190630f51ed7160e41b82523290820152fd5b503284526067855260ff8385205416156106ea565b508290346102975760203660031901126102975780356001600160401b03811161029357610a3a9036908301611721565b919093610a4561189f565b8360ff60665460a01c169182610ac0575b5050610aa957467f000000000000000000000000000000000000000000000000000000000000000003610a9b5750610a956020936106879236916118fe565b33611975565b825163c6ea680360e01b8152fd5b602490835190630f51ed7160e41b82523290820152fd5b60ff92503281526067602052205416158386610a56565b82843461029b578060031936011261029b5751908152602090f35b82843461029b578160031936011261029b577fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035490516001600160a01b039091168152602090f35b509190346105f15760a03660031901126105f1576044356001600160a01b038116938035929185900361029b576001600160401b0360843581811161029357610b869036908401611721565b929091610b9161189f565b60ff60665460a01c1680610c20575b610c0a578511610bfc5750610687936020969383610a959460a1948951978895600160f81b8d880152602187015260243560418701526061860152606435608186015285850137820190838201520360818101845201826117f9565b855163107c527b60e01b8152fd5b8651630f51ed7160e41b81523281840152602490fd5b50328552606760205260ff878620541615610ba0565b508234610297578260031936011261029757606554815163cb23bcb560e01b81526020936001600160a01b0392909190859082908490829087165afa908115610d5d579083918791610d40575b501691823303610ccf575b857f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2588686610cba61189f565b600160ff19603354161760335551338152a180f35b8351638da5cb5b60e01b81529085828481875afa918215610d36578792610d17575b508116330315610c8e5761022f908451938493630739600760e01b855233908501611852565b610d2f919250863d881161025b5761024c81836117f9565b9087610cf1565b85513d89823e3d90fd5b610d579150863d881161025b5761024c81836117f9565b87610c83565b84513d88823e3d90fd5b82843461029b578160031936011261029b5760209060ff6033541690519015158152f35b509190346105f157610d9c36611753565b9b95949099610db299929998939897949761189f565b8b60ff60665460a01c169182610ea8575b5050610e9257848196610dd58b612108565b610df2610de28789611d63565b610dec8d8d611d86565b90611d63565b8110610e5e5750509160209c9997959391836106879c9a9896943b610e3f575b50803b610e20575b50611d99565b6001600160a01b0390811661111161111160901b010116945038610e1a565b6001600160a01b0390811661111161111160901b010116945038610e12565b604492508d610e7b8b610dec8e610e758b8d611d63565b92611d86565b9051631c102d6360e21b8152928301526024820152fd5b8a51630f51ed7160e41b81523281880152602490fd5b60ff92503281526067602052205416158b38610dc3565b509190346105f15760c03660031901126105f1576064356001600160a01b038116938035929185900361029b576001600160401b0360a43581811161029357610f0b9036908401611721565b929091610f1661189f565b60ff60665460a01c1680610f85575b610c0a578511610bfc5750610687936020969383610a959460c1948951978895858d880152602187015260243560418701526044356061870152608186015260843560a186015285850137820190838201520360a18101845201826117f9565b50328552606760205260ff878620541615610f25565b508290346102975781600319360112610297576001600160a01b03908035828116908190036105ce57602480359284841680940361130057865460ff8160081c1615948580966112f3575b80156112dc575b156112835760ff198281166001178a559186611272575b50867f000000000000000000000000000000000000000000000000000000000000000016301461121b576110789060ff8a5460081c169061104482611d03565b606580546001600160a01b03191688179055606680546001600160a81b03191691909117905561107381611d03565b611d03565b60335416603355855194631c2eb17b60e31b865260209586818481885afa9081156109575789916111fe575b5016918651636eb1769f60e11b8152308382015284828201528681604481875afa9081156109575789916111d1575b5061117057865163095ea7b360e01b8782015281810194909452600019604480860191909152845260808401916001600160401b0383118584101761115f57505085526111209190611b50565b611128578280f35b7f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989161ff001984541684555160018152a181808280f35b634e487b7160e01b89526041905287fd5b865162461bcd60e51b81529182018690526036908201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b6064820152608490fd5b90508681813d83116111f7575b6111e881836117f9565b810103126105c65751896110d3565b503d6111de565b6112159150873d891161025b5761024c81836117f9565b896110a4565b875162461bcd60e51b8152602081850152602c818601527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201526b19195b1959d85d1958d85b1b60a21b6064820152608490fd5b61ffff191661010117895589611004565b875162461bcd60e51b8152602081850152602e818601527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608490fd5b50303b158015610fed5750600160ff831614610fed565b50600160ff831610610fe6565b8680fd5b50913461029b578160031936011261029b57606554815163cb23bcb560e01b8152602092916001600160a01b039190849082908890829086165afa90811561145957908291869161143c575b5016908133036113d5575b50506033549360ff85161561139d57507f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa929360ff191660335551338152a180f35b82606492519162461bcd60e51b8352820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b6044820152fd5b8251638da5cb5b60e01b81529084828881865afa918215610d5d57869261141d575b50811633031561135b578251630739600760e01b815291829161022f9133848a01611852565b611435919250853d871161025b5761024c81836117f9565b90386113f7565b6114539150853d871161025b5761024c81836117f9565b38611350565b83513d87823e3d90fd5b82843461029b578160031936011261029b5760209060ff60665460a01c1690519015158152f35b50913461029b57602092836003193601126102975780356001600160401b038111610293576114bc9036908301611721565b6114c461189f565b60ff60665460a01c168061170c575b6116f657467f0000000000000000000000000000000000000000000000000000000000000000036116e657323314806116dd575b156116cd577f00000000000000000000000000000000000000000000000000000000000000008082116116b25750906115419136916118fe565b8051908501206065548351631c2eb17b60e31b81526001600160a01b039392918416919087818581865afa90811561168b57859189918991611695575b5060248851809481936370a0823160e01b8352308a840152165afa801561168b5791889493918893611654575b509160039391608493885197889687956375d81e2560e01b87528601526111118060901b01330116602485015260448401528160648401525af190811561164857839161160d575b506000805160206122688339815191528192519380a28152f35b90508381813d8311611641575b61162481836117f9565b8101031261029757516000805160206122688339815191526115f3565b503d61161a565b505051903d90823e3d90fd5b909250849193943d8311611684575b61166d81836117f9565b81010312611680578692918691386115ab565b8580fd5b503d611663565b86513d89823e3d90fd5b6116ac9150823d841161025b5761024c81836117f9565b3861157e565b91506044935192634634691b60e01b84528301526024820152fd5b835163c8958ead60e01b81528390fd5b50333b15611507565b835163c6ea680360e01b81528390fd5b8351630f51ed7160e41b81523281850152602490fd5b503285526067865260ff8486205416156114d3565b9181601f8401121561174e578235916001600160401b03831161174e576020838186019501011161174e57565b600080fd5b9061012060031983011261174e576001600160a01b0391600435838116810361174e57926024359260443592606435838116810361174e5792608435908116810361174e579160a4359160c4359160e4359161010435906001600160401b03821161174e576117c491600401611721565b9091565b60a081019081106001600160401b038211176117e357604052565b634e487b7160e01b600052604160045260246000fd5b601f909101601f19168101906001600160401b038211908210176117e357604052565b6001600160401b0381116117e35760051b60200190565b9081602091031261174e57516001600160a01b038116810361174e5790565b6001600160a01b0391821681529181166020830152909116604082015260600190565b80518210156118895760209160051b010190565b634e487b7160e01b600052603260045260246000fd5b60ff603354166118ab57565b60405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606490fd5b6001600160401b0381116117e357601f01601f191660200190565b92919261190a826118e3565b9161191860405193846117f9565b82948184528183011161174e578281602093846000960137010152565b919082519283825260005b848110611961575050826000602080949584010152601f8019910116010190565b602081830181015184830182015201611940565b9080517f0000000000000000000000000000000000000000000000000000000000000000808211611b32575050805160208083019190912060655460408051631c2eb17b60e31b8152929590926001600160a01b03928316908581600481855afa908115611b0a5784918791600091611b15575b5060248751809481936370a0823160e01b8352306004840152165afa8015611b0a57908694939291611adc575b5084516375d81e2560e01b81526003600482015291831661111161111160901b010190921660248201526044810196909652600060648701819052869160849183915af1938415611ad157600094611a94575b50518181528392600080516020612248833981519152928291611a8e91830190611935565b0390a290565b90938282813d8311611aca575b611aab81836117f9565b810103126105f157505192600080516020612248833981519152611a69565b503d611aa1565b50513d6000823e3d90fd5b849192943d8311611b03575b611af281836117f9565b8101031261174e5791849238611a16565b503d611ae8565b85513d6000823e3d90fd5b611b2c9150823d841161025b5761024c81836117f9565b386119e9565b6044925060405191634634691b60e01b835260048301526024820152fd5b604080516001600160a01b03929092169290918083016001600160401b038111828210176117e35783526020938482527f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656485830152803b15611c7f5790611bec9160008481959282898195519301915af13d15611c77573d90611bd2826118e3565b91611bdf875193846117f9565b82523d858884013e611cc3565b805180611bfb575b5050505050565b8185918101031261029b57830151908115918215036105f15750611c2157808080611bf4565b60849250519062461bcd60e51b82526004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152fd5b606090611cc3565b835162461bcd60e51b815260048101869052601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606490fd5b90919015611ccf575090565b815115611cdf5750805190602001fd5b60405162461bcd60e51b81526020600482015290819061022f906024830190611935565b15611d0a57565b60405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608490fd5b91908201809211611d7057565b634e487b7160e01b600052601160045260246000fd5b81810292918115918404141715611d7057565b939597909297969491966001831480156120fe575b61207c576001600160401b03831161206a57611e3f92611dcd87612108565b94604098899788519c8d9c608060209e8f81019b8c9760018060a01b039e8f998a8099169052830152606082015201521660a08d01521660c08b015260e08a015261010089015261012098808a8a01528061014092838b01378801988860009a8b8482015203908101895201876117f9565b85517f000000000000000000000000000000000000000000000000000000000000000080821161204d57505085519020906004858260655416865192838092631c2eb17b60e31b82525afa908115612043579082918991612026575b501684516370a0823160e01b81523060048201528681602481855afa90811561201c579087949392918a91611fe7575b50858110611f86575b5050808860849260655416875196879586946375d81e2560e01b8652600960048701526111118060901b013301166024860152604485015260648401525af1948515611f7b578095611f47575b5050518181528392600080516020612248833981519152928291611a8e91830190611935565b909194508282813d8311611f74575b611f6081836117f9565b810103126105f15750519281611a8e611f21565b503d611f56565b8251903d90823e3d90fd5b9091929350840390848211611fd35791611fcc6084928895948851916323b872dd60e01b888401523360248401523060448401526064830152606482526108fc826117c8565b9038611ed4565b634e487b7160e01b89526011600452602489fd5b85819394959692503d8311612015575b61200181836117f9565b810103126105c65790869392915138611ecb565b503d611ff7565b86513d8b823e3d90fd5b61203d9150873d891161025b5761024c81836117f9565b38611e9b565b85513d8a823e3d90fd5b60449250855191634634691b60e01b835260048301526024820152fd5b60405163107c527b60e01b8152600490fd5b929095899489604051998a986307c266e360e01b8a523360048b015260018060a01b03958680951660248c015260448b015260648a015260848901521660a48701521660c485015260e4840152610104830152610140610124830152806101448301528061016493848401376000828201840152601f01601f19168101030190fd5b5060018114611dae565b6065546040516356a465af60e11b815291929190602090829060049082906001600160a01b03165afa9081156121bd57600091612182575b50601260ff82161061215a575b61215791926121da565b90565b6001600160c01b0383111561214d576040516304041d9560e11b815260048101849052602490fd5b6020813d82116121b5575b8161219a602093836117f9565b8101031261029b57519060ff821682036105f1575038612140565b3d915061218d565b6040513d6000823e3d90fd5b60ff16604d8111611d7057600a0a90565b9060ff16601281036121ea575090565b6012811015612211576012039060ff8211611d705761220b612157926121c9565b90611d86565b6011190160ff8111611d7057612226906121c9565b908115612231570490565b634e487b7160e01b600052601260045260246000fdfeff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60bab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9ca26469706673582212209cd3e5355576e4f2142d87af2cbdcd24879bd1d55b919e3e37eb80cc0164020b64736f6c63430008130033",
}

// ERC20InboxABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC20InboxMetaData.ABI instead.
var ERC20InboxABI = ERC20InboxMetaData.ABI

// ERC20InboxBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ERC20InboxMetaData.Bin instead.
var ERC20InboxBin = ERC20InboxMetaData.Bin

// DeployERC20Inbox deploys a new Ethereum contract, binding an instance of ERC20Inbox to it.
func DeployERC20Inbox(auth *bind.TransactOpts, backend bind.ContractBackend, _maxDataSize *big.Int) (common.Address, *types.Transaction, *ERC20Inbox, error) {
	parsed, err := ERC20InboxMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ERC20InboxBin), backend, _maxDataSize)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20Inbox{ERC20InboxCaller: ERC20InboxCaller{contract: contract}, ERC20InboxTransactor: ERC20InboxTransactor{contract: contract}, ERC20InboxFilterer: ERC20InboxFilterer{contract: contract}}, nil
}

// ERC20Inbox is an auto generated Go binding around an Ethereum contract.
type ERC20Inbox struct {
	ERC20InboxCaller     // Read-only binding to the contract
	ERC20InboxTransactor // Write-only binding to the contract
	ERC20InboxFilterer   // Log filterer for contract events
}

// ERC20InboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20InboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20InboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20InboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20InboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20InboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20InboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20InboxSession struct {
	Contract     *ERC20Inbox       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20InboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20InboxCallerSession struct {
	Contract *ERC20InboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// ERC20InboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20InboxTransactorSession struct {
	Contract     *ERC20InboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// ERC20InboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20InboxRaw struct {
	Contract *ERC20Inbox // Generic contract binding to access the raw methods on
}

// ERC20InboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20InboxCallerRaw struct {
	Contract *ERC20InboxCaller // Generic read-only contract binding to access the raw methods on
}

// ERC20InboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20InboxTransactorRaw struct {
	Contract *ERC20InboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20Inbox creates a new instance of ERC20Inbox, bound to a specific deployed contract.
func NewERC20Inbox(address common.Address, backend bind.ContractBackend) (*ERC20Inbox, error) {
	contract, err := bindERC20Inbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20Inbox{ERC20InboxCaller: ERC20InboxCaller{contract: contract}, ERC20InboxTransactor: ERC20InboxTransactor{contract: contract}, ERC20InboxFilterer: ERC20InboxFilterer{contract: contract}}, nil
}

// NewERC20InboxCaller creates a new read-only instance of ERC20Inbox, bound to a specific deployed contract.
func NewERC20InboxCaller(address common.Address, caller bind.ContractCaller) (*ERC20InboxCaller, error) {
	contract, err := bindERC20Inbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20InboxCaller{contract: contract}, nil
}

// NewERC20InboxTransactor creates a new write-only instance of ERC20Inbox, bound to a specific deployed contract.
func NewERC20InboxTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC20InboxTransactor, error) {
	contract, err := bindERC20Inbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20InboxTransactor{contract: contract}, nil
}

// NewERC20InboxFilterer creates a new log filterer instance of ERC20Inbox, bound to a specific deployed contract.
func NewERC20InboxFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC20InboxFilterer, error) {
	contract, err := bindERC20Inbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20InboxFilterer{contract: contract}, nil
}

// bindERC20Inbox binds a generic wrapper to an already deployed contract.
func bindERC20Inbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ERC20InboxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Inbox *ERC20InboxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Inbox.Contract.ERC20InboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Inbox *ERC20InboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.ERC20InboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Inbox *ERC20InboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.ERC20InboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Inbox *ERC20InboxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Inbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Inbox *ERC20InboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Inbox *ERC20InboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.contract.Transact(opts, method, params...)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_ERC20Inbox *ERC20InboxCaller) AllowListEnabled(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "allowListEnabled")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_ERC20Inbox *ERC20InboxSession) AllowListEnabled() (bool, error) {
	return _ERC20Inbox.Contract.AllowListEnabled(&_ERC20Inbox.CallOpts)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_ERC20Inbox *ERC20InboxCallerSession) AllowListEnabled() (bool, error) {
	return _ERC20Inbox.Contract.AllowListEnabled(&_ERC20Inbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_ERC20Inbox *ERC20InboxCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_ERC20Inbox *ERC20InboxSession) Bridge() (common.Address, error) {
	return _ERC20Inbox.Contract.Bridge(&_ERC20Inbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_ERC20Inbox *ERC20InboxCallerSession) Bridge() (common.Address, error) {
	return _ERC20Inbox.Contract.Bridge(&_ERC20Inbox.CallOpts)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 , uint256 ) pure returns(uint256)
func (_ERC20Inbox *ERC20InboxCaller) CalculateRetryableSubmissionFee(opts *bind.CallOpts, arg0 *big.Int, arg1 *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "calculateRetryableSubmissionFee", arg0, arg1)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 , uint256 ) pure returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) CalculateRetryableSubmissionFee(arg0 *big.Int, arg1 *big.Int) (*big.Int, error) {
	return _ERC20Inbox.Contract.CalculateRetryableSubmissionFee(&_ERC20Inbox.CallOpts, arg0, arg1)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 , uint256 ) pure returns(uint256)
func (_ERC20Inbox *ERC20InboxCallerSession) CalculateRetryableSubmissionFee(arg0 *big.Int, arg1 *big.Int) (*big.Int, error) {
	return _ERC20Inbox.Contract.CalculateRetryableSubmissionFee(&_ERC20Inbox.CallOpts, arg0, arg1)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_ERC20Inbox *ERC20InboxCaller) GetProxyAdmin(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "getProxyAdmin")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_ERC20Inbox *ERC20InboxSession) GetProxyAdmin() (common.Address, error) {
	return _ERC20Inbox.Contract.GetProxyAdmin(&_ERC20Inbox.CallOpts)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_ERC20Inbox *ERC20InboxCallerSession) GetProxyAdmin() (common.Address, error) {
	return _ERC20Inbox.Contract.GetProxyAdmin(&_ERC20Inbox.CallOpts)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address ) view returns(bool)
func (_ERC20Inbox *ERC20InboxCaller) IsAllowed(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "isAllowed", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address ) view returns(bool)
func (_ERC20Inbox *ERC20InboxSession) IsAllowed(arg0 common.Address) (bool, error) {
	return _ERC20Inbox.Contract.IsAllowed(&_ERC20Inbox.CallOpts, arg0)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address ) view returns(bool)
func (_ERC20Inbox *ERC20InboxCallerSession) IsAllowed(arg0 common.Address) (bool, error) {
	return _ERC20Inbox.Contract.IsAllowed(&_ERC20Inbox.CallOpts, arg0)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_ERC20Inbox *ERC20InboxCaller) MaxDataSize(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "maxDataSize")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) MaxDataSize() (*big.Int, error) {
	return _ERC20Inbox.Contract.MaxDataSize(&_ERC20Inbox.CallOpts)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_ERC20Inbox *ERC20InboxCallerSession) MaxDataSize() (*big.Int, error) {
	return _ERC20Inbox.Contract.MaxDataSize(&_ERC20Inbox.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_ERC20Inbox *ERC20InboxCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_ERC20Inbox *ERC20InboxSession) Paused() (bool, error) {
	return _ERC20Inbox.Contract.Paused(&_ERC20Inbox.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_ERC20Inbox *ERC20InboxCallerSession) Paused() (bool, error) {
	return _ERC20Inbox.Contract.Paused(&_ERC20Inbox.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_ERC20Inbox *ERC20InboxCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Inbox.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_ERC20Inbox *ERC20InboxSession) SequencerInbox() (common.Address, error) {
	return _ERC20Inbox.Contract.SequencerInbox(&_ERC20Inbox.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_ERC20Inbox *ERC20InboxCallerSession) SequencerInbox() (common.Address, error) {
	return _ERC20Inbox.Contract.SequencerInbox(&_ERC20Inbox.CallOpts)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x549e8426.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) CreateRetryableTicket(opts *bind.TransactOpts, to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "createRetryableTicket", to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x549e8426.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) CreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.CreateRetryableTicket(&_ERC20Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x549e8426.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) CreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.CreateRetryableTicket(&_ERC20Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// DepositERC20 is a paid mutator transaction binding the contract method 0xb79092fd.
//
// Solidity: function depositERC20(uint256 amount) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) DepositERC20(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "depositERC20", amount)
}

// DepositERC20 is a paid mutator transaction binding the contract method 0xb79092fd.
//
// Solidity: function depositERC20(uint256 amount) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) DepositERC20(amount *big.Int) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.DepositERC20(&_ERC20Inbox.TransactOpts, amount)
}

// DepositERC20 is a paid mutator transaction binding the contract method 0xb79092fd.
//
// Solidity: function depositERC20(uint256 amount) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) DepositERC20(amount *big.Int) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.DepositERC20(&_ERC20Inbox.TransactOpts, amount)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_ERC20Inbox *ERC20InboxTransactor) Initialize(opts *bind.TransactOpts, _bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "initialize", _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_ERC20Inbox *ERC20InboxSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.Initialize(&_ERC20Inbox.TransactOpts, _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_ERC20Inbox *ERC20InboxTransactorSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.Initialize(&_ERC20Inbox.TransactOpts, _bridge, _sequencerInbox)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_ERC20Inbox *ERC20InboxTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_ERC20Inbox *ERC20InboxSession) Pause() (*types.Transaction, error) {
	return _ERC20Inbox.Contract.Pause(&_ERC20Inbox.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_ERC20Inbox *ERC20InboxTransactorSession) Pause() (*types.Transaction, error) {
	return _ERC20Inbox.Contract.Pause(&_ERC20Inbox.TransactOpts)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) SendContractTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "sendContractTransaction", gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendContractTransaction(&_ERC20Inbox.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendContractTransaction(&_ERC20Inbox.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) SendL2Message(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "sendL2Message", messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendL2Message(&_ERC20Inbox.TransactOpts, messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendL2Message(&_ERC20Inbox.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) SendL2MessageFromOrigin(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "sendL2MessageFromOrigin", messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendL2MessageFromOrigin(&_ERC20Inbox.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendL2MessageFromOrigin(&_ERC20Inbox.TransactOpts, messageData)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) SendUnsignedTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "sendUnsignedTransaction", gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendUnsignedTransaction(&_ERC20Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SendUnsignedTransaction(&_ERC20Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_ERC20Inbox *ERC20InboxTransactor) SetAllowList(opts *bind.TransactOpts, user []common.Address, val []bool) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "setAllowList", user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_ERC20Inbox *ERC20InboxSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SetAllowList(&_ERC20Inbox.TransactOpts, user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_ERC20Inbox *ERC20InboxTransactorSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SetAllowList(&_ERC20Inbox.TransactOpts, user, val)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_ERC20Inbox *ERC20InboxTransactor) SetAllowListEnabled(opts *bind.TransactOpts, _allowListEnabled bool) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "setAllowListEnabled", _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_ERC20Inbox *ERC20InboxSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SetAllowListEnabled(&_ERC20Inbox.TransactOpts, _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_ERC20Inbox *ERC20InboxTransactorSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.SetAllowListEnabled(&_ERC20Inbox.TransactOpts, _allowListEnabled)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_ERC20Inbox *ERC20InboxTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_ERC20Inbox *ERC20InboxSession) Unpause() (*types.Transaction, error) {
	return _ERC20Inbox.Contract.Unpause(&_ERC20Inbox.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_ERC20Inbox *ERC20InboxTransactorSession) Unpause() (*types.Transaction, error) {
	return _ERC20Inbox.Contract.Unpause(&_ERC20Inbox.TransactOpts)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0xb9b9a688.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactor) UnsafeCreateRetryableTicket(opts *bind.TransactOpts, to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.contract.Transact(opts, "unsafeCreateRetryableTicket", to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0xb9b9a688.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxSession) UnsafeCreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.UnsafeCreateRetryableTicket(&_ERC20Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0xb9b9a688.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_ERC20Inbox *ERC20InboxTransactorSession) UnsafeCreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Inbox.Contract.UnsafeCreateRetryableTicket(&_ERC20Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// ERC20InboxAllowListAddressSetIterator is returned from FilterAllowListAddressSet and is used to iterate over the raw logs and unpacked data for AllowListAddressSet events raised by the ERC20Inbox contract.
type ERC20InboxAllowListAddressSetIterator struct {
	Event *ERC20InboxAllowListAddressSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxAllowListAddressSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxAllowListAddressSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxAllowListAddressSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxAllowListAddressSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxAllowListAddressSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxAllowListAddressSet represents a AllowListAddressSet event raised by the ERC20Inbox contract.
type ERC20InboxAllowListAddressSet struct {
	User common.Address
	Val  bool
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterAllowListAddressSet is a free log retrieval operation binding the contract event 0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a.
//
// Solidity: event AllowListAddressSet(address indexed user, bool val)
func (_ERC20Inbox *ERC20InboxFilterer) FilterAllowListAddressSet(opts *bind.FilterOpts, user []common.Address) (*ERC20InboxAllowListAddressSetIterator, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "AllowListAddressSet", userRule)
	if err != nil {
		return nil, err
	}
	return &ERC20InboxAllowListAddressSetIterator{contract: _ERC20Inbox.contract, event: "AllowListAddressSet", logs: logs, sub: sub}, nil
}

// WatchAllowListAddressSet is a free log subscription operation binding the contract event 0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a.
//
// Solidity: event AllowListAddressSet(address indexed user, bool val)
func (_ERC20Inbox *ERC20InboxFilterer) WatchAllowListAddressSet(opts *bind.WatchOpts, sink chan<- *ERC20InboxAllowListAddressSet, user []common.Address) (event.Subscription, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "AllowListAddressSet", userRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxAllowListAddressSet)
				if err := _ERC20Inbox.contract.UnpackLog(event, "AllowListAddressSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAllowListAddressSet is a log parse operation binding the contract event 0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a.
//
// Solidity: event AllowListAddressSet(address indexed user, bool val)
func (_ERC20Inbox *ERC20InboxFilterer) ParseAllowListAddressSet(log types.Log) (*ERC20InboxAllowListAddressSet, error) {
	event := new(ERC20InboxAllowListAddressSet)
	if err := _ERC20Inbox.contract.UnpackLog(event, "AllowListAddressSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20InboxAllowListEnabledUpdatedIterator is returned from FilterAllowListEnabledUpdated and is used to iterate over the raw logs and unpacked data for AllowListEnabledUpdated events raised by the ERC20Inbox contract.
type ERC20InboxAllowListEnabledUpdatedIterator struct {
	Event *ERC20InboxAllowListEnabledUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxAllowListEnabledUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxAllowListEnabledUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxAllowListEnabledUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxAllowListEnabledUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxAllowListEnabledUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxAllowListEnabledUpdated represents a AllowListEnabledUpdated event raised by the ERC20Inbox contract.
type ERC20InboxAllowListEnabledUpdated struct {
	IsEnabled bool
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterAllowListEnabledUpdated is a free log retrieval operation binding the contract event 0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3.
//
// Solidity: event AllowListEnabledUpdated(bool isEnabled)
func (_ERC20Inbox *ERC20InboxFilterer) FilterAllowListEnabledUpdated(opts *bind.FilterOpts) (*ERC20InboxAllowListEnabledUpdatedIterator, error) {

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "AllowListEnabledUpdated")
	if err != nil {
		return nil, err
	}
	return &ERC20InboxAllowListEnabledUpdatedIterator{contract: _ERC20Inbox.contract, event: "AllowListEnabledUpdated", logs: logs, sub: sub}, nil
}

// WatchAllowListEnabledUpdated is a free log subscription operation binding the contract event 0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3.
//
// Solidity: event AllowListEnabledUpdated(bool isEnabled)
func (_ERC20Inbox *ERC20InboxFilterer) WatchAllowListEnabledUpdated(opts *bind.WatchOpts, sink chan<- *ERC20InboxAllowListEnabledUpdated) (event.Subscription, error) {

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "AllowListEnabledUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxAllowListEnabledUpdated)
				if err := _ERC20Inbox.contract.UnpackLog(event, "AllowListEnabledUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAllowListEnabledUpdated is a log parse operation binding the contract event 0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3.
//
// Solidity: event AllowListEnabledUpdated(bool isEnabled)
func (_ERC20Inbox *ERC20InboxFilterer) ParseAllowListEnabledUpdated(log types.Log) (*ERC20InboxAllowListEnabledUpdated, error) {
	event := new(ERC20InboxAllowListEnabledUpdated)
	if err := _ERC20Inbox.contract.UnpackLog(event, "AllowListEnabledUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20InboxInboxMessageDeliveredIterator is returned from FilterInboxMessageDelivered and is used to iterate over the raw logs and unpacked data for InboxMessageDelivered events raised by the ERC20Inbox contract.
type ERC20InboxInboxMessageDeliveredIterator struct {
	Event *ERC20InboxInboxMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxInboxMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxInboxMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxInboxMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxInboxMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxInboxMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxInboxMessageDelivered represents a InboxMessageDelivered event raised by the ERC20Inbox contract.
type ERC20InboxInboxMessageDelivered struct {
	MessageNum *big.Int
	Data       []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDelivered is a free log retrieval operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_ERC20Inbox *ERC20InboxFilterer) FilterInboxMessageDelivered(opts *bind.FilterOpts, messageNum []*big.Int) (*ERC20InboxInboxMessageDeliveredIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &ERC20InboxInboxMessageDeliveredIterator{contract: _ERC20Inbox.contract, event: "InboxMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDelivered is a free log subscription operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_ERC20Inbox *ERC20InboxFilterer) WatchInboxMessageDelivered(opts *bind.WatchOpts, sink chan<- *ERC20InboxInboxMessageDelivered, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxInboxMessageDelivered)
				if err := _ERC20Inbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDelivered is a log parse operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_ERC20Inbox *ERC20InboxFilterer) ParseInboxMessageDelivered(log types.Log) (*ERC20InboxInboxMessageDelivered, error) {
	event := new(ERC20InboxInboxMessageDelivered)
	if err := _ERC20Inbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20InboxInboxMessageDeliveredFromOriginIterator is returned from FilterInboxMessageDeliveredFromOrigin and is used to iterate over the raw logs and unpacked data for InboxMessageDeliveredFromOrigin events raised by the ERC20Inbox contract.
type ERC20InboxInboxMessageDeliveredFromOriginIterator struct {
	Event *ERC20InboxInboxMessageDeliveredFromOrigin // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxInboxMessageDeliveredFromOriginIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxInboxMessageDeliveredFromOrigin)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxInboxMessageDeliveredFromOrigin)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxInboxMessageDeliveredFromOriginIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxInboxMessageDeliveredFromOriginIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxInboxMessageDeliveredFromOrigin represents a InboxMessageDeliveredFromOrigin event raised by the ERC20Inbox contract.
type ERC20InboxInboxMessageDeliveredFromOrigin struct {
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDeliveredFromOrigin is a free log retrieval operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_ERC20Inbox *ERC20InboxFilterer) FilterInboxMessageDeliveredFromOrigin(opts *bind.FilterOpts, messageNum []*big.Int) (*ERC20InboxInboxMessageDeliveredFromOriginIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &ERC20InboxInboxMessageDeliveredFromOriginIterator{contract: _ERC20Inbox.contract, event: "InboxMessageDeliveredFromOrigin", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDeliveredFromOrigin is a free log subscription operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_ERC20Inbox *ERC20InboxFilterer) WatchInboxMessageDeliveredFromOrigin(opts *bind.WatchOpts, sink chan<- *ERC20InboxInboxMessageDeliveredFromOrigin, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxInboxMessageDeliveredFromOrigin)
				if err := _ERC20Inbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDeliveredFromOrigin is a log parse operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_ERC20Inbox *ERC20InboxFilterer) ParseInboxMessageDeliveredFromOrigin(log types.Log) (*ERC20InboxInboxMessageDeliveredFromOrigin, error) {
	event := new(ERC20InboxInboxMessageDeliveredFromOrigin)
	if err := _ERC20Inbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20InboxInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the ERC20Inbox contract.
type ERC20InboxInitializedIterator struct {
	Event *ERC20InboxInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxInitialized represents a Initialized event raised by the ERC20Inbox contract.
type ERC20InboxInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_ERC20Inbox *ERC20InboxFilterer) FilterInitialized(opts *bind.FilterOpts) (*ERC20InboxInitializedIterator, error) {

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &ERC20InboxInitializedIterator{contract: _ERC20Inbox.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_ERC20Inbox *ERC20InboxFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *ERC20InboxInitialized) (event.Subscription, error) {

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxInitialized)
				if err := _ERC20Inbox.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_ERC20Inbox *ERC20InboxFilterer) ParseInitialized(log types.Log) (*ERC20InboxInitialized, error) {
	event := new(ERC20InboxInitialized)
	if err := _ERC20Inbox.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20InboxPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the ERC20Inbox contract.
type ERC20InboxPausedIterator struct {
	Event *ERC20InboxPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxPaused represents a Paused event raised by the ERC20Inbox contract.
type ERC20InboxPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_ERC20Inbox *ERC20InboxFilterer) FilterPaused(opts *bind.FilterOpts) (*ERC20InboxPausedIterator, error) {

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &ERC20InboxPausedIterator{contract: _ERC20Inbox.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_ERC20Inbox *ERC20InboxFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *ERC20InboxPaused) (event.Subscription, error) {

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxPaused)
				if err := _ERC20Inbox.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_ERC20Inbox *ERC20InboxFilterer) ParsePaused(log types.Log) (*ERC20InboxPaused, error) {
	event := new(ERC20InboxPaused)
	if err := _ERC20Inbox.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20InboxUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the ERC20Inbox contract.
type ERC20InboxUnpausedIterator struct {
	Event *ERC20InboxUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20InboxUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20InboxUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20InboxUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20InboxUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20InboxUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20InboxUnpaused represents a Unpaused event raised by the ERC20Inbox contract.
type ERC20InboxUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_ERC20Inbox *ERC20InboxFilterer) FilterUnpaused(opts *bind.FilterOpts) (*ERC20InboxUnpausedIterator, error) {

	logs, sub, err := _ERC20Inbox.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &ERC20InboxUnpausedIterator{contract: _ERC20Inbox.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_ERC20Inbox *ERC20InboxFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *ERC20InboxUnpaused) (event.Subscription, error) {

	logs, sub, err := _ERC20Inbox.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20InboxUnpaused)
				if err := _ERC20Inbox.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_ERC20Inbox *ERC20InboxFilterer) ParseUnpaused(log types.Log) (*ERC20InboxUnpaused, error) {
	event := new(ERC20InboxUnpaused)
	if err := _ERC20Inbox.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20OutboxMetaData contains all meta data concerning the ERC20Outbox contract.
var ERC20OutboxMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"AlreadyInit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"AlreadySpent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadPostUpgradeInit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BridgeCallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HadZeroInit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxProofLength\",\"type\":\"uint256\"}],\"name\":\"MerkleProofTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"}],\"name\":\"NotRollup\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxIndex\",\"type\":\"uint256\"}],\"name\":\"PathNotMinimal\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proofLength\",\"type\":\"uint256\"}],\"name\":\"ProofTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RollupNotChanged\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SimulationOnlyEntrypoint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"UnknownRoot\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"zero\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionIndex\",\"type\":\"uint256\"}],\"name\":\"OutBoxTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"outputRoot\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"l2BlockHash\",\"type\":\"bytes32\"}],\"name\":\"SendRootUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OUTBOX_VERSION\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"calculateItemHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"path\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"item\",\"type\":\"bytes32\"}],\"name\":\"calculateMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeTransactionSimulation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isSpent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1BatchNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Block\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1EthBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1OutputId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Sender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1WithdrawalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"postUpgradeInit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"roots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spent\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2BlockHash\",\"type\":\"bytes32\"}],\"name\":\"updateSendRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a0806040523461002a57306080526112c19081610030823960805181818161066801526108b50152f35b600080fdfe6080604052600436101561001257600080fd5b60003560e01c80627436d31461016657806308635a9514610161578063119852711461015c578063288e5b101461015757806346547790146101525780635a129efe1461014d5780636ae71f121461014857806372f2a8c71461014357806380648b021461013e5780638515bc6a1461013957806395fcea78146101345780639f0c04bf1461012f578063a04cee601461012a578063ae6dead714610125578063b0f3053714610120578063c4d66de81461011b578063c75184df14610116578063cb23bcb514610111578063cbf96f631461010c578063d5b5cc23146101075763e78cea921461010257600080fd5b610a4e565b610a22565b610a07565b6109de565b6109c2565b61088a565b61086f565b610843565b6107c1565b61075a565b610649565b61062e565b610601565b6105e6565b610476565b610447565b61042c565b6103af565b610393565b6102fc565b610249565b634e487b7160e01b600052604160045260246000fd5b60c081019081106001600160401b0382111761019c57604052565b61016b565b604081019081106001600160401b0382111761019c57604052565b601f909101601f19168101906001600160401b0382119082101761019c57604052565b604051906101ec82610181565b565b9092916001600160401b03841161019c578360051b6040519260208094610217828501826101bc565b809781520191810192831161024457905b8282106102355750505050565b81358152908301908301610228565b600080fd5b34610244576060366003190112610244576004356001600160401b03811161024457366023820112156102445761029c61028f60209236906024816004013591016101ee565b60443590602435906110f5565b604051908152f35b6001600160a01b0381160361024457565b604435906101ec826102a4565b606435906101ec826102a4565b9181601f84011215610244578235916001600160401b038311610244576020838186019501011161024457565b3461024457610120366003190112610244576001600160401b036004358181116102445736602382011215610244578060040135828111610244573660248260051b840101116102445761034e6102b5565b6103566102c2565b9061010435948511610244576103736103919536906004016102cf565b94909360e4359360c4359360a4359360843593602480359201610c06565b005b3461024457600036600319011261024457602060405160008152f35b3461024457610100366003190112610244576024356103cd816102a4565b6044356103d9816102a4565b60e4356001600160401b038111610244576103f89036906004016102cf565b913361041a576103919360c4359160a435916084359160643591600435610dca565b604051630e13b69d60e01b8152600490fd5b3461024457600036600319011261024457602061029c610bb1565b346102445760203660031901126102445760206001610467600435610f09565b604051911c9092161515825250f35b34610244576000806003193601126105e3578054604051638da5cb5b60e01b8082526001600160a01b039283169291602091908281600481885afa801561056257849187916105c6575b50163303610567575060015460049082906104eb906001600160a01b03165b6001600160a01b031690565b60405163cb23bcb560e01b815292839182905afa918215610562578592610535575b5050168091146105235761052090610ad8565b80f35b60405163d054909f60e01b8152600490fd5b6105549250803d1061055b575b61054c81836101bc565b810190610b55565b388061050d565b503d610542565b610b6d565b8193925060046040518094819382525afa918215610562576105a593926105a9575b5050604051631194af8760e11b81529182913360048401610b79565b0390fd5b6105bf9250803d1061055b5761054c81836101bc565b3880610589565b6105dd9150843d861161055b5761054c81836101bc565b386104c0565b80fd5b3461024457600036600319011261024457602061029c610bf7565b3461024457600036600319011261024457602061061c610b93565b6040516001600160a01b039091168152f35b3461024457600036600319011261024457602061029c610bc9565b34610244576000366003190112610244576001600160a01b03610690307f000000000000000000000000000000000000000000000000000000000000000083161415610a77565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610354908116330361073c576004546001600160801b03166002600160801b03190161072a576103916040516106e481610181565b6001600160801b0381526001600160801b0360208201525b600019604082018190526001600160a01b0360608301526001600160601b03608083015260a0820152610afa565b60405163d0afb66160e01b8152600490fd5b604051631194af8760e11b81529081906105a5903360048401610b79565b346102445760e036600319011261024457600435610777816102a4565b602435610783816102a4565b60c435906001600160401b038211610244576020926107a961029c9336906004016102cf565b92909160a4359160843591606435916044359161108d565b34610244576040366003190112610244576000805460243590600435906001600160a01b031633819003610825575080835260036020528160408420557fb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f67488380a380f35b604051630e4cf1bf60e21b81529081906105a5903360048401610b79565b346102445760203660031901126102445760043560005260036020526020604060002054604051908152f35b3461024457600036600319011261024457602061029c610be0565b34610244576020366003190112610244576004356108a7816102a4565b6001600160a01b036108dd307f000000000000000000000000000000000000000000000000000000000000000083161415610a77565b8082169182156109b0576001546108fe906104df906001600160a01b031681565b61099e576004926109536020926109316109166101df565b6001600160801b0381526001600160801b03818701526106fc565b600180546001600160a01b0319166001600160a01b0392909216919091179055565b60405163cb23bcb560e01b815293849182905afa80156105625761039192600091610980575b5016610ad8565b610998915060203d811161055b5761054c81836101bc565b38610979565b604051633bcd329760e21b8152600490fd5b604051631ad0f74360e01b8152600490fd5b3461024457600036600319011261024457602060405160028152f35b34610244576000366003190112610244576000546040516001600160a01b039091168152602090f35b3461024457600036600319011261024457602061029c61119b565b346102445760203660031901126102445760043560005260026020526020604060002054604051908152f35b34610244576000366003190112610244576001546040516001600160a01b039091168152602090f35b15610a7e57565b60405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201526b19195b1959d85d1958d85b1b60a21b6064820152608490fd5b600080546001600160a01b0319166001600160a01b0392909216919091179055565b805160208201516001600160801b039091166001600160801b0319608092831b161760045560408201516005556060820151908201516001600160a01b039091166001600160a01b031960a092831b16176006550151600755565b908160209103126102445751610b6a816102a4565b90565b6040513d6000823e3d90fd5b6001600160a01b0391821681529116602082015260400190565b6006546001600160a01b03908116908114610bab5790565b50600090565b6004546001600160801b03908116908114610bab5790565b60065460a01c6001600160601b038114610bab5790565b60045460801c6001600160801b038114610bab5790565b6005546000198114610bab5790565b610c2d909b9a99989796959493929b610c258b8b8b8b8b8b8b8b61108d565b9236916101ee565b8051610100811015610d09575080610c468d9251610f27565b821015610ce05790610c5892916110f5565b610c6c816000526003602052604060002090565b5415610cc65750610c7c8a610f09565b9b919060018d821c16610cad576101ec9b9c6001610ca7921b17916000526002602052604060002090565b55610dca565b604051639715b8d360e01b815260048101849052602490fd5b6040516310e61af960e31b81526004810191909152602490fd5b610cea9051610f27565b604051630b8a724b60e01b815260048101929092526024820152604490fd5b60405163ab6a068360e01b81526004810191909152602490fd5b60405190610d3082610181565b6004546001600160801b0381168352608090811c602084015260055460408401526006546001600160a01b038116606085015260a090811c9184019190915260075490830152565b6001600160401b03811161019c57601f01601f191660200190565b929192610d9f82610d78565b91610dad60405193846101bc565b829481845281830111610244578281602093846000960137010152565b93979092969194600490602060405187815260008960018060a01b03927f20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab189648585808d16941692a460015416604051938480926356a465af60e11b82525afa8015610562576101ec9a610e96610eb897610e56610ea694610ebe9d610eb198600092610ec3575b506111e7565b99610e81610e62610d23565b9e610e6b6101df565b6001600160801b03918216815297166020880152565b60408601526001600160a01b03166060850152565b6001600160601b03166080830152565b8560a0820152610afa565b3691610d93565b91610fcd565b610afa565b610ee591925060203d8111610eec575b610edd81836101bc565b8101906111aa565b9038610e50565b503d610ed3565b634e487b7160e01b600052601160045260246000fd5b9060ff82049081600052600260205260ff6040600020549293069190565b60ff8111610f36576001901b90565b610ef3565b60005b838110610f4e5750506000910152565b8181015183820152602001610f3e565b9190604083820312610244578251801515810361024457602084015190936001600160401b038211610244570181601f82011215610244578051610fa181610d78565b92610faf60405194856101bc565b8184526020828401011161024457610b6a9160208085019101610f3b565b9060009160018060a01b0383608482600154169360405197889687958693639e5d4c4960e01b85521660048401526024830152606060448301526110208151809281606486015260208686019101610f3b565b601f01601f191681010301925af1908115610562576000908192611069575b50156110485750565b80511561105757805190602001fd5b604051631bb7daad60e11b8152600490fd5b9061108692503d8091833e61107e81836101bc565b810190610f5e565b903861103f565b92956110ef9560c895899498999399604051998a97602089019c8d60018060601b0319809360601b16905260601b16603489015260488801526068870152608886015260a88501528484013781016000838201520360a88101845201826101bc565b51902090565b916040805191602092838101918252838152611110816101a1565b5190209184519261010080851161117e575094939291906000945b83861061113b5750505050505090565b90919293949561114b8783611261565b5160019182891b881661116e57600052835283600020965b01949392919061112b565b9060005283528360002096611163565b84604491855191637ed6198f60e11b835260048301526024820152fd5b6007546000198114610bab5790565b90816020910312610244575160ff811681036102445790565b60ff6011199116019060ff8211610f3657565b60ff16604d8111610f3657600a0a90565b9060ff8116601281036111f957505090565b8060121060001461122a5750611211611216916111c3565b6111d6565b90818102918183041490151715610f365790565b905060120360ff8111610f3657611240906111d6565b90811561124b570490565b634e487b7160e01b600052601260045260246000fd5b80518210156112755760209160051b010190565b634e487b7160e01b600052603260045260246000fdfea26469706673582212206b4854198bf5cddfee6d227ffcc80e04935d921e11ab678ec09f5eb13e84006964736f6c63430008130033",
}

// ERC20OutboxABI is the input ABI used to generate the binding from.
// Deprecated: Use ERC20OutboxMetaData.ABI instead.
var ERC20OutboxABI = ERC20OutboxMetaData.ABI

// ERC20OutboxBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use ERC20OutboxMetaData.Bin instead.
var ERC20OutboxBin = ERC20OutboxMetaData.Bin

// DeployERC20Outbox deploys a new Ethereum contract, binding an instance of ERC20Outbox to it.
func DeployERC20Outbox(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ERC20Outbox, error) {
	parsed, err := ERC20OutboxMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(ERC20OutboxBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ERC20Outbox{ERC20OutboxCaller: ERC20OutboxCaller{contract: contract}, ERC20OutboxTransactor: ERC20OutboxTransactor{contract: contract}, ERC20OutboxFilterer: ERC20OutboxFilterer{contract: contract}}, nil
}

// ERC20Outbox is an auto generated Go binding around an Ethereum contract.
type ERC20Outbox struct {
	ERC20OutboxCaller     // Read-only binding to the contract
	ERC20OutboxTransactor // Write-only binding to the contract
	ERC20OutboxFilterer   // Log filterer for contract events
}

// ERC20OutboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type ERC20OutboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20OutboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ERC20OutboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20OutboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ERC20OutboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ERC20OutboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ERC20OutboxSession struct {
	Contract     *ERC20Outbox      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ERC20OutboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ERC20OutboxCallerSession struct {
	Contract *ERC20OutboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// ERC20OutboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ERC20OutboxTransactorSession struct {
	Contract     *ERC20OutboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// ERC20OutboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type ERC20OutboxRaw struct {
	Contract *ERC20Outbox // Generic contract binding to access the raw methods on
}

// ERC20OutboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ERC20OutboxCallerRaw struct {
	Contract *ERC20OutboxCaller // Generic read-only contract binding to access the raw methods on
}

// ERC20OutboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ERC20OutboxTransactorRaw struct {
	Contract *ERC20OutboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewERC20Outbox creates a new instance of ERC20Outbox, bound to a specific deployed contract.
func NewERC20Outbox(address common.Address, backend bind.ContractBackend) (*ERC20Outbox, error) {
	contract, err := bindERC20Outbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ERC20Outbox{ERC20OutboxCaller: ERC20OutboxCaller{contract: contract}, ERC20OutboxTransactor: ERC20OutboxTransactor{contract: contract}, ERC20OutboxFilterer: ERC20OutboxFilterer{contract: contract}}, nil
}

// NewERC20OutboxCaller creates a new read-only instance of ERC20Outbox, bound to a specific deployed contract.
func NewERC20OutboxCaller(address common.Address, caller bind.ContractCaller) (*ERC20OutboxCaller, error) {
	contract, err := bindERC20Outbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20OutboxCaller{contract: contract}, nil
}

// NewERC20OutboxTransactor creates a new write-only instance of ERC20Outbox, bound to a specific deployed contract.
func NewERC20OutboxTransactor(address common.Address, transactor bind.ContractTransactor) (*ERC20OutboxTransactor, error) {
	contract, err := bindERC20Outbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ERC20OutboxTransactor{contract: contract}, nil
}

// NewERC20OutboxFilterer creates a new log filterer instance of ERC20Outbox, bound to a specific deployed contract.
func NewERC20OutboxFilterer(address common.Address, filterer bind.ContractFilterer) (*ERC20OutboxFilterer, error) {
	contract, err := bindERC20Outbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ERC20OutboxFilterer{contract: contract}, nil
}

// bindERC20Outbox binds a generic wrapper to an already deployed contract.
func bindERC20Outbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ERC20OutboxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Outbox *ERC20OutboxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Outbox.Contract.ERC20OutboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Outbox *ERC20OutboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Outbox.Contract.ERC20OutboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Outbox *ERC20OutboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Outbox.Contract.ERC20OutboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ERC20Outbox *ERC20OutboxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ERC20Outbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ERC20Outbox *ERC20OutboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Outbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ERC20Outbox *ERC20OutboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ERC20Outbox.Contract.contract.Transact(opts, method, params...)
}

// OUTBOXVERSION is a free data retrieval call binding the contract method 0xc75184df.
//
// Solidity: function OUTBOX_VERSION() view returns(uint128)
func (_ERC20Outbox *ERC20OutboxCaller) OUTBOXVERSION(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "OUTBOX_VERSION")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// OUTBOXVERSION is a free data retrieval call binding the contract method 0xc75184df.
//
// Solidity: function OUTBOX_VERSION() view returns(uint128)
func (_ERC20Outbox *ERC20OutboxSession) OUTBOXVERSION() (*big.Int, error) {
	return _ERC20Outbox.Contract.OUTBOXVERSION(&_ERC20Outbox.CallOpts)
}

// OUTBOXVERSION is a free data retrieval call binding the contract method 0xc75184df.
//
// Solidity: function OUTBOX_VERSION() view returns(uint128)
func (_ERC20Outbox *ERC20OutboxCallerSession) OUTBOXVERSION() (*big.Int, error) {
	return _ERC20Outbox.Contract.OUTBOXVERSION(&_ERC20Outbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_ERC20Outbox *ERC20OutboxCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_ERC20Outbox *ERC20OutboxSession) Bridge() (common.Address, error) {
	return _ERC20Outbox.Contract.Bridge(&_ERC20Outbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_ERC20Outbox *ERC20OutboxCallerSession) Bridge() (common.Address, error) {
	return _ERC20Outbox.Contract.Bridge(&_ERC20Outbox.CallOpts)
}

// CalculateItemHash is a free data retrieval call binding the contract method 0x9f0c04bf.
//
// Solidity: function calculateItemHash(address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) pure returns(bytes32)
func (_ERC20Outbox *ERC20OutboxCaller) CalculateItemHash(opts *bind.CallOpts, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) ([32]byte, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "calculateItemHash", l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CalculateItemHash is a free data retrieval call binding the contract method 0x9f0c04bf.
//
// Solidity: function calculateItemHash(address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) pure returns(bytes32)
func (_ERC20Outbox *ERC20OutboxSession) CalculateItemHash(l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) ([32]byte, error) {
	return _ERC20Outbox.Contract.CalculateItemHash(&_ERC20Outbox.CallOpts, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// CalculateItemHash is a free data retrieval call binding the contract method 0x9f0c04bf.
//
// Solidity: function calculateItemHash(address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) pure returns(bytes32)
func (_ERC20Outbox *ERC20OutboxCallerSession) CalculateItemHash(l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) ([32]byte, error) {
	return _ERC20Outbox.Contract.CalculateItemHash(&_ERC20Outbox.CallOpts, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// CalculateMerkleRoot is a free data retrieval call binding the contract method 0x007436d3.
//
// Solidity: function calculateMerkleRoot(bytes32[] proof, uint256 path, bytes32 item) pure returns(bytes32)
func (_ERC20Outbox *ERC20OutboxCaller) CalculateMerkleRoot(opts *bind.CallOpts, proof [][32]byte, path *big.Int, item [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "calculateMerkleRoot", proof, path, item)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CalculateMerkleRoot is a free data retrieval call binding the contract method 0x007436d3.
//
// Solidity: function calculateMerkleRoot(bytes32[] proof, uint256 path, bytes32 item) pure returns(bytes32)
func (_ERC20Outbox *ERC20OutboxSession) CalculateMerkleRoot(proof [][32]byte, path *big.Int, item [32]byte) ([32]byte, error) {
	return _ERC20Outbox.Contract.CalculateMerkleRoot(&_ERC20Outbox.CallOpts, proof, path, item)
}

// CalculateMerkleRoot is a free data retrieval call binding the contract method 0x007436d3.
//
// Solidity: function calculateMerkleRoot(bytes32[] proof, uint256 path, bytes32 item) pure returns(bytes32)
func (_ERC20Outbox *ERC20OutboxCallerSession) CalculateMerkleRoot(proof [][32]byte, path *big.Int, item [32]byte) ([32]byte, error) {
	return _ERC20Outbox.Contract.CalculateMerkleRoot(&_ERC20Outbox.CallOpts, proof, path, item)
}

// IsSpent is a free data retrieval call binding the contract method 0x5a129efe.
//
// Solidity: function isSpent(uint256 index) view returns(bool)
func (_ERC20Outbox *ERC20OutboxCaller) IsSpent(opts *bind.CallOpts, index *big.Int) (bool, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "isSpent", index)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSpent is a free data retrieval call binding the contract method 0x5a129efe.
//
// Solidity: function isSpent(uint256 index) view returns(bool)
func (_ERC20Outbox *ERC20OutboxSession) IsSpent(index *big.Int) (bool, error) {
	return _ERC20Outbox.Contract.IsSpent(&_ERC20Outbox.CallOpts, index)
}

// IsSpent is a free data retrieval call binding the contract method 0x5a129efe.
//
// Solidity: function isSpent(uint256 index) view returns(bool)
func (_ERC20Outbox *ERC20OutboxCallerSession) IsSpent(index *big.Int) (bool, error) {
	return _ERC20Outbox.Contract.IsSpent(&_ERC20Outbox.CallOpts, index)
}

// L2ToL1BatchNum is a free data retrieval call binding the contract method 0x11985271.
//
// Solidity: function l2ToL1BatchNum() pure returns(uint256)
func (_ERC20Outbox *ERC20OutboxCaller) L2ToL1BatchNum(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "l2ToL1BatchNum")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1BatchNum is a free data retrieval call binding the contract method 0x11985271.
//
// Solidity: function l2ToL1BatchNum() pure returns(uint256)
func (_ERC20Outbox *ERC20OutboxSession) L2ToL1BatchNum() (*big.Int, error) {
	return _ERC20Outbox.Contract.L2ToL1BatchNum(&_ERC20Outbox.CallOpts)
}

// L2ToL1BatchNum is a free data retrieval call binding the contract method 0x11985271.
//
// Solidity: function l2ToL1BatchNum() pure returns(uint256)
func (_ERC20Outbox *ERC20OutboxCallerSession) L2ToL1BatchNum() (*big.Int, error) {
	return _ERC20Outbox.Contract.L2ToL1BatchNum(&_ERC20Outbox.CallOpts)
}

// L2ToL1Block is a free data retrieval call binding the contract method 0x46547790.
//
// Solidity: function l2ToL1Block() view returns(uint256)
func (_ERC20Outbox *ERC20OutboxCaller) L2ToL1Block(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "l2ToL1Block")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1Block is a free data retrieval call binding the contract method 0x46547790.
//
// Solidity: function l2ToL1Block() view returns(uint256)
func (_ERC20Outbox *ERC20OutboxSession) L2ToL1Block() (*big.Int, error) {
	return _ERC20Outbox.Contract.L2ToL1Block(&_ERC20Outbox.CallOpts)
}

// L2ToL1Block is a free data retrieval call binding the contract method 0x46547790.
//
// Solidity: function l2ToL1Block() view returns(uint256)
func (_ERC20Outbox *ERC20OutboxCallerSession) L2ToL1Block() (*big.Int, error) {
	return _ERC20Outbox.Contract.L2ToL1Block(&_ERC20Outbox.CallOpts)
}

// L2ToL1EthBlock is a free data retrieval call binding the contract method 0x8515bc6a.
//
// Solidity: function l2ToL1EthBlock() view returns(uint256)
func (_ERC20Outbox *ERC20OutboxCaller) L2ToL1EthBlock(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "l2ToL1EthBlock")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1EthBlock is a free data retrieval call binding the contract method 0x8515bc6a.
//
// Solidity: function l2ToL1EthBlock() view returns(uint256)
func (_ERC20Outbox *ERC20OutboxSession) L2ToL1EthBlock() (*big.Int, error) {
	return _ERC20Outbox.Contract.L2ToL1EthBlock(&_ERC20Outbox.CallOpts)
}

// L2ToL1EthBlock is a free data retrieval call binding the contract method 0x8515bc6a.
//
// Solidity: function l2ToL1EthBlock() view returns(uint256)
func (_ERC20Outbox *ERC20OutboxCallerSession) L2ToL1EthBlock() (*big.Int, error) {
	return _ERC20Outbox.Contract.L2ToL1EthBlock(&_ERC20Outbox.CallOpts)
}

// L2ToL1OutputId is a free data retrieval call binding the contract method 0x72f2a8c7.
//
// Solidity: function l2ToL1OutputId() view returns(bytes32)
func (_ERC20Outbox *ERC20OutboxCaller) L2ToL1OutputId(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "l2ToL1OutputId")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// L2ToL1OutputId is a free data retrieval call binding the contract method 0x72f2a8c7.
//
// Solidity: function l2ToL1OutputId() view returns(bytes32)
func (_ERC20Outbox *ERC20OutboxSession) L2ToL1OutputId() ([32]byte, error) {
	return _ERC20Outbox.Contract.L2ToL1OutputId(&_ERC20Outbox.CallOpts)
}

// L2ToL1OutputId is a free data retrieval call binding the contract method 0x72f2a8c7.
//
// Solidity: function l2ToL1OutputId() view returns(bytes32)
func (_ERC20Outbox *ERC20OutboxCallerSession) L2ToL1OutputId() ([32]byte, error) {
	return _ERC20Outbox.Contract.L2ToL1OutputId(&_ERC20Outbox.CallOpts)
}

// L2ToL1Sender is a free data retrieval call binding the contract method 0x80648b02.
//
// Solidity: function l2ToL1Sender() view returns(address)
func (_ERC20Outbox *ERC20OutboxCaller) L2ToL1Sender(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "l2ToL1Sender")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// L2ToL1Sender is a free data retrieval call binding the contract method 0x80648b02.
//
// Solidity: function l2ToL1Sender() view returns(address)
func (_ERC20Outbox *ERC20OutboxSession) L2ToL1Sender() (common.Address, error) {
	return _ERC20Outbox.Contract.L2ToL1Sender(&_ERC20Outbox.CallOpts)
}

// L2ToL1Sender is a free data retrieval call binding the contract method 0x80648b02.
//
// Solidity: function l2ToL1Sender() view returns(address)
func (_ERC20Outbox *ERC20OutboxCallerSession) L2ToL1Sender() (common.Address, error) {
	return _ERC20Outbox.Contract.L2ToL1Sender(&_ERC20Outbox.CallOpts)
}

// L2ToL1Timestamp is a free data retrieval call binding the contract method 0xb0f30537.
//
// Solidity: function l2ToL1Timestamp() view returns(uint256)
func (_ERC20Outbox *ERC20OutboxCaller) L2ToL1Timestamp(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "l2ToL1Timestamp")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1Timestamp is a free data retrieval call binding the contract method 0xb0f30537.
//
// Solidity: function l2ToL1Timestamp() view returns(uint256)
func (_ERC20Outbox *ERC20OutboxSession) L2ToL1Timestamp() (*big.Int, error) {
	return _ERC20Outbox.Contract.L2ToL1Timestamp(&_ERC20Outbox.CallOpts)
}

// L2ToL1Timestamp is a free data retrieval call binding the contract method 0xb0f30537.
//
// Solidity: function l2ToL1Timestamp() view returns(uint256)
func (_ERC20Outbox *ERC20OutboxCallerSession) L2ToL1Timestamp() (*big.Int, error) {
	return _ERC20Outbox.Contract.L2ToL1Timestamp(&_ERC20Outbox.CallOpts)
}

// L2ToL1WithdrawalAmount is a free data retrieval call binding the contract method 0xcbf96f63.
//
// Solidity: function l2ToL1WithdrawalAmount() view returns(uint256)
func (_ERC20Outbox *ERC20OutboxCaller) L2ToL1WithdrawalAmount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "l2ToL1WithdrawalAmount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1WithdrawalAmount is a free data retrieval call binding the contract method 0xcbf96f63.
//
// Solidity: function l2ToL1WithdrawalAmount() view returns(uint256)
func (_ERC20Outbox *ERC20OutboxSession) L2ToL1WithdrawalAmount() (*big.Int, error) {
	return _ERC20Outbox.Contract.L2ToL1WithdrawalAmount(&_ERC20Outbox.CallOpts)
}

// L2ToL1WithdrawalAmount is a free data retrieval call binding the contract method 0xcbf96f63.
//
// Solidity: function l2ToL1WithdrawalAmount() view returns(uint256)
func (_ERC20Outbox *ERC20OutboxCallerSession) L2ToL1WithdrawalAmount() (*big.Int, error) {
	return _ERC20Outbox.Contract.L2ToL1WithdrawalAmount(&_ERC20Outbox.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_ERC20Outbox *ERC20OutboxCaller) Rollup(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "rollup")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_ERC20Outbox *ERC20OutboxSession) Rollup() (common.Address, error) {
	return _ERC20Outbox.Contract.Rollup(&_ERC20Outbox.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_ERC20Outbox *ERC20OutboxCallerSession) Rollup() (common.Address, error) {
	return _ERC20Outbox.Contract.Rollup(&_ERC20Outbox.CallOpts)
}

// Roots is a free data retrieval call binding the contract method 0xae6dead7.
//
// Solidity: function roots(bytes32 ) view returns(bytes32)
func (_ERC20Outbox *ERC20OutboxCaller) Roots(opts *bind.CallOpts, arg0 [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "roots", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Roots is a free data retrieval call binding the contract method 0xae6dead7.
//
// Solidity: function roots(bytes32 ) view returns(bytes32)
func (_ERC20Outbox *ERC20OutboxSession) Roots(arg0 [32]byte) ([32]byte, error) {
	return _ERC20Outbox.Contract.Roots(&_ERC20Outbox.CallOpts, arg0)
}

// Roots is a free data retrieval call binding the contract method 0xae6dead7.
//
// Solidity: function roots(bytes32 ) view returns(bytes32)
func (_ERC20Outbox *ERC20OutboxCallerSession) Roots(arg0 [32]byte) ([32]byte, error) {
	return _ERC20Outbox.Contract.Roots(&_ERC20Outbox.CallOpts, arg0)
}

// Spent is a free data retrieval call binding the contract method 0xd5b5cc23.
//
// Solidity: function spent(uint256 ) view returns(bytes32)
func (_ERC20Outbox *ERC20OutboxCaller) Spent(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _ERC20Outbox.contract.Call(opts, &out, "spent", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Spent is a free data retrieval call binding the contract method 0xd5b5cc23.
//
// Solidity: function spent(uint256 ) view returns(bytes32)
func (_ERC20Outbox *ERC20OutboxSession) Spent(arg0 *big.Int) ([32]byte, error) {
	return _ERC20Outbox.Contract.Spent(&_ERC20Outbox.CallOpts, arg0)
}

// Spent is a free data retrieval call binding the contract method 0xd5b5cc23.
//
// Solidity: function spent(uint256 ) view returns(bytes32)
func (_ERC20Outbox *ERC20OutboxCallerSession) Spent(arg0 *big.Int) ([32]byte, error) {
	return _ERC20Outbox.Contract.Spent(&_ERC20Outbox.CallOpts, arg0)
}

// ExecuteTransaction is a paid mutator transaction binding the contract method 0x08635a95.
//
// Solidity: function executeTransaction(bytes32[] proof, uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_ERC20Outbox *ERC20OutboxTransactor) ExecuteTransaction(opts *bind.TransactOpts, proof [][32]byte, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Outbox.contract.Transact(opts, "executeTransaction", proof, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransaction is a paid mutator transaction binding the contract method 0x08635a95.
//
// Solidity: function executeTransaction(bytes32[] proof, uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_ERC20Outbox *ERC20OutboxSession) ExecuteTransaction(proof [][32]byte, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Outbox.Contract.ExecuteTransaction(&_ERC20Outbox.TransactOpts, proof, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransaction is a paid mutator transaction binding the contract method 0x08635a95.
//
// Solidity: function executeTransaction(bytes32[] proof, uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_ERC20Outbox *ERC20OutboxTransactorSession) ExecuteTransaction(proof [][32]byte, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Outbox.Contract.ExecuteTransaction(&_ERC20Outbox.TransactOpts, proof, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransactionSimulation is a paid mutator transaction binding the contract method 0x288e5b10.
//
// Solidity: function executeTransactionSimulation(uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_ERC20Outbox *ERC20OutboxTransactor) ExecuteTransactionSimulation(opts *bind.TransactOpts, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Outbox.contract.Transact(opts, "executeTransactionSimulation", index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransactionSimulation is a paid mutator transaction binding the contract method 0x288e5b10.
//
// Solidity: function executeTransactionSimulation(uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_ERC20Outbox *ERC20OutboxSession) ExecuteTransactionSimulation(index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Outbox.Contract.ExecuteTransactionSimulation(&_ERC20Outbox.TransactOpts, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransactionSimulation is a paid mutator transaction binding the contract method 0x288e5b10.
//
// Solidity: function executeTransactionSimulation(uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_ERC20Outbox *ERC20OutboxTransactorSession) ExecuteTransactionSimulation(index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _ERC20Outbox.Contract.ExecuteTransactionSimulation(&_ERC20Outbox.TransactOpts, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _bridge) returns()
func (_ERC20Outbox *ERC20OutboxTransactor) Initialize(opts *bind.TransactOpts, _bridge common.Address) (*types.Transaction, error) {
	return _ERC20Outbox.contract.Transact(opts, "initialize", _bridge)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _bridge) returns()
func (_ERC20Outbox *ERC20OutboxSession) Initialize(_bridge common.Address) (*types.Transaction, error) {
	return _ERC20Outbox.Contract.Initialize(&_ERC20Outbox.TransactOpts, _bridge)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _bridge) returns()
func (_ERC20Outbox *ERC20OutboxTransactorSession) Initialize(_bridge common.Address) (*types.Transaction, error) {
	return _ERC20Outbox.Contract.Initialize(&_ERC20Outbox.TransactOpts, _bridge)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0x95fcea78.
//
// Solidity: function postUpgradeInit() returns()
func (_ERC20Outbox *ERC20OutboxTransactor) PostUpgradeInit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Outbox.contract.Transact(opts, "postUpgradeInit")
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0x95fcea78.
//
// Solidity: function postUpgradeInit() returns()
func (_ERC20Outbox *ERC20OutboxSession) PostUpgradeInit() (*types.Transaction, error) {
	return _ERC20Outbox.Contract.PostUpgradeInit(&_ERC20Outbox.TransactOpts)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0x95fcea78.
//
// Solidity: function postUpgradeInit() returns()
func (_ERC20Outbox *ERC20OutboxTransactorSession) PostUpgradeInit() (*types.Transaction, error) {
	return _ERC20Outbox.Contract.PostUpgradeInit(&_ERC20Outbox.TransactOpts)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_ERC20Outbox *ERC20OutboxTransactor) UpdateRollupAddress(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ERC20Outbox.contract.Transact(opts, "updateRollupAddress")
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_ERC20Outbox *ERC20OutboxSession) UpdateRollupAddress() (*types.Transaction, error) {
	return _ERC20Outbox.Contract.UpdateRollupAddress(&_ERC20Outbox.TransactOpts)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_ERC20Outbox *ERC20OutboxTransactorSession) UpdateRollupAddress() (*types.Transaction, error) {
	return _ERC20Outbox.Contract.UpdateRollupAddress(&_ERC20Outbox.TransactOpts)
}

// UpdateSendRoot is a paid mutator transaction binding the contract method 0xa04cee60.
//
// Solidity: function updateSendRoot(bytes32 root, bytes32 l2BlockHash) returns()
func (_ERC20Outbox *ERC20OutboxTransactor) UpdateSendRoot(opts *bind.TransactOpts, root [32]byte, l2BlockHash [32]byte) (*types.Transaction, error) {
	return _ERC20Outbox.contract.Transact(opts, "updateSendRoot", root, l2BlockHash)
}

// UpdateSendRoot is a paid mutator transaction binding the contract method 0xa04cee60.
//
// Solidity: function updateSendRoot(bytes32 root, bytes32 l2BlockHash) returns()
func (_ERC20Outbox *ERC20OutboxSession) UpdateSendRoot(root [32]byte, l2BlockHash [32]byte) (*types.Transaction, error) {
	return _ERC20Outbox.Contract.UpdateSendRoot(&_ERC20Outbox.TransactOpts, root, l2BlockHash)
}

// UpdateSendRoot is a paid mutator transaction binding the contract method 0xa04cee60.
//
// Solidity: function updateSendRoot(bytes32 root, bytes32 l2BlockHash) returns()
func (_ERC20Outbox *ERC20OutboxTransactorSession) UpdateSendRoot(root [32]byte, l2BlockHash [32]byte) (*types.Transaction, error) {
	return _ERC20Outbox.Contract.UpdateSendRoot(&_ERC20Outbox.TransactOpts, root, l2BlockHash)
}

// ERC20OutboxOutBoxTransactionExecutedIterator is returned from FilterOutBoxTransactionExecuted and is used to iterate over the raw logs and unpacked data for OutBoxTransactionExecuted events raised by the ERC20Outbox contract.
type ERC20OutboxOutBoxTransactionExecutedIterator struct {
	Event *ERC20OutboxOutBoxTransactionExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20OutboxOutBoxTransactionExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20OutboxOutBoxTransactionExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20OutboxOutBoxTransactionExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20OutboxOutBoxTransactionExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20OutboxOutBoxTransactionExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20OutboxOutBoxTransactionExecuted represents a OutBoxTransactionExecuted event raised by the ERC20Outbox contract.
type ERC20OutboxOutBoxTransactionExecuted struct {
	To               common.Address
	L2Sender         common.Address
	Zero             *big.Int
	TransactionIndex *big.Int
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterOutBoxTransactionExecuted is a free log retrieval operation binding the contract event 0x20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab18964.
//
// Solidity: event OutBoxTransactionExecuted(address indexed to, address indexed l2Sender, uint256 indexed zero, uint256 transactionIndex)
func (_ERC20Outbox *ERC20OutboxFilterer) FilterOutBoxTransactionExecuted(opts *bind.FilterOpts, to []common.Address, l2Sender []common.Address, zero []*big.Int) (*ERC20OutboxOutBoxTransactionExecutedIterator, error) {

	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var l2SenderRule []interface{}
	for _, l2SenderItem := range l2Sender {
		l2SenderRule = append(l2SenderRule, l2SenderItem)
	}
	var zeroRule []interface{}
	for _, zeroItem := range zero {
		zeroRule = append(zeroRule, zeroItem)
	}

	logs, sub, err := _ERC20Outbox.contract.FilterLogs(opts, "OutBoxTransactionExecuted", toRule, l2SenderRule, zeroRule)
	if err != nil {
		return nil, err
	}
	return &ERC20OutboxOutBoxTransactionExecutedIterator{contract: _ERC20Outbox.contract, event: "OutBoxTransactionExecuted", logs: logs, sub: sub}, nil
}

// WatchOutBoxTransactionExecuted is a free log subscription operation binding the contract event 0x20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab18964.
//
// Solidity: event OutBoxTransactionExecuted(address indexed to, address indexed l2Sender, uint256 indexed zero, uint256 transactionIndex)
func (_ERC20Outbox *ERC20OutboxFilterer) WatchOutBoxTransactionExecuted(opts *bind.WatchOpts, sink chan<- *ERC20OutboxOutBoxTransactionExecuted, to []common.Address, l2Sender []common.Address, zero []*big.Int) (event.Subscription, error) {

	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var l2SenderRule []interface{}
	for _, l2SenderItem := range l2Sender {
		l2SenderRule = append(l2SenderRule, l2SenderItem)
	}
	var zeroRule []interface{}
	for _, zeroItem := range zero {
		zeroRule = append(zeroRule, zeroItem)
	}

	logs, sub, err := _ERC20Outbox.contract.WatchLogs(opts, "OutBoxTransactionExecuted", toRule, l2SenderRule, zeroRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20OutboxOutBoxTransactionExecuted)
				if err := _ERC20Outbox.contract.UnpackLog(event, "OutBoxTransactionExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOutBoxTransactionExecuted is a log parse operation binding the contract event 0x20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab18964.
//
// Solidity: event OutBoxTransactionExecuted(address indexed to, address indexed l2Sender, uint256 indexed zero, uint256 transactionIndex)
func (_ERC20Outbox *ERC20OutboxFilterer) ParseOutBoxTransactionExecuted(log types.Log) (*ERC20OutboxOutBoxTransactionExecuted, error) {
	event := new(ERC20OutboxOutBoxTransactionExecuted)
	if err := _ERC20Outbox.contract.UnpackLog(event, "OutBoxTransactionExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ERC20OutboxSendRootUpdatedIterator is returned from FilterSendRootUpdated and is used to iterate over the raw logs and unpacked data for SendRootUpdated events raised by the ERC20Outbox contract.
type ERC20OutboxSendRootUpdatedIterator struct {
	Event *ERC20OutboxSendRootUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ERC20OutboxSendRootUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ERC20OutboxSendRootUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ERC20OutboxSendRootUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ERC20OutboxSendRootUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ERC20OutboxSendRootUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ERC20OutboxSendRootUpdated represents a SendRootUpdated event raised by the ERC20Outbox contract.
type ERC20OutboxSendRootUpdated struct {
	OutputRoot  [32]byte
	L2BlockHash [32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSendRootUpdated is a free log retrieval operation binding the contract event 0xb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f6748.
//
// Solidity: event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash)
func (_ERC20Outbox *ERC20OutboxFilterer) FilterSendRootUpdated(opts *bind.FilterOpts, outputRoot [][32]byte, l2BlockHash [][32]byte) (*ERC20OutboxSendRootUpdatedIterator, error) {

	var outputRootRule []interface{}
	for _, outputRootItem := range outputRoot {
		outputRootRule = append(outputRootRule, outputRootItem)
	}
	var l2BlockHashRule []interface{}
	for _, l2BlockHashItem := range l2BlockHash {
		l2BlockHashRule = append(l2BlockHashRule, l2BlockHashItem)
	}

	logs, sub, err := _ERC20Outbox.contract.FilterLogs(opts, "SendRootUpdated", outputRootRule, l2BlockHashRule)
	if err != nil {
		return nil, err
	}
	return &ERC20OutboxSendRootUpdatedIterator{contract: _ERC20Outbox.contract, event: "SendRootUpdated", logs: logs, sub: sub}, nil
}

// WatchSendRootUpdated is a free log subscription operation binding the contract event 0xb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f6748.
//
// Solidity: event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash)
func (_ERC20Outbox *ERC20OutboxFilterer) WatchSendRootUpdated(opts *bind.WatchOpts, sink chan<- *ERC20OutboxSendRootUpdated, outputRoot [][32]byte, l2BlockHash [][32]byte) (event.Subscription, error) {

	var outputRootRule []interface{}
	for _, outputRootItem := range outputRoot {
		outputRootRule = append(outputRootRule, outputRootItem)
	}
	var l2BlockHashRule []interface{}
	for _, l2BlockHashItem := range l2BlockHash {
		l2BlockHashRule = append(l2BlockHashRule, l2BlockHashItem)
	}

	logs, sub, err := _ERC20Outbox.contract.WatchLogs(opts, "SendRootUpdated", outputRootRule, l2BlockHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ERC20OutboxSendRootUpdated)
				if err := _ERC20Outbox.contract.UnpackLog(event, "SendRootUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSendRootUpdated is a log parse operation binding the contract event 0xb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f6748.
//
// Solidity: event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash)
func (_ERC20Outbox *ERC20OutboxFilterer) ParseSendRootUpdated(log types.Log) (*ERC20OutboxSendRootUpdated, error) {
	event := new(ERC20OutboxSendRootUpdated)
	if err := _ERC20Outbox.contract.UnpackLog(event, "SendRootUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasRefunderMetaData contains all meta data concerning the GasRefunder contract.
var GasRefunderMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enumGasRefunder.CommonParameterKey\",\"name\":\"parameter\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"CommonParameterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"ContractAllowedSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"DisallowerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"refundee\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"enumGasRefunder.RefundDenyReason\",\"name\":\"reason\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"}],\"name\":\"RefundGasCostsDenied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"refundee\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gas\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPaid\",\"type\":\"uint256\"}],\"name\":\"RefundedGasCosts\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"RefundeeAllowedSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"allowContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"allowRefundees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedRefundees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commonParams\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"maxRefundeeBalance\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"extraGasMargin\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"calldataCost\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"maxGasTip\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxGasCost\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"maxSingleGasUsage\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"disallowContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"disallowRefundees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disallower\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"refundee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calldataSize\",\"type\":\"uint256\"}],\"name\":\"onGasSpent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newValue\",\"type\":\"uint8\"}],\"name\":\"setCalldataCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setDisallower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newValue\",\"type\":\"uint32\"}],\"name\":\"setExtraGasMargin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"newValue\",\"type\":\"uint64\"}],\"name\":\"setMaxGasCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"newValue\",\"type\":\"uint64\"}],\"name\":\"setMaxGasTip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"newValue\",\"type\":\"uint128\"}],\"name\":\"setMaxRefundeeBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newValue\",\"type\":\"uint32\"}],\"name\":\"setMaxSingleGasUsage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"destination\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]",
	Bin: "0x6080346100ff5760008054336001600160a01b0319821681178355906001600160a01b03167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08380a360c082016001600160401b038111838210176100eb576040908152908252610fa06020830152600c8183015263773594006060830152641bf08eb0006080830152621e848060a090920191909152600480546001600160e81b03191678773594000c00000fa000000000000000000000000000000000179055600580546001600160601b0319166a1e84800000001bf08eb00017905551610e5790816101058239f35b634e487b7160e01b82526041600452602482fd5b600080fdfe60406080815260048036101561004c575b50361561001c57600080fd5b807f2da466a7b24304f47e87fa2e1e5a81b9831ce54fec19055ce277ca2f39ba42c49151338152346020820152a1005b600090813560e01c806325416bc9146108ca5780632ccb03f21461086d578063500de4311461080357806351e0e26b146107c3578063715018a6146107785780637edddf451461071057806386b988951461069f5780638da5cb5b14610677578063a89d217314610637578063bffe1780146105d8578063ca10129514610561578063cd499da3146104d0578063d513894814610469578063e3db8a4914610432578063e52074531461039c578063efe12b0114610373578063f1e845ca14610309578063f2fde38b14610251578063f3fef3a3146101995763f52128eb146101355750610010565b918192346101955760203660031901126101955780356001600160801b0381169081900361019057600080516020610da2833981519152926020926101786109a7565b80546001600160801b0319168317905551908152a280f35b505050fd5b5050fd5b50823461024d578060031936011261024d576101b3610991565b90602435916101c06109a7565b6001600160a01b0316928480808086885af16101da610a9b565b5015610219575091606091837fd1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb9451923384526020840152820152a180f35b6020606492519162461bcd60e51b8352820152600f60248201526e15d2551211149055d7d19052531151608a1b6044820152fd5b8280fd5b50823461024d57602036600319011261024d576001600160a01b03823581811693919290849003610305576102846109a7565b83156102b357505082546001600160a01b031981168317845516600080516020610dc28339815191528380a380f35b906020608492519162461bcd60e51b8352820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152fd5b8480fd5b503461036f57602036600319011261036f57356001600160a01b0381169081900361036f576103366109a7565b600380546001600160a01b031916821790557fc388cec0895ad7ee4635898ec92207ca48d42256d4355f7042efef62c368a9798280a280f35b5080fd5b82843461036f578160031936011261036f5760035490516001600160a01b039091168152602090f35b82843461036f576103ac3661093f565b83549192916001600160a01b039190821633148015610425575b6103cf906109ff565b845b8181106103dc578580f35b8086846103f56103f061042095878b610a61565b610a87565b168082526002602052868220805460ff19169055600080516020610d828339815191528280a3610a3c565b6103d1565b50600354821633146103c6565b82843461036f57606036600319011261036f57602090610460610453610991565b6044359060243590610b28565b90519015158152f35b5082903461024d578260031936011261024d5760c092505460055482519260018060801b038316845263ffffffff92838160801c16602086015260ff8160a01c168286015260018060401b03809160a81c166060860152821660808501521c1660a0820152f35b82843461036f576104e03661093f565b83549192916001600160a01b039190821633148015610554575b610503906109ff565b845b818110610510578580f35b8086846105246103f061054f95878b610a61565b168082526001602052868220805460ff19169055600080516020610de28339815191528280a3610a3c565b610505565b50600354821633146104fa565b82843461036f576105713661093f565b919061057b6109a7565b835b838110610588578480f35b6105d3906001600160a01b036105a26103f0838887610a61565b168087526002602052848720906001918260ff19825416179055600080516020610d828339815191528880a3610a3c565b61057d565b5082903461024d57602036600319011261024d57803560ff811680820361030557600293600080516020610da2833981519152936020936106176109a7565b815460ff60a01b191660a09190911b60ff60a01b1617905551908152a280f35b5082903461024d57602036600319011261024d57356001600160a01b0381169081900361024d57818360ff92602095526002855220541690519015158152f35b82843461036f578160031936011261036f57905490516001600160a01b039091168152602090f35b5082903461024d57602036600319011261024d5780356001600160401b03811680820361030557600393600080516020610da2833981519152936020936106e46109a7565b8154600160a81b600160e81b03191660a89190911b600160a81b600160e81b031617905551908152a280f35b5082903461024d57602036600319011261024d57803563ffffffff811680820361030557600193600080516020610da2833981519152936020936107526109a7565b815463ffffffff60801b191660809190911b63ffffffff60801b1617905551908152a280f35b82346107c057806003193601126107c0576107916109a7565b80546001600160a01b03198116825581906001600160a01b0316600080516020610dc28339815191528280a380f35b80fd5b5082903461024d57602036600319011261024d57356001600160a01b0381169081900361024d57818360ff92602095526001855220541690519015158152f35b5082903461024d57602036600319011261024d57359063ffffffff82169182810361086957600592600080516020610da2833981519152926020926108466109a7565b855463ffffffff60401b191690821b63ffffffff60401b1617855551908152a280f35b8380fd5b50823461024d57602036600319011261024d5781356001600160401b038116919082900361086957600080516020610da2833981519152916020916108b06109a7565b600580546001600160401b0319168317905551908152a280f35b82843461036f576108da3661093f565b91906108e46109a7565b835b8381106108f1578480f35b61093a906001600160a01b0361090b6103f0838887610a61565b16808752600190816020528588208260ff19825416179055600080516020610de28339815191528880a3610a3c565b6108e6565b90602060031983011261098c576001600160401b03916004359083821161098c578060238301121561098c57816004013593841161098c5760248460051b8301011161098c576024019190565b600080fd5b600435906001600160a01b038216820361098c57565b6000546001600160a01b031633036109bb57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b15610a0657565b60405162461bcd60e51b815260206004820152600e60248201526d1393d517d055551213d49256915160921b6044820152606490fd5b6000198114610a4b5760010190565b634e487b7160e01b600052601160045260246000fd5b9190811015610a715760051b0190565b634e487b7160e01b600052603260045260246000fd5b356001600160a01b038116810361098c5790565b3d15610af6576001600160401b03903d828111610ae05760405192601f8201601f19908116603f0116840190811184821017610ae05760405282523d6000602084013e565b634e487b7160e01b600052604160045260246000fd5b606090565b91908201809211610a4b57565b81810292918115918404141715610a4b57565b91908203918211610a4b57565b909291925a9147928315610d4e576000338152600160205260409260ff848320541615610d1d576001600160a01b031680825260026020528382205490959060ff1615610cf957600454976001600160401b0395610b8c60a88b901c881648610afb565b998a3a10610cf1575b60055497881680151580610ce8575b610ce0575b50883192600160801b6001900382169663ffffffff809a8a1c16998360801c16610bd291610afb565b9160a01c60ff16610be291610b08565b610beb91610afb565b610bf491610afb565b5a610bfe91610b1b565b9580151580610cd7575b610ccf575b50610c18868a610b08565b9380151580610cbd575b610c85575b5050808311610c7d575b5080808084885af191610c42610a9b565b508296815194855260208501528301521515917fd0224505f828ccfcbc56ca0590d97442e239a7aa770f712948fd6388356b20de60603393a4565b915038610c31565b8181929394999a989796955011600014610ca3575050505050505090565b90610cb5919897929394959698610b1b565b913880610c27565b5080610cc98684610afb565b11610c22565b955038610c0d565b50808711610c08565b9a5038610ba9565b50808c11610ba4565b3a9a50610b95565b50949550509160019251918252600080516020610e0283398151915260203393a490565b925193845294955084935033926001600160a01b0390921691600080516020610e028339815191529150602090a490565b506040519182529293506003923392506001600160a01b031690600080516020610e0283398151915290602090a460009056fef544cca9d5484bfd447775bd759d12d53f1aa7c5f770be82c55070798ff9c63eda79b6b81f905f788560507c685a42d5a8ab209ee26538cbcf3ce3caed601f9b8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0b0918cd965657b8d231f8adba328fa810b6d61d800de9c795d40eb3623498c012b8ae00e22d9eaf5a92820a22b947c007aee773fa36502ad7a1c9a464ab4932ba2646970667358221220ec28796e35ccdce331f8303a2ff0d6fe55f2ca4a92e691f5a0b09224c8af6b4164736f6c63430008130033",
}

// GasRefunderABI is the input ABI used to generate the binding from.
// Deprecated: Use GasRefunderMetaData.ABI instead.
var GasRefunderABI = GasRefunderMetaData.ABI

// GasRefunderBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use GasRefunderMetaData.Bin instead.
var GasRefunderBin = GasRefunderMetaData.Bin

// DeployGasRefunder deploys a new Ethereum contract, binding an instance of GasRefunder to it.
func DeployGasRefunder(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *GasRefunder, error) {
	parsed, err := GasRefunderMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(GasRefunderBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &GasRefunder{GasRefunderCaller: GasRefunderCaller{contract: contract}, GasRefunderTransactor: GasRefunderTransactor{contract: contract}, GasRefunderFilterer: GasRefunderFilterer{contract: contract}}, nil
}

// GasRefunder is an auto generated Go binding around an Ethereum contract.
type GasRefunder struct {
	GasRefunderCaller     // Read-only binding to the contract
	GasRefunderTransactor // Write-only binding to the contract
	GasRefunderFilterer   // Log filterer for contract events
}

// GasRefunderCaller is an auto generated read-only Go binding around an Ethereum contract.
type GasRefunderCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// GasRefunderTransactor is an auto generated write-only Go binding around an Ethereum contract.
type GasRefunderTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// GasRefunderFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type GasRefunderFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// GasRefunderSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type GasRefunderSession struct {
	Contract     *GasRefunder      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// GasRefunderCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type GasRefunderCallerSession struct {
	Contract *GasRefunderCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// GasRefunderTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type GasRefunderTransactorSession struct {
	Contract     *GasRefunderTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// GasRefunderRaw is an auto generated low-level Go binding around an Ethereum contract.
type GasRefunderRaw struct {
	Contract *GasRefunder // Generic contract binding to access the raw methods on
}

// GasRefunderCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type GasRefunderCallerRaw struct {
	Contract *GasRefunderCaller // Generic read-only contract binding to access the raw methods on
}

// GasRefunderTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type GasRefunderTransactorRaw struct {
	Contract *GasRefunderTransactor // Generic write-only contract binding to access the raw methods on
}

// NewGasRefunder creates a new instance of GasRefunder, bound to a specific deployed contract.
func NewGasRefunder(address common.Address, backend bind.ContractBackend) (*GasRefunder, error) {
	contract, err := bindGasRefunder(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &GasRefunder{GasRefunderCaller: GasRefunderCaller{contract: contract}, GasRefunderTransactor: GasRefunderTransactor{contract: contract}, GasRefunderFilterer: GasRefunderFilterer{contract: contract}}, nil
}

// NewGasRefunderCaller creates a new read-only instance of GasRefunder, bound to a specific deployed contract.
func NewGasRefunderCaller(address common.Address, caller bind.ContractCaller) (*GasRefunderCaller, error) {
	contract, err := bindGasRefunder(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &GasRefunderCaller{contract: contract}, nil
}

// NewGasRefunderTransactor creates a new write-only instance of GasRefunder, bound to a specific deployed contract.
func NewGasRefunderTransactor(address common.Address, transactor bind.ContractTransactor) (*GasRefunderTransactor, error) {
	contract, err := bindGasRefunder(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &GasRefunderTransactor{contract: contract}, nil
}

// NewGasRefunderFilterer creates a new log filterer instance of GasRefunder, bound to a specific deployed contract.
func NewGasRefunderFilterer(address common.Address, filterer bind.ContractFilterer) (*GasRefunderFilterer, error) {
	contract, err := bindGasRefunder(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &GasRefunderFilterer{contract: contract}, nil
}

// bindGasRefunder binds a generic wrapper to an already deployed contract.
func bindGasRefunder(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := GasRefunderMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_GasRefunder *GasRefunderRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _GasRefunder.Contract.GasRefunderCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_GasRefunder *GasRefunderRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasRefunder.Contract.GasRefunderTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_GasRefunder *GasRefunderRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _GasRefunder.Contract.GasRefunderTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_GasRefunder *GasRefunderCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _GasRefunder.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_GasRefunder *GasRefunderTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasRefunder.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_GasRefunder *GasRefunderTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _GasRefunder.Contract.contract.Transact(opts, method, params...)
}

// AllowedContracts is a free data retrieval call binding the contract method 0x51e0e26b.
//
// Solidity: function allowedContracts(address ) view returns(bool)
func (_GasRefunder *GasRefunderCaller) AllowedContracts(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _GasRefunder.contract.Call(opts, &out, "allowedContracts", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedContracts is a free data retrieval call binding the contract method 0x51e0e26b.
//
// Solidity: function allowedContracts(address ) view returns(bool)
func (_GasRefunder *GasRefunderSession) AllowedContracts(arg0 common.Address) (bool, error) {
	return _GasRefunder.Contract.AllowedContracts(&_GasRefunder.CallOpts, arg0)
}

// AllowedContracts is a free data retrieval call binding the contract method 0x51e0e26b.
//
// Solidity: function allowedContracts(address ) view returns(bool)
func (_GasRefunder *GasRefunderCallerSession) AllowedContracts(arg0 common.Address) (bool, error) {
	return _GasRefunder.Contract.AllowedContracts(&_GasRefunder.CallOpts, arg0)
}

// AllowedRefundees is a free data retrieval call binding the contract method 0xa89d2173.
//
// Solidity: function allowedRefundees(address ) view returns(bool)
func (_GasRefunder *GasRefunderCaller) AllowedRefundees(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _GasRefunder.contract.Call(opts, &out, "allowedRefundees", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedRefundees is a free data retrieval call binding the contract method 0xa89d2173.
//
// Solidity: function allowedRefundees(address ) view returns(bool)
func (_GasRefunder *GasRefunderSession) AllowedRefundees(arg0 common.Address) (bool, error) {
	return _GasRefunder.Contract.AllowedRefundees(&_GasRefunder.CallOpts, arg0)
}

// AllowedRefundees is a free data retrieval call binding the contract method 0xa89d2173.
//
// Solidity: function allowedRefundees(address ) view returns(bool)
func (_GasRefunder *GasRefunderCallerSession) AllowedRefundees(arg0 common.Address) (bool, error) {
	return _GasRefunder.Contract.AllowedRefundees(&_GasRefunder.CallOpts, arg0)
}

// CommonParams is a free data retrieval call binding the contract method 0xd5138948.
//
// Solidity: function commonParams() view returns(uint128 maxRefundeeBalance, uint32 extraGasMargin, uint8 calldataCost, uint64 maxGasTip, uint64 maxGasCost, uint32 maxSingleGasUsage)
func (_GasRefunder *GasRefunderCaller) CommonParams(opts *bind.CallOpts) (struct {
	MaxRefundeeBalance *big.Int
	ExtraGasMargin     uint32
	CalldataCost       uint8
	MaxGasTip          uint64
	MaxGasCost         uint64
	MaxSingleGasUsage  uint32
}, error) {
	var out []interface{}
	err := _GasRefunder.contract.Call(opts, &out, "commonParams")

	outstruct := new(struct {
		MaxRefundeeBalance *big.Int
		ExtraGasMargin     uint32
		CalldataCost       uint8
		MaxGasTip          uint64
		MaxGasCost         uint64
		MaxSingleGasUsage  uint32
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.MaxRefundeeBalance = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.ExtraGasMargin = *abi.ConvertType(out[1], new(uint32)).(*uint32)
	outstruct.CalldataCost = *abi.ConvertType(out[2], new(uint8)).(*uint8)
	outstruct.MaxGasTip = *abi.ConvertType(out[3], new(uint64)).(*uint64)
	outstruct.MaxGasCost = *abi.ConvertType(out[4], new(uint64)).(*uint64)
	outstruct.MaxSingleGasUsage = *abi.ConvertType(out[5], new(uint32)).(*uint32)

	return *outstruct, err

}

// CommonParams is a free data retrieval call binding the contract method 0xd5138948.
//
// Solidity: function commonParams() view returns(uint128 maxRefundeeBalance, uint32 extraGasMargin, uint8 calldataCost, uint64 maxGasTip, uint64 maxGasCost, uint32 maxSingleGasUsage)
func (_GasRefunder *GasRefunderSession) CommonParams() (struct {
	MaxRefundeeBalance *big.Int
	ExtraGasMargin     uint32
	CalldataCost       uint8
	MaxGasTip          uint64
	MaxGasCost         uint64
	MaxSingleGasUsage  uint32
}, error) {
	return _GasRefunder.Contract.CommonParams(&_GasRefunder.CallOpts)
}

// CommonParams is a free data retrieval call binding the contract method 0xd5138948.
//
// Solidity: function commonParams() view returns(uint128 maxRefundeeBalance, uint32 extraGasMargin, uint8 calldataCost, uint64 maxGasTip, uint64 maxGasCost, uint32 maxSingleGasUsage)
func (_GasRefunder *GasRefunderCallerSession) CommonParams() (struct {
	MaxRefundeeBalance *big.Int
	ExtraGasMargin     uint32
	CalldataCost       uint8
	MaxGasTip          uint64
	MaxGasCost         uint64
	MaxSingleGasUsage  uint32
}, error) {
	return _GasRefunder.Contract.CommonParams(&_GasRefunder.CallOpts)
}

// Disallower is a free data retrieval call binding the contract method 0xefe12b01.
//
// Solidity: function disallower() view returns(address)
func (_GasRefunder *GasRefunderCaller) Disallower(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _GasRefunder.contract.Call(opts, &out, "disallower")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Disallower is a free data retrieval call binding the contract method 0xefe12b01.
//
// Solidity: function disallower() view returns(address)
func (_GasRefunder *GasRefunderSession) Disallower() (common.Address, error) {
	return _GasRefunder.Contract.Disallower(&_GasRefunder.CallOpts)
}

// Disallower is a free data retrieval call binding the contract method 0xefe12b01.
//
// Solidity: function disallower() view returns(address)
func (_GasRefunder *GasRefunderCallerSession) Disallower() (common.Address, error) {
	return _GasRefunder.Contract.Disallower(&_GasRefunder.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_GasRefunder *GasRefunderCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _GasRefunder.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_GasRefunder *GasRefunderSession) Owner() (common.Address, error) {
	return _GasRefunder.Contract.Owner(&_GasRefunder.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_GasRefunder *GasRefunderCallerSession) Owner() (common.Address, error) {
	return _GasRefunder.Contract.Owner(&_GasRefunder.CallOpts)
}

// AllowContracts is a paid mutator transaction binding the contract method 0x25416bc9.
//
// Solidity: function allowContracts(address[] addresses) returns()
func (_GasRefunder *GasRefunderTransactor) AllowContracts(opts *bind.TransactOpts, addresses []common.Address) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "allowContracts", addresses)
}

// AllowContracts is a paid mutator transaction binding the contract method 0x25416bc9.
//
// Solidity: function allowContracts(address[] addresses) returns()
func (_GasRefunder *GasRefunderSession) AllowContracts(addresses []common.Address) (*types.Transaction, error) {
	return _GasRefunder.Contract.AllowContracts(&_GasRefunder.TransactOpts, addresses)
}

// AllowContracts is a paid mutator transaction binding the contract method 0x25416bc9.
//
// Solidity: function allowContracts(address[] addresses) returns()
func (_GasRefunder *GasRefunderTransactorSession) AllowContracts(addresses []common.Address) (*types.Transaction, error) {
	return _GasRefunder.Contract.AllowContracts(&_GasRefunder.TransactOpts, addresses)
}

// AllowRefundees is a paid mutator transaction binding the contract method 0xca101295.
//
// Solidity: function allowRefundees(address[] addresses) returns()
func (_GasRefunder *GasRefunderTransactor) AllowRefundees(opts *bind.TransactOpts, addresses []common.Address) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "allowRefundees", addresses)
}

// AllowRefundees is a paid mutator transaction binding the contract method 0xca101295.
//
// Solidity: function allowRefundees(address[] addresses) returns()
func (_GasRefunder *GasRefunderSession) AllowRefundees(addresses []common.Address) (*types.Transaction, error) {
	return _GasRefunder.Contract.AllowRefundees(&_GasRefunder.TransactOpts, addresses)
}

// AllowRefundees is a paid mutator transaction binding the contract method 0xca101295.
//
// Solidity: function allowRefundees(address[] addresses) returns()
func (_GasRefunder *GasRefunderTransactorSession) AllowRefundees(addresses []common.Address) (*types.Transaction, error) {
	return _GasRefunder.Contract.AllowRefundees(&_GasRefunder.TransactOpts, addresses)
}

// DisallowContracts is a paid mutator transaction binding the contract method 0xcd499da3.
//
// Solidity: function disallowContracts(address[] addresses) returns()
func (_GasRefunder *GasRefunderTransactor) DisallowContracts(opts *bind.TransactOpts, addresses []common.Address) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "disallowContracts", addresses)
}

// DisallowContracts is a paid mutator transaction binding the contract method 0xcd499da3.
//
// Solidity: function disallowContracts(address[] addresses) returns()
func (_GasRefunder *GasRefunderSession) DisallowContracts(addresses []common.Address) (*types.Transaction, error) {
	return _GasRefunder.Contract.DisallowContracts(&_GasRefunder.TransactOpts, addresses)
}

// DisallowContracts is a paid mutator transaction binding the contract method 0xcd499da3.
//
// Solidity: function disallowContracts(address[] addresses) returns()
func (_GasRefunder *GasRefunderTransactorSession) DisallowContracts(addresses []common.Address) (*types.Transaction, error) {
	return _GasRefunder.Contract.DisallowContracts(&_GasRefunder.TransactOpts, addresses)
}

// DisallowRefundees is a paid mutator transaction binding the contract method 0xe5207453.
//
// Solidity: function disallowRefundees(address[] addresses) returns()
func (_GasRefunder *GasRefunderTransactor) DisallowRefundees(opts *bind.TransactOpts, addresses []common.Address) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "disallowRefundees", addresses)
}

// DisallowRefundees is a paid mutator transaction binding the contract method 0xe5207453.
//
// Solidity: function disallowRefundees(address[] addresses) returns()
func (_GasRefunder *GasRefunderSession) DisallowRefundees(addresses []common.Address) (*types.Transaction, error) {
	return _GasRefunder.Contract.DisallowRefundees(&_GasRefunder.TransactOpts, addresses)
}

// DisallowRefundees is a paid mutator transaction binding the contract method 0xe5207453.
//
// Solidity: function disallowRefundees(address[] addresses) returns()
func (_GasRefunder *GasRefunderTransactorSession) DisallowRefundees(addresses []common.Address) (*types.Transaction, error) {
	return _GasRefunder.Contract.DisallowRefundees(&_GasRefunder.TransactOpts, addresses)
}

// OnGasSpent is a paid mutator transaction binding the contract method 0xe3db8a49.
//
// Solidity: function onGasSpent(address refundee, uint256 gasUsed, uint256 calldataSize) returns(bool success)
func (_GasRefunder *GasRefunderTransactor) OnGasSpent(opts *bind.TransactOpts, refundee common.Address, gasUsed *big.Int, calldataSize *big.Int) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "onGasSpent", refundee, gasUsed, calldataSize)
}

// OnGasSpent is a paid mutator transaction binding the contract method 0xe3db8a49.
//
// Solidity: function onGasSpent(address refundee, uint256 gasUsed, uint256 calldataSize) returns(bool success)
func (_GasRefunder *GasRefunderSession) OnGasSpent(refundee common.Address, gasUsed *big.Int, calldataSize *big.Int) (*types.Transaction, error) {
	return _GasRefunder.Contract.OnGasSpent(&_GasRefunder.TransactOpts, refundee, gasUsed, calldataSize)
}

// OnGasSpent is a paid mutator transaction binding the contract method 0xe3db8a49.
//
// Solidity: function onGasSpent(address refundee, uint256 gasUsed, uint256 calldataSize) returns(bool success)
func (_GasRefunder *GasRefunderTransactorSession) OnGasSpent(refundee common.Address, gasUsed *big.Int, calldataSize *big.Int) (*types.Transaction, error) {
	return _GasRefunder.Contract.OnGasSpent(&_GasRefunder.TransactOpts, refundee, gasUsed, calldataSize)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_GasRefunder *GasRefunderTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_GasRefunder *GasRefunderSession) RenounceOwnership() (*types.Transaction, error) {
	return _GasRefunder.Contract.RenounceOwnership(&_GasRefunder.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_GasRefunder *GasRefunderTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _GasRefunder.Contract.RenounceOwnership(&_GasRefunder.TransactOpts)
}

// SetCalldataCost is a paid mutator transaction binding the contract method 0xbffe1780.
//
// Solidity: function setCalldataCost(uint8 newValue) returns()
func (_GasRefunder *GasRefunderTransactor) SetCalldataCost(opts *bind.TransactOpts, newValue uint8) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "setCalldataCost", newValue)
}

// SetCalldataCost is a paid mutator transaction binding the contract method 0xbffe1780.
//
// Solidity: function setCalldataCost(uint8 newValue) returns()
func (_GasRefunder *GasRefunderSession) SetCalldataCost(newValue uint8) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetCalldataCost(&_GasRefunder.TransactOpts, newValue)
}

// SetCalldataCost is a paid mutator transaction binding the contract method 0xbffe1780.
//
// Solidity: function setCalldataCost(uint8 newValue) returns()
func (_GasRefunder *GasRefunderTransactorSession) SetCalldataCost(newValue uint8) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetCalldataCost(&_GasRefunder.TransactOpts, newValue)
}

// SetDisallower is a paid mutator transaction binding the contract method 0xf1e845ca.
//
// Solidity: function setDisallower(address addr) returns()
func (_GasRefunder *GasRefunderTransactor) SetDisallower(opts *bind.TransactOpts, addr common.Address) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "setDisallower", addr)
}

// SetDisallower is a paid mutator transaction binding the contract method 0xf1e845ca.
//
// Solidity: function setDisallower(address addr) returns()
func (_GasRefunder *GasRefunderSession) SetDisallower(addr common.Address) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetDisallower(&_GasRefunder.TransactOpts, addr)
}

// SetDisallower is a paid mutator transaction binding the contract method 0xf1e845ca.
//
// Solidity: function setDisallower(address addr) returns()
func (_GasRefunder *GasRefunderTransactorSession) SetDisallower(addr common.Address) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetDisallower(&_GasRefunder.TransactOpts, addr)
}

// SetExtraGasMargin is a paid mutator transaction binding the contract method 0x7edddf45.
//
// Solidity: function setExtraGasMargin(uint32 newValue) returns()
func (_GasRefunder *GasRefunderTransactor) SetExtraGasMargin(opts *bind.TransactOpts, newValue uint32) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "setExtraGasMargin", newValue)
}

// SetExtraGasMargin is a paid mutator transaction binding the contract method 0x7edddf45.
//
// Solidity: function setExtraGasMargin(uint32 newValue) returns()
func (_GasRefunder *GasRefunderSession) SetExtraGasMargin(newValue uint32) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetExtraGasMargin(&_GasRefunder.TransactOpts, newValue)
}

// SetExtraGasMargin is a paid mutator transaction binding the contract method 0x7edddf45.
//
// Solidity: function setExtraGasMargin(uint32 newValue) returns()
func (_GasRefunder *GasRefunderTransactorSession) SetExtraGasMargin(newValue uint32) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetExtraGasMargin(&_GasRefunder.TransactOpts, newValue)
}

// SetMaxGasCost is a paid mutator transaction binding the contract method 0x2ccb03f2.
//
// Solidity: function setMaxGasCost(uint64 newValue) returns()
func (_GasRefunder *GasRefunderTransactor) SetMaxGasCost(opts *bind.TransactOpts, newValue uint64) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "setMaxGasCost", newValue)
}

// SetMaxGasCost is a paid mutator transaction binding the contract method 0x2ccb03f2.
//
// Solidity: function setMaxGasCost(uint64 newValue) returns()
func (_GasRefunder *GasRefunderSession) SetMaxGasCost(newValue uint64) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetMaxGasCost(&_GasRefunder.TransactOpts, newValue)
}

// SetMaxGasCost is a paid mutator transaction binding the contract method 0x2ccb03f2.
//
// Solidity: function setMaxGasCost(uint64 newValue) returns()
func (_GasRefunder *GasRefunderTransactorSession) SetMaxGasCost(newValue uint64) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetMaxGasCost(&_GasRefunder.TransactOpts, newValue)
}

// SetMaxGasTip is a paid mutator transaction binding the contract method 0x86b98895.
//
// Solidity: function setMaxGasTip(uint64 newValue) returns()
func (_GasRefunder *GasRefunderTransactor) SetMaxGasTip(opts *bind.TransactOpts, newValue uint64) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "setMaxGasTip", newValue)
}

// SetMaxGasTip is a paid mutator transaction binding the contract method 0x86b98895.
//
// Solidity: function setMaxGasTip(uint64 newValue) returns()
func (_GasRefunder *GasRefunderSession) SetMaxGasTip(newValue uint64) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetMaxGasTip(&_GasRefunder.TransactOpts, newValue)
}

// SetMaxGasTip is a paid mutator transaction binding the contract method 0x86b98895.
//
// Solidity: function setMaxGasTip(uint64 newValue) returns()
func (_GasRefunder *GasRefunderTransactorSession) SetMaxGasTip(newValue uint64) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetMaxGasTip(&_GasRefunder.TransactOpts, newValue)
}

// SetMaxRefundeeBalance is a paid mutator transaction binding the contract method 0xf52128eb.
//
// Solidity: function setMaxRefundeeBalance(uint128 newValue) returns()
func (_GasRefunder *GasRefunderTransactor) SetMaxRefundeeBalance(opts *bind.TransactOpts, newValue *big.Int) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "setMaxRefundeeBalance", newValue)
}

// SetMaxRefundeeBalance is a paid mutator transaction binding the contract method 0xf52128eb.
//
// Solidity: function setMaxRefundeeBalance(uint128 newValue) returns()
func (_GasRefunder *GasRefunderSession) SetMaxRefundeeBalance(newValue *big.Int) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetMaxRefundeeBalance(&_GasRefunder.TransactOpts, newValue)
}

// SetMaxRefundeeBalance is a paid mutator transaction binding the contract method 0xf52128eb.
//
// Solidity: function setMaxRefundeeBalance(uint128 newValue) returns()
func (_GasRefunder *GasRefunderTransactorSession) SetMaxRefundeeBalance(newValue *big.Int) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetMaxRefundeeBalance(&_GasRefunder.TransactOpts, newValue)
}

// SetMaxSingleGasUsage is a paid mutator transaction binding the contract method 0x500de431.
//
// Solidity: function setMaxSingleGasUsage(uint32 newValue) returns()
func (_GasRefunder *GasRefunderTransactor) SetMaxSingleGasUsage(opts *bind.TransactOpts, newValue uint32) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "setMaxSingleGasUsage", newValue)
}

// SetMaxSingleGasUsage is a paid mutator transaction binding the contract method 0x500de431.
//
// Solidity: function setMaxSingleGasUsage(uint32 newValue) returns()
func (_GasRefunder *GasRefunderSession) SetMaxSingleGasUsage(newValue uint32) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetMaxSingleGasUsage(&_GasRefunder.TransactOpts, newValue)
}

// SetMaxSingleGasUsage is a paid mutator transaction binding the contract method 0x500de431.
//
// Solidity: function setMaxSingleGasUsage(uint32 newValue) returns()
func (_GasRefunder *GasRefunderTransactorSession) SetMaxSingleGasUsage(newValue uint32) (*types.Transaction, error) {
	return _GasRefunder.Contract.SetMaxSingleGasUsage(&_GasRefunder.TransactOpts, newValue)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_GasRefunder *GasRefunderTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_GasRefunder *GasRefunderSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _GasRefunder.Contract.TransferOwnership(&_GasRefunder.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_GasRefunder *GasRefunderTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _GasRefunder.Contract.TransferOwnership(&_GasRefunder.TransactOpts, newOwner)
}

// Withdraw is a paid mutator transaction binding the contract method 0xf3fef3a3.
//
// Solidity: function withdraw(address destination, uint256 amount) returns()
func (_GasRefunder *GasRefunderTransactor) Withdraw(opts *bind.TransactOpts, destination common.Address, amount *big.Int) (*types.Transaction, error) {
	return _GasRefunder.contract.Transact(opts, "withdraw", destination, amount)
}

// Withdraw is a paid mutator transaction binding the contract method 0xf3fef3a3.
//
// Solidity: function withdraw(address destination, uint256 amount) returns()
func (_GasRefunder *GasRefunderSession) Withdraw(destination common.Address, amount *big.Int) (*types.Transaction, error) {
	return _GasRefunder.Contract.Withdraw(&_GasRefunder.TransactOpts, destination, amount)
}

// Withdraw is a paid mutator transaction binding the contract method 0xf3fef3a3.
//
// Solidity: function withdraw(address destination, uint256 amount) returns()
func (_GasRefunder *GasRefunderTransactorSession) Withdraw(destination common.Address, amount *big.Int) (*types.Transaction, error) {
	return _GasRefunder.Contract.Withdraw(&_GasRefunder.TransactOpts, destination, amount)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_GasRefunder *GasRefunderTransactor) Receive(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _GasRefunder.contract.RawTransact(opts, nil) // calldata is disallowed for receive function
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_GasRefunder *GasRefunderSession) Receive() (*types.Transaction, error) {
	return _GasRefunder.Contract.Receive(&_GasRefunder.TransactOpts)
}

// Receive is a paid mutator transaction binding the contract receive function.
//
// Solidity: receive() payable returns()
func (_GasRefunder *GasRefunderTransactorSession) Receive() (*types.Transaction, error) {
	return _GasRefunder.Contract.Receive(&_GasRefunder.TransactOpts)
}

// GasRefunderCommonParameterSetIterator is returned from FilterCommonParameterSet and is used to iterate over the raw logs and unpacked data for CommonParameterSet events raised by the GasRefunder contract.
type GasRefunderCommonParameterSetIterator struct {
	Event *GasRefunderCommonParameterSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasRefunderCommonParameterSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasRefunderCommonParameterSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasRefunderCommonParameterSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasRefunderCommonParameterSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasRefunderCommonParameterSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasRefunderCommonParameterSet represents a CommonParameterSet event raised by the GasRefunder contract.
type GasRefunderCommonParameterSet struct {
	Parameter uint8
	Value     *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterCommonParameterSet is a free log retrieval operation binding the contract event 0xda79b6b81f905f788560507c685a42d5a8ab209ee26538cbcf3ce3caed601f9b.
//
// Solidity: event CommonParameterSet(uint8 indexed parameter, uint256 value)
func (_GasRefunder *GasRefunderFilterer) FilterCommonParameterSet(opts *bind.FilterOpts, parameter []uint8) (*GasRefunderCommonParameterSetIterator, error) {

	var parameterRule []interface{}
	for _, parameterItem := range parameter {
		parameterRule = append(parameterRule, parameterItem)
	}

	logs, sub, err := _GasRefunder.contract.FilterLogs(opts, "CommonParameterSet", parameterRule)
	if err != nil {
		return nil, err
	}
	return &GasRefunderCommonParameterSetIterator{contract: _GasRefunder.contract, event: "CommonParameterSet", logs: logs, sub: sub}, nil
}

// WatchCommonParameterSet is a free log subscription operation binding the contract event 0xda79b6b81f905f788560507c685a42d5a8ab209ee26538cbcf3ce3caed601f9b.
//
// Solidity: event CommonParameterSet(uint8 indexed parameter, uint256 value)
func (_GasRefunder *GasRefunderFilterer) WatchCommonParameterSet(opts *bind.WatchOpts, sink chan<- *GasRefunderCommonParameterSet, parameter []uint8) (event.Subscription, error) {

	var parameterRule []interface{}
	for _, parameterItem := range parameter {
		parameterRule = append(parameterRule, parameterItem)
	}

	logs, sub, err := _GasRefunder.contract.WatchLogs(opts, "CommonParameterSet", parameterRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasRefunderCommonParameterSet)
				if err := _GasRefunder.contract.UnpackLog(event, "CommonParameterSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCommonParameterSet is a log parse operation binding the contract event 0xda79b6b81f905f788560507c685a42d5a8ab209ee26538cbcf3ce3caed601f9b.
//
// Solidity: event CommonParameterSet(uint8 indexed parameter, uint256 value)
func (_GasRefunder *GasRefunderFilterer) ParseCommonParameterSet(log types.Log) (*GasRefunderCommonParameterSet, error) {
	event := new(GasRefunderCommonParameterSet)
	if err := _GasRefunder.contract.UnpackLog(event, "CommonParameterSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasRefunderContractAllowedSetIterator is returned from FilterContractAllowedSet and is used to iterate over the raw logs and unpacked data for ContractAllowedSet events raised by the GasRefunder contract.
type GasRefunderContractAllowedSetIterator struct {
	Event *GasRefunderContractAllowedSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasRefunderContractAllowedSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasRefunderContractAllowedSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasRefunderContractAllowedSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasRefunderContractAllowedSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasRefunderContractAllowedSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasRefunderContractAllowedSet represents a ContractAllowedSet event raised by the GasRefunder contract.
type GasRefunderContractAllowedSet struct {
	Addr    common.Address
	Allowed bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterContractAllowedSet is a free log retrieval operation binding the contract event 0xb0918cd965657b8d231f8adba328fa810b6d61d800de9c795d40eb3623498c01.
//
// Solidity: event ContractAllowedSet(address indexed addr, bool indexed allowed)
func (_GasRefunder *GasRefunderFilterer) FilterContractAllowedSet(opts *bind.FilterOpts, addr []common.Address, allowed []bool) (*GasRefunderContractAllowedSetIterator, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}
	var allowedRule []interface{}
	for _, allowedItem := range allowed {
		allowedRule = append(allowedRule, allowedItem)
	}

	logs, sub, err := _GasRefunder.contract.FilterLogs(opts, "ContractAllowedSet", addrRule, allowedRule)
	if err != nil {
		return nil, err
	}
	return &GasRefunderContractAllowedSetIterator{contract: _GasRefunder.contract, event: "ContractAllowedSet", logs: logs, sub: sub}, nil
}

// WatchContractAllowedSet is a free log subscription operation binding the contract event 0xb0918cd965657b8d231f8adba328fa810b6d61d800de9c795d40eb3623498c01.
//
// Solidity: event ContractAllowedSet(address indexed addr, bool indexed allowed)
func (_GasRefunder *GasRefunderFilterer) WatchContractAllowedSet(opts *bind.WatchOpts, sink chan<- *GasRefunderContractAllowedSet, addr []common.Address, allowed []bool) (event.Subscription, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}
	var allowedRule []interface{}
	for _, allowedItem := range allowed {
		allowedRule = append(allowedRule, allowedItem)
	}

	logs, sub, err := _GasRefunder.contract.WatchLogs(opts, "ContractAllowedSet", addrRule, allowedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasRefunderContractAllowedSet)
				if err := _GasRefunder.contract.UnpackLog(event, "ContractAllowedSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseContractAllowedSet is a log parse operation binding the contract event 0xb0918cd965657b8d231f8adba328fa810b6d61d800de9c795d40eb3623498c01.
//
// Solidity: event ContractAllowedSet(address indexed addr, bool indexed allowed)
func (_GasRefunder *GasRefunderFilterer) ParseContractAllowedSet(log types.Log) (*GasRefunderContractAllowedSet, error) {
	event := new(GasRefunderContractAllowedSet)
	if err := _GasRefunder.contract.UnpackLog(event, "ContractAllowedSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasRefunderDepositedIterator is returned from FilterDeposited and is used to iterate over the raw logs and unpacked data for Deposited events raised by the GasRefunder contract.
type GasRefunderDepositedIterator struct {
	Event *GasRefunderDeposited // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasRefunderDepositedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasRefunderDeposited)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasRefunderDeposited)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasRefunderDepositedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasRefunderDepositedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasRefunderDeposited represents a Deposited event raised by the GasRefunder contract.
type GasRefunderDeposited struct {
	Sender common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterDeposited is a free log retrieval operation binding the contract event 0x2da466a7b24304f47e87fa2e1e5a81b9831ce54fec19055ce277ca2f39ba42c4.
//
// Solidity: event Deposited(address sender, uint256 amount)
func (_GasRefunder *GasRefunderFilterer) FilterDeposited(opts *bind.FilterOpts) (*GasRefunderDepositedIterator, error) {

	logs, sub, err := _GasRefunder.contract.FilterLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return &GasRefunderDepositedIterator{contract: _GasRefunder.contract, event: "Deposited", logs: logs, sub: sub}, nil
}

// WatchDeposited is a free log subscription operation binding the contract event 0x2da466a7b24304f47e87fa2e1e5a81b9831ce54fec19055ce277ca2f39ba42c4.
//
// Solidity: event Deposited(address sender, uint256 amount)
func (_GasRefunder *GasRefunderFilterer) WatchDeposited(opts *bind.WatchOpts, sink chan<- *GasRefunderDeposited) (event.Subscription, error) {

	logs, sub, err := _GasRefunder.contract.WatchLogs(opts, "Deposited")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasRefunderDeposited)
				if err := _GasRefunder.contract.UnpackLog(event, "Deposited", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDeposited is a log parse operation binding the contract event 0x2da466a7b24304f47e87fa2e1e5a81b9831ce54fec19055ce277ca2f39ba42c4.
//
// Solidity: event Deposited(address sender, uint256 amount)
func (_GasRefunder *GasRefunderFilterer) ParseDeposited(log types.Log) (*GasRefunderDeposited, error) {
	event := new(GasRefunderDeposited)
	if err := _GasRefunder.contract.UnpackLog(event, "Deposited", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasRefunderDisallowerSetIterator is returned from FilterDisallowerSet and is used to iterate over the raw logs and unpacked data for DisallowerSet events raised by the GasRefunder contract.
type GasRefunderDisallowerSetIterator struct {
	Event *GasRefunderDisallowerSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasRefunderDisallowerSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasRefunderDisallowerSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasRefunderDisallowerSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasRefunderDisallowerSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasRefunderDisallowerSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasRefunderDisallowerSet represents a DisallowerSet event raised by the GasRefunder contract.
type GasRefunderDisallowerSet struct {
	Addr common.Address
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterDisallowerSet is a free log retrieval operation binding the contract event 0xc388cec0895ad7ee4635898ec92207ca48d42256d4355f7042efef62c368a979.
//
// Solidity: event DisallowerSet(address indexed addr)
func (_GasRefunder *GasRefunderFilterer) FilterDisallowerSet(opts *bind.FilterOpts, addr []common.Address) (*GasRefunderDisallowerSetIterator, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}

	logs, sub, err := _GasRefunder.contract.FilterLogs(opts, "DisallowerSet", addrRule)
	if err != nil {
		return nil, err
	}
	return &GasRefunderDisallowerSetIterator{contract: _GasRefunder.contract, event: "DisallowerSet", logs: logs, sub: sub}, nil
}

// WatchDisallowerSet is a free log subscription operation binding the contract event 0xc388cec0895ad7ee4635898ec92207ca48d42256d4355f7042efef62c368a979.
//
// Solidity: event DisallowerSet(address indexed addr)
func (_GasRefunder *GasRefunderFilterer) WatchDisallowerSet(opts *bind.WatchOpts, sink chan<- *GasRefunderDisallowerSet, addr []common.Address) (event.Subscription, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}

	logs, sub, err := _GasRefunder.contract.WatchLogs(opts, "DisallowerSet", addrRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasRefunderDisallowerSet)
				if err := _GasRefunder.contract.UnpackLog(event, "DisallowerSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDisallowerSet is a log parse operation binding the contract event 0xc388cec0895ad7ee4635898ec92207ca48d42256d4355f7042efef62c368a979.
//
// Solidity: event DisallowerSet(address indexed addr)
func (_GasRefunder *GasRefunderFilterer) ParseDisallowerSet(log types.Log) (*GasRefunderDisallowerSet, error) {
	event := new(GasRefunderDisallowerSet)
	if err := _GasRefunder.contract.UnpackLog(event, "DisallowerSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasRefunderOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the GasRefunder contract.
type GasRefunderOwnershipTransferredIterator struct {
	Event *GasRefunderOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasRefunderOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasRefunderOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasRefunderOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasRefunderOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasRefunderOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasRefunderOwnershipTransferred represents a OwnershipTransferred event raised by the GasRefunder contract.
type GasRefunderOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_GasRefunder *GasRefunderFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*GasRefunderOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _GasRefunder.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &GasRefunderOwnershipTransferredIterator{contract: _GasRefunder.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_GasRefunder *GasRefunderFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *GasRefunderOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _GasRefunder.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasRefunderOwnershipTransferred)
				if err := _GasRefunder.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_GasRefunder *GasRefunderFilterer) ParseOwnershipTransferred(log types.Log) (*GasRefunderOwnershipTransferred, error) {
	event := new(GasRefunderOwnershipTransferred)
	if err := _GasRefunder.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasRefunderRefundGasCostsDeniedIterator is returned from FilterRefundGasCostsDenied and is used to iterate over the raw logs and unpacked data for RefundGasCostsDenied events raised by the GasRefunder contract.
type GasRefunderRefundGasCostsDeniedIterator struct {
	Event *GasRefunderRefundGasCostsDenied // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasRefunderRefundGasCostsDeniedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasRefunderRefundGasCostsDenied)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasRefunderRefundGasCostsDenied)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasRefunderRefundGasCostsDeniedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasRefunderRefundGasCostsDeniedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasRefunderRefundGasCostsDenied represents a RefundGasCostsDenied event raised by the GasRefunder contract.
type GasRefunderRefundGasCostsDenied struct {
	Refundee        common.Address
	ContractAddress common.Address
	Reason          uint8
	Gas             *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterRefundGasCostsDenied is a free log retrieval operation binding the contract event 0x2b8ae00e22d9eaf5a92820a22b947c007aee773fa36502ad7a1c9a464ab4932b.
//
// Solidity: event RefundGasCostsDenied(address indexed refundee, address indexed contractAddress, uint8 indexed reason, uint256 gas)
func (_GasRefunder *GasRefunderFilterer) FilterRefundGasCostsDenied(opts *bind.FilterOpts, refundee []common.Address, contractAddress []common.Address, reason []uint8) (*GasRefunderRefundGasCostsDeniedIterator, error) {

	var refundeeRule []interface{}
	for _, refundeeItem := range refundee {
		refundeeRule = append(refundeeRule, refundeeItem)
	}
	var contractAddressRule []interface{}
	for _, contractAddressItem := range contractAddress {
		contractAddressRule = append(contractAddressRule, contractAddressItem)
	}
	var reasonRule []interface{}
	for _, reasonItem := range reason {
		reasonRule = append(reasonRule, reasonItem)
	}

	logs, sub, err := _GasRefunder.contract.FilterLogs(opts, "RefundGasCostsDenied", refundeeRule, contractAddressRule, reasonRule)
	if err != nil {
		return nil, err
	}
	return &GasRefunderRefundGasCostsDeniedIterator{contract: _GasRefunder.contract, event: "RefundGasCostsDenied", logs: logs, sub: sub}, nil
}

// WatchRefundGasCostsDenied is a free log subscription operation binding the contract event 0x2b8ae00e22d9eaf5a92820a22b947c007aee773fa36502ad7a1c9a464ab4932b.
//
// Solidity: event RefundGasCostsDenied(address indexed refundee, address indexed contractAddress, uint8 indexed reason, uint256 gas)
func (_GasRefunder *GasRefunderFilterer) WatchRefundGasCostsDenied(opts *bind.WatchOpts, sink chan<- *GasRefunderRefundGasCostsDenied, refundee []common.Address, contractAddress []common.Address, reason []uint8) (event.Subscription, error) {

	var refundeeRule []interface{}
	for _, refundeeItem := range refundee {
		refundeeRule = append(refundeeRule, refundeeItem)
	}
	var contractAddressRule []interface{}
	for _, contractAddressItem := range contractAddress {
		contractAddressRule = append(contractAddressRule, contractAddressItem)
	}
	var reasonRule []interface{}
	for _, reasonItem := range reason {
		reasonRule = append(reasonRule, reasonItem)
	}

	logs, sub, err := _GasRefunder.contract.WatchLogs(opts, "RefundGasCostsDenied", refundeeRule, contractAddressRule, reasonRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasRefunderRefundGasCostsDenied)
				if err := _GasRefunder.contract.UnpackLog(event, "RefundGasCostsDenied", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRefundGasCostsDenied is a log parse operation binding the contract event 0x2b8ae00e22d9eaf5a92820a22b947c007aee773fa36502ad7a1c9a464ab4932b.
//
// Solidity: event RefundGasCostsDenied(address indexed refundee, address indexed contractAddress, uint8 indexed reason, uint256 gas)
func (_GasRefunder *GasRefunderFilterer) ParseRefundGasCostsDenied(log types.Log) (*GasRefunderRefundGasCostsDenied, error) {
	event := new(GasRefunderRefundGasCostsDenied)
	if err := _GasRefunder.contract.UnpackLog(event, "RefundGasCostsDenied", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasRefunderRefundedGasCostsIterator is returned from FilterRefundedGasCosts and is used to iterate over the raw logs and unpacked data for RefundedGasCosts events raised by the GasRefunder contract.
type GasRefunderRefundedGasCostsIterator struct {
	Event *GasRefunderRefundedGasCosts // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasRefunderRefundedGasCostsIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasRefunderRefundedGasCosts)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasRefunderRefundedGasCosts)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasRefunderRefundedGasCostsIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasRefunderRefundedGasCostsIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasRefunderRefundedGasCosts represents a RefundedGasCosts event raised by the GasRefunder contract.
type GasRefunderRefundedGasCosts struct {
	Refundee        common.Address
	ContractAddress common.Address
	Success         bool
	Gas             *big.Int
	GasPrice        *big.Int
	AmountPaid      *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterRefundedGasCosts is a free log retrieval operation binding the contract event 0xd0224505f828ccfcbc56ca0590d97442e239a7aa770f712948fd6388356b20de.
//
// Solidity: event RefundedGasCosts(address indexed refundee, address indexed contractAddress, bool indexed success, uint256 gas, uint256 gasPrice, uint256 amountPaid)
func (_GasRefunder *GasRefunderFilterer) FilterRefundedGasCosts(opts *bind.FilterOpts, refundee []common.Address, contractAddress []common.Address, success []bool) (*GasRefunderRefundedGasCostsIterator, error) {

	var refundeeRule []interface{}
	for _, refundeeItem := range refundee {
		refundeeRule = append(refundeeRule, refundeeItem)
	}
	var contractAddressRule []interface{}
	for _, contractAddressItem := range contractAddress {
		contractAddressRule = append(contractAddressRule, contractAddressItem)
	}
	var successRule []interface{}
	for _, successItem := range success {
		successRule = append(successRule, successItem)
	}

	logs, sub, err := _GasRefunder.contract.FilterLogs(opts, "RefundedGasCosts", refundeeRule, contractAddressRule, successRule)
	if err != nil {
		return nil, err
	}
	return &GasRefunderRefundedGasCostsIterator{contract: _GasRefunder.contract, event: "RefundedGasCosts", logs: logs, sub: sub}, nil
}

// WatchRefundedGasCosts is a free log subscription operation binding the contract event 0xd0224505f828ccfcbc56ca0590d97442e239a7aa770f712948fd6388356b20de.
//
// Solidity: event RefundedGasCosts(address indexed refundee, address indexed contractAddress, bool indexed success, uint256 gas, uint256 gasPrice, uint256 amountPaid)
func (_GasRefunder *GasRefunderFilterer) WatchRefundedGasCosts(opts *bind.WatchOpts, sink chan<- *GasRefunderRefundedGasCosts, refundee []common.Address, contractAddress []common.Address, success []bool) (event.Subscription, error) {

	var refundeeRule []interface{}
	for _, refundeeItem := range refundee {
		refundeeRule = append(refundeeRule, refundeeItem)
	}
	var contractAddressRule []interface{}
	for _, contractAddressItem := range contractAddress {
		contractAddressRule = append(contractAddressRule, contractAddressItem)
	}
	var successRule []interface{}
	for _, successItem := range success {
		successRule = append(successRule, successItem)
	}

	logs, sub, err := _GasRefunder.contract.WatchLogs(opts, "RefundedGasCosts", refundeeRule, contractAddressRule, successRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasRefunderRefundedGasCosts)
				if err := _GasRefunder.contract.UnpackLog(event, "RefundedGasCosts", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRefundedGasCosts is a log parse operation binding the contract event 0xd0224505f828ccfcbc56ca0590d97442e239a7aa770f712948fd6388356b20de.
//
// Solidity: event RefundedGasCosts(address indexed refundee, address indexed contractAddress, bool indexed success, uint256 gas, uint256 gasPrice, uint256 amountPaid)
func (_GasRefunder *GasRefunderFilterer) ParseRefundedGasCosts(log types.Log) (*GasRefunderRefundedGasCosts, error) {
	event := new(GasRefunderRefundedGasCosts)
	if err := _GasRefunder.contract.UnpackLog(event, "RefundedGasCosts", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasRefunderRefundeeAllowedSetIterator is returned from FilterRefundeeAllowedSet and is used to iterate over the raw logs and unpacked data for RefundeeAllowedSet events raised by the GasRefunder contract.
type GasRefunderRefundeeAllowedSetIterator struct {
	Event *GasRefunderRefundeeAllowedSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasRefunderRefundeeAllowedSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasRefunderRefundeeAllowedSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasRefunderRefundeeAllowedSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasRefunderRefundeeAllowedSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasRefunderRefundeeAllowedSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasRefunderRefundeeAllowedSet represents a RefundeeAllowedSet event raised by the GasRefunder contract.
type GasRefunderRefundeeAllowedSet struct {
	Addr    common.Address
	Allowed bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterRefundeeAllowedSet is a free log retrieval operation binding the contract event 0xf544cca9d5484bfd447775bd759d12d53f1aa7c5f770be82c55070798ff9c63e.
//
// Solidity: event RefundeeAllowedSet(address indexed addr, bool indexed allowed)
func (_GasRefunder *GasRefunderFilterer) FilterRefundeeAllowedSet(opts *bind.FilterOpts, addr []common.Address, allowed []bool) (*GasRefunderRefundeeAllowedSetIterator, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}
	var allowedRule []interface{}
	for _, allowedItem := range allowed {
		allowedRule = append(allowedRule, allowedItem)
	}

	logs, sub, err := _GasRefunder.contract.FilterLogs(opts, "RefundeeAllowedSet", addrRule, allowedRule)
	if err != nil {
		return nil, err
	}
	return &GasRefunderRefundeeAllowedSetIterator{contract: _GasRefunder.contract, event: "RefundeeAllowedSet", logs: logs, sub: sub}, nil
}

// WatchRefundeeAllowedSet is a free log subscription operation binding the contract event 0xf544cca9d5484bfd447775bd759d12d53f1aa7c5f770be82c55070798ff9c63e.
//
// Solidity: event RefundeeAllowedSet(address indexed addr, bool indexed allowed)
func (_GasRefunder *GasRefunderFilterer) WatchRefundeeAllowedSet(opts *bind.WatchOpts, sink chan<- *GasRefunderRefundeeAllowedSet, addr []common.Address, allowed []bool) (event.Subscription, error) {

	var addrRule []interface{}
	for _, addrItem := range addr {
		addrRule = append(addrRule, addrItem)
	}
	var allowedRule []interface{}
	for _, allowedItem := range allowed {
		allowedRule = append(allowedRule, allowedItem)
	}

	logs, sub, err := _GasRefunder.contract.WatchLogs(opts, "RefundeeAllowedSet", addrRule, allowedRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasRefunderRefundeeAllowedSet)
				if err := _GasRefunder.contract.UnpackLog(event, "RefundeeAllowedSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRefundeeAllowedSet is a log parse operation binding the contract event 0xf544cca9d5484bfd447775bd759d12d53f1aa7c5f770be82c55070798ff9c63e.
//
// Solidity: event RefundeeAllowedSet(address indexed addr, bool indexed allowed)
func (_GasRefunder *GasRefunderFilterer) ParseRefundeeAllowedSet(log types.Log) (*GasRefunderRefundeeAllowedSet, error) {
	event := new(GasRefunderRefundeeAllowedSet)
	if err := _GasRefunder.contract.UnpackLog(event, "RefundeeAllowedSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// GasRefunderWithdrawnIterator is returned from FilterWithdrawn and is used to iterate over the raw logs and unpacked data for Withdrawn events raised by the GasRefunder contract.
type GasRefunderWithdrawnIterator struct {
	Event *GasRefunderWithdrawn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *GasRefunderWithdrawnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(GasRefunderWithdrawn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(GasRefunderWithdrawn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *GasRefunderWithdrawnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *GasRefunderWithdrawnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// GasRefunderWithdrawn represents a Withdrawn event raised by the GasRefunder contract.
type GasRefunderWithdrawn struct {
	Initiator   common.Address
	Destination common.Address
	Amount      *big.Int
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterWithdrawn is a free log retrieval operation binding the contract event 0xd1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb.
//
// Solidity: event Withdrawn(address initiator, address destination, uint256 amount)
func (_GasRefunder *GasRefunderFilterer) FilterWithdrawn(opts *bind.FilterOpts) (*GasRefunderWithdrawnIterator, error) {

	logs, sub, err := _GasRefunder.contract.FilterLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return &GasRefunderWithdrawnIterator{contract: _GasRefunder.contract, event: "Withdrawn", logs: logs, sub: sub}, nil
}

// WatchWithdrawn is a free log subscription operation binding the contract event 0xd1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb.
//
// Solidity: event Withdrawn(address initiator, address destination, uint256 amount)
func (_GasRefunder *GasRefunderFilterer) WatchWithdrawn(opts *bind.WatchOpts, sink chan<- *GasRefunderWithdrawn) (event.Subscription, error) {

	logs, sub, err := _GasRefunder.contract.WatchLogs(opts, "Withdrawn")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(GasRefunderWithdrawn)
				if err := _GasRefunder.contract.UnpackLog(event, "Withdrawn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseWithdrawn is a log parse operation binding the contract event 0xd1c19fbcd4551a5edfb66d43d2e337c04837afda3482b42bdf569a8fccdae5fb.
//
// Solidity: event Withdrawn(address initiator, address destination, uint256 amount)
func (_GasRefunder *GasRefunderFilterer) ParseWithdrawn(log types.Log) (*GasRefunderWithdrawn, error) {
	event := new(GasRefunderWithdrawn)
	if err := _GasRefunder.contract.UnpackLog(event, "Withdrawn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBridgeMetaData contains all meta data concerning the IBridge contract.
var IBridgeMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BridgeCallTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"InboxToggle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beforeInboxAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"MessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OutboxToggle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"}],\"name\":\"RollupUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSequencerInbox\",\"type\":\"address\"}],\"name\":\"SequencerInboxUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activeOutbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedDelayedInboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"}],\"name\":\"allowedDelayedInboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedOutboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"}],\"name\":\"allowedOutboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"delayedInboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayedMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"}],\"name\":\"enqueueSequencerMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seqMessageIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"beforeAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"delayedAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"acc\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sequencerInboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerReportedSubMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setDelayedInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setOutbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"setSequencerInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"batchPoster\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"submitBatchSpendingReport\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"msgNum\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"_rollup\",\"type\":\"address\"}],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IBridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use IBridgeMetaData.ABI instead.
var IBridgeABI = IBridgeMetaData.ABI

// IBridge is an auto generated Go binding around an Ethereum contract.
type IBridge struct {
	IBridgeCaller     // Read-only binding to the contract
	IBridgeTransactor // Write-only binding to the contract
	IBridgeFilterer   // Log filterer for contract events
}

// IBridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type IBridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IBridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IBridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IBridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IBridgeSession struct {
	Contract     *IBridge          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IBridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IBridgeCallerSession struct {
	Contract *IBridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// IBridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IBridgeTransactorSession struct {
	Contract     *IBridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IBridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type IBridgeRaw struct {
	Contract *IBridge // Generic contract binding to access the raw methods on
}

// IBridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IBridgeCallerRaw struct {
	Contract *IBridgeCaller // Generic read-only contract binding to access the raw methods on
}

// IBridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IBridgeTransactorRaw struct {
	Contract *IBridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIBridge creates a new instance of IBridge, bound to a specific deployed contract.
func NewIBridge(address common.Address, backend bind.ContractBackend) (*IBridge, error) {
	contract, err := bindIBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IBridge{IBridgeCaller: IBridgeCaller{contract: contract}, IBridgeTransactor: IBridgeTransactor{contract: contract}, IBridgeFilterer: IBridgeFilterer{contract: contract}}, nil
}

// NewIBridgeCaller creates a new read-only instance of IBridge, bound to a specific deployed contract.
func NewIBridgeCaller(address common.Address, caller bind.ContractCaller) (*IBridgeCaller, error) {
	contract, err := bindIBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IBridgeCaller{contract: contract}, nil
}

// NewIBridgeTransactor creates a new write-only instance of IBridge, bound to a specific deployed contract.
func NewIBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*IBridgeTransactor, error) {
	contract, err := bindIBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IBridgeTransactor{contract: contract}, nil
}

// NewIBridgeFilterer creates a new log filterer instance of IBridge, bound to a specific deployed contract.
func NewIBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*IBridgeFilterer, error) {
	contract, err := bindIBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IBridgeFilterer{contract: contract}, nil
}

// bindIBridge binds a generic wrapper to an already deployed contract.
func bindIBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IBridgeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBridge *IBridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBridge.Contract.IBridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBridge *IBridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBridge.Contract.IBridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBridge *IBridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBridge.Contract.IBridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IBridge *IBridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IBridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IBridge *IBridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IBridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IBridge *IBridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IBridge.Contract.contract.Transact(opts, method, params...)
}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_IBridge *IBridgeCaller) ActiveOutbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IBridge.contract.Call(opts, &out, "activeOutbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_IBridge *IBridgeSession) ActiveOutbox() (common.Address, error) {
	return _IBridge.Contract.ActiveOutbox(&_IBridge.CallOpts)
}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_IBridge *IBridgeCallerSession) ActiveOutbox() (common.Address, error) {
	return _IBridge.Contract.ActiveOutbox(&_IBridge.CallOpts)
}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_IBridge *IBridgeCaller) AllowedDelayedInboxes(opts *bind.CallOpts, inbox common.Address) (bool, error) {
	var out []interface{}
	err := _IBridge.contract.Call(opts, &out, "allowedDelayedInboxes", inbox)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_IBridge *IBridgeSession) AllowedDelayedInboxes(inbox common.Address) (bool, error) {
	return _IBridge.Contract.AllowedDelayedInboxes(&_IBridge.CallOpts, inbox)
}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_IBridge *IBridgeCallerSession) AllowedDelayedInboxes(inbox common.Address) (bool, error) {
	return _IBridge.Contract.AllowedDelayedInboxes(&_IBridge.CallOpts, inbox)
}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_IBridge *IBridgeCaller) AllowedOutboxes(opts *bind.CallOpts, outbox common.Address) (bool, error) {
	var out []interface{}
	err := _IBridge.contract.Call(opts, &out, "allowedOutboxes", outbox)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_IBridge *IBridgeSession) AllowedOutboxes(outbox common.Address) (bool, error) {
	return _IBridge.Contract.AllowedOutboxes(&_IBridge.CallOpts, outbox)
}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_IBridge *IBridgeCallerSession) AllowedOutboxes(outbox common.Address) (bool, error) {
	return _IBridge.Contract.AllowedOutboxes(&_IBridge.CallOpts, outbox)
}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_IBridge *IBridgeCaller) DelayedInboxAccs(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _IBridge.contract.Call(opts, &out, "delayedInboxAccs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_IBridge *IBridgeSession) DelayedInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _IBridge.Contract.DelayedInboxAccs(&_IBridge.CallOpts, arg0)
}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_IBridge *IBridgeCallerSession) DelayedInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _IBridge.Contract.DelayedInboxAccs(&_IBridge.CallOpts, arg0)
}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_IBridge *IBridgeCaller) DelayedMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IBridge.contract.Call(opts, &out, "delayedMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_IBridge *IBridgeSession) DelayedMessageCount() (*big.Int, error) {
	return _IBridge.Contract.DelayedMessageCount(&_IBridge.CallOpts)
}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_IBridge *IBridgeCallerSession) DelayedMessageCount() (*big.Int, error) {
	return _IBridge.Contract.DelayedMessageCount(&_IBridge.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_IBridge *IBridgeCaller) Rollup(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IBridge.contract.Call(opts, &out, "rollup")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_IBridge *IBridgeSession) Rollup() (common.Address, error) {
	return _IBridge.Contract.Rollup(&_IBridge.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_IBridge *IBridgeCallerSession) Rollup() (common.Address, error) {
	return _IBridge.Contract.Rollup(&_IBridge.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IBridge *IBridgeCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IBridge.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IBridge *IBridgeSession) SequencerInbox() (common.Address, error) {
	return _IBridge.Contract.SequencerInbox(&_IBridge.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IBridge *IBridgeCallerSession) SequencerInbox() (common.Address, error) {
	return _IBridge.Contract.SequencerInbox(&_IBridge.CallOpts)
}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_IBridge *IBridgeCaller) SequencerInboxAccs(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _IBridge.contract.Call(opts, &out, "sequencerInboxAccs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_IBridge *IBridgeSession) SequencerInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _IBridge.Contract.SequencerInboxAccs(&_IBridge.CallOpts, arg0)
}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_IBridge *IBridgeCallerSession) SequencerInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _IBridge.Contract.SequencerInboxAccs(&_IBridge.CallOpts, arg0)
}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_IBridge *IBridgeCaller) SequencerMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IBridge.contract.Call(opts, &out, "sequencerMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_IBridge *IBridgeSession) SequencerMessageCount() (*big.Int, error) {
	return _IBridge.Contract.SequencerMessageCount(&_IBridge.CallOpts)
}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_IBridge *IBridgeCallerSession) SequencerMessageCount() (*big.Int, error) {
	return _IBridge.Contract.SequencerMessageCount(&_IBridge.CallOpts)
}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_IBridge *IBridgeCaller) SequencerReportedSubMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IBridge.contract.Call(opts, &out, "sequencerReportedSubMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_IBridge *IBridgeSession) SequencerReportedSubMessageCount() (*big.Int, error) {
	return _IBridge.Contract.SequencerReportedSubMessageCount(&_IBridge.CallOpts)
}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_IBridge *IBridgeCallerSession) SequencerReportedSubMessageCount() (*big.Int, error) {
	return _IBridge.Contract.SequencerReportedSubMessageCount(&_IBridge.CallOpts)
}

// AllowedDelayedInboxList is a paid mutator transaction binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) returns(address)
func (_IBridge *IBridgeTransactor) AllowedDelayedInboxList(opts *bind.TransactOpts, arg0 *big.Int) (*types.Transaction, error) {
	return _IBridge.contract.Transact(opts, "allowedDelayedInboxList", arg0)
}

// AllowedDelayedInboxList is a paid mutator transaction binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) returns(address)
func (_IBridge *IBridgeSession) AllowedDelayedInboxList(arg0 *big.Int) (*types.Transaction, error) {
	return _IBridge.Contract.AllowedDelayedInboxList(&_IBridge.TransactOpts, arg0)
}

// AllowedDelayedInboxList is a paid mutator transaction binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) returns(address)
func (_IBridge *IBridgeTransactorSession) AllowedDelayedInboxList(arg0 *big.Int) (*types.Transaction, error) {
	return _IBridge.Contract.AllowedDelayedInboxList(&_IBridge.TransactOpts, arg0)
}

// AllowedOutboxList is a paid mutator transaction binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) returns(address)
func (_IBridge *IBridgeTransactor) AllowedOutboxList(opts *bind.TransactOpts, arg0 *big.Int) (*types.Transaction, error) {
	return _IBridge.contract.Transact(opts, "allowedOutboxList", arg0)
}

// AllowedOutboxList is a paid mutator transaction binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) returns(address)
func (_IBridge *IBridgeSession) AllowedOutboxList(arg0 *big.Int) (*types.Transaction, error) {
	return _IBridge.Contract.AllowedOutboxList(&_IBridge.TransactOpts, arg0)
}

// AllowedOutboxList is a paid mutator transaction binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) returns(address)
func (_IBridge *IBridgeTransactorSession) AllowedOutboxList(arg0 *big.Int) (*types.Transaction, error) {
	return _IBridge.Contract.AllowedOutboxList(&_IBridge.TransactOpts, arg0)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_IBridge *IBridgeTransactor) EnqueueSequencerMessage(opts *bind.TransactOpts, dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _IBridge.contract.Transact(opts, "enqueueSequencerMessage", dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_IBridge *IBridgeSession) EnqueueSequencerMessage(dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _IBridge.Contract.EnqueueSequencerMessage(&_IBridge.TransactOpts, dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_IBridge *IBridgeTransactorSession) EnqueueSequencerMessage(dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _IBridge.Contract.EnqueueSequencerMessage(&_IBridge.TransactOpts, dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_IBridge *IBridgeTransactor) ExecuteCall(opts *bind.TransactOpts, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IBridge.contract.Transact(opts, "executeCall", to, value, data)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_IBridge *IBridgeSession) ExecuteCall(to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IBridge.Contract.ExecuteCall(&_IBridge.TransactOpts, to, value, data)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_IBridge *IBridgeTransactorSession) ExecuteCall(to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IBridge.Contract.ExecuteCall(&_IBridge.TransactOpts, to, value, data)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_IBridge *IBridgeTransactor) SetDelayedInbox(opts *bind.TransactOpts, inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IBridge.contract.Transact(opts, "setDelayedInbox", inbox, enabled)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_IBridge *IBridgeSession) SetDelayedInbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IBridge.Contract.SetDelayedInbox(&_IBridge.TransactOpts, inbox, enabled)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_IBridge *IBridgeTransactorSession) SetDelayedInbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IBridge.Contract.SetDelayedInbox(&_IBridge.TransactOpts, inbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address inbox, bool enabled) returns()
func (_IBridge *IBridgeTransactor) SetOutbox(opts *bind.TransactOpts, inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IBridge.contract.Transact(opts, "setOutbox", inbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address inbox, bool enabled) returns()
func (_IBridge *IBridgeSession) SetOutbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IBridge.Contract.SetOutbox(&_IBridge.TransactOpts, inbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address inbox, bool enabled) returns()
func (_IBridge *IBridgeTransactorSession) SetOutbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IBridge.Contract.SetOutbox(&_IBridge.TransactOpts, inbox, enabled)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_IBridge *IBridgeTransactor) SetSequencerInbox(opts *bind.TransactOpts, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _IBridge.contract.Transact(opts, "setSequencerInbox", _sequencerInbox)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_IBridge *IBridgeSession) SetSequencerInbox(_sequencerInbox common.Address) (*types.Transaction, error) {
	return _IBridge.Contract.SetSequencerInbox(&_IBridge.TransactOpts, _sequencerInbox)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_IBridge *IBridgeTransactorSession) SetSequencerInbox(_sequencerInbox common.Address) (*types.Transaction, error) {
	return _IBridge.Contract.SetSequencerInbox(&_IBridge.TransactOpts, _sequencerInbox)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address batchPoster, bytes32 dataHash) returns(uint256 msgNum)
func (_IBridge *IBridgeTransactor) SubmitBatchSpendingReport(opts *bind.TransactOpts, batchPoster common.Address, dataHash [32]byte) (*types.Transaction, error) {
	return _IBridge.contract.Transact(opts, "submitBatchSpendingReport", batchPoster, dataHash)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address batchPoster, bytes32 dataHash) returns(uint256 msgNum)
func (_IBridge *IBridgeSession) SubmitBatchSpendingReport(batchPoster common.Address, dataHash [32]byte) (*types.Transaction, error) {
	return _IBridge.Contract.SubmitBatchSpendingReport(&_IBridge.TransactOpts, batchPoster, dataHash)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address batchPoster, bytes32 dataHash) returns(uint256 msgNum)
func (_IBridge *IBridgeTransactorSession) SubmitBatchSpendingReport(batchPoster common.Address, dataHash [32]byte) (*types.Transaction, error) {
	return _IBridge.Contract.SubmitBatchSpendingReport(&_IBridge.TransactOpts, batchPoster, dataHash)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_IBridge *IBridgeTransactor) UpdateRollupAddress(opts *bind.TransactOpts, _rollup common.Address) (*types.Transaction, error) {
	return _IBridge.contract.Transact(opts, "updateRollupAddress", _rollup)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_IBridge *IBridgeSession) UpdateRollupAddress(_rollup common.Address) (*types.Transaction, error) {
	return _IBridge.Contract.UpdateRollupAddress(&_IBridge.TransactOpts, _rollup)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_IBridge *IBridgeTransactorSession) UpdateRollupAddress(_rollup common.Address) (*types.Transaction, error) {
	return _IBridge.Contract.UpdateRollupAddress(&_IBridge.TransactOpts, _rollup)
}

// IBridgeBridgeCallTriggeredIterator is returned from FilterBridgeCallTriggered and is used to iterate over the raw logs and unpacked data for BridgeCallTriggered events raised by the IBridge contract.
type IBridgeBridgeCallTriggeredIterator struct {
	Event *IBridgeBridgeCallTriggered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBridgeBridgeCallTriggeredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBridgeBridgeCallTriggered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBridgeBridgeCallTriggered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBridgeBridgeCallTriggeredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBridgeBridgeCallTriggeredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBridgeBridgeCallTriggered represents a BridgeCallTriggered event raised by the IBridge contract.
type IBridgeBridgeCallTriggered struct {
	Outbox common.Address
	To     common.Address
	Value  *big.Int
	Data   []byte
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBridgeCallTriggered is a free log retrieval operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_IBridge *IBridgeFilterer) FilterBridgeCallTriggered(opts *bind.FilterOpts, outbox []common.Address, to []common.Address) (*IBridgeBridgeCallTriggeredIterator, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IBridge.contract.FilterLogs(opts, "BridgeCallTriggered", outboxRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IBridgeBridgeCallTriggeredIterator{contract: _IBridge.contract, event: "BridgeCallTriggered", logs: logs, sub: sub}, nil
}

// WatchBridgeCallTriggered is a free log subscription operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_IBridge *IBridgeFilterer) WatchBridgeCallTriggered(opts *bind.WatchOpts, sink chan<- *IBridgeBridgeCallTriggered, outbox []common.Address, to []common.Address) (event.Subscription, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IBridge.contract.WatchLogs(opts, "BridgeCallTriggered", outboxRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBridgeBridgeCallTriggered)
				if err := _IBridge.contract.UnpackLog(event, "BridgeCallTriggered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBridgeCallTriggered is a log parse operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_IBridge *IBridgeFilterer) ParseBridgeCallTriggered(log types.Log) (*IBridgeBridgeCallTriggered, error) {
	event := new(IBridgeBridgeCallTriggered)
	if err := _IBridge.contract.UnpackLog(event, "BridgeCallTriggered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBridgeInboxToggleIterator is returned from FilterInboxToggle and is used to iterate over the raw logs and unpacked data for InboxToggle events raised by the IBridge contract.
type IBridgeInboxToggleIterator struct {
	Event *IBridgeInboxToggle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBridgeInboxToggleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBridgeInboxToggle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBridgeInboxToggle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBridgeInboxToggleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBridgeInboxToggleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBridgeInboxToggle represents a InboxToggle event raised by the IBridge contract.
type IBridgeInboxToggle struct {
	Inbox   common.Address
	Enabled bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInboxToggle is a free log retrieval operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_IBridge *IBridgeFilterer) FilterInboxToggle(opts *bind.FilterOpts, inbox []common.Address) (*IBridgeInboxToggleIterator, error) {

	var inboxRule []interface{}
	for _, inboxItem := range inbox {
		inboxRule = append(inboxRule, inboxItem)
	}

	logs, sub, err := _IBridge.contract.FilterLogs(opts, "InboxToggle", inboxRule)
	if err != nil {
		return nil, err
	}
	return &IBridgeInboxToggleIterator{contract: _IBridge.contract, event: "InboxToggle", logs: logs, sub: sub}, nil
}

// WatchInboxToggle is a free log subscription operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_IBridge *IBridgeFilterer) WatchInboxToggle(opts *bind.WatchOpts, sink chan<- *IBridgeInboxToggle, inbox []common.Address) (event.Subscription, error) {

	var inboxRule []interface{}
	for _, inboxItem := range inbox {
		inboxRule = append(inboxRule, inboxItem)
	}

	logs, sub, err := _IBridge.contract.WatchLogs(opts, "InboxToggle", inboxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBridgeInboxToggle)
				if err := _IBridge.contract.UnpackLog(event, "InboxToggle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxToggle is a log parse operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_IBridge *IBridgeFilterer) ParseInboxToggle(log types.Log) (*IBridgeInboxToggle, error) {
	event := new(IBridgeInboxToggle)
	if err := _IBridge.contract.UnpackLog(event, "InboxToggle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBridgeMessageDeliveredIterator is returned from FilterMessageDelivered and is used to iterate over the raw logs and unpacked data for MessageDelivered events raised by the IBridge contract.
type IBridgeMessageDeliveredIterator struct {
	Event *IBridgeMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBridgeMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBridgeMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBridgeMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBridgeMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBridgeMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBridgeMessageDelivered represents a MessageDelivered event raised by the IBridge contract.
type IBridgeMessageDelivered struct {
	MessageIndex    *big.Int
	BeforeInboxAcc  [32]byte
	Inbox           common.Address
	Kind            uint8
	Sender          common.Address
	MessageDataHash [32]byte
	BaseFeeL1       *big.Int
	Timestamp       uint64
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterMessageDelivered is a free log retrieval operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_IBridge *IBridgeFilterer) FilterMessageDelivered(opts *bind.FilterOpts, messageIndex []*big.Int, beforeInboxAcc [][32]byte) (*IBridgeMessageDeliveredIterator, error) {

	var messageIndexRule []interface{}
	for _, messageIndexItem := range messageIndex {
		messageIndexRule = append(messageIndexRule, messageIndexItem)
	}
	var beforeInboxAccRule []interface{}
	for _, beforeInboxAccItem := range beforeInboxAcc {
		beforeInboxAccRule = append(beforeInboxAccRule, beforeInboxAccItem)
	}

	logs, sub, err := _IBridge.contract.FilterLogs(opts, "MessageDelivered", messageIndexRule, beforeInboxAccRule)
	if err != nil {
		return nil, err
	}
	return &IBridgeMessageDeliveredIterator{contract: _IBridge.contract, event: "MessageDelivered", logs: logs, sub: sub}, nil
}

// WatchMessageDelivered is a free log subscription operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_IBridge *IBridgeFilterer) WatchMessageDelivered(opts *bind.WatchOpts, sink chan<- *IBridgeMessageDelivered, messageIndex []*big.Int, beforeInboxAcc [][32]byte) (event.Subscription, error) {

	var messageIndexRule []interface{}
	for _, messageIndexItem := range messageIndex {
		messageIndexRule = append(messageIndexRule, messageIndexItem)
	}
	var beforeInboxAccRule []interface{}
	for _, beforeInboxAccItem := range beforeInboxAcc {
		beforeInboxAccRule = append(beforeInboxAccRule, beforeInboxAccItem)
	}

	logs, sub, err := _IBridge.contract.WatchLogs(opts, "MessageDelivered", messageIndexRule, beforeInboxAccRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBridgeMessageDelivered)
				if err := _IBridge.contract.UnpackLog(event, "MessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageDelivered is a log parse operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_IBridge *IBridgeFilterer) ParseMessageDelivered(log types.Log) (*IBridgeMessageDelivered, error) {
	event := new(IBridgeMessageDelivered)
	if err := _IBridge.contract.UnpackLog(event, "MessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBridgeOutboxToggleIterator is returned from FilterOutboxToggle and is used to iterate over the raw logs and unpacked data for OutboxToggle events raised by the IBridge contract.
type IBridgeOutboxToggleIterator struct {
	Event *IBridgeOutboxToggle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBridgeOutboxToggleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBridgeOutboxToggle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBridgeOutboxToggle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBridgeOutboxToggleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBridgeOutboxToggleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBridgeOutboxToggle represents a OutboxToggle event raised by the IBridge contract.
type IBridgeOutboxToggle struct {
	Outbox  common.Address
	Enabled bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterOutboxToggle is a free log retrieval operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_IBridge *IBridgeFilterer) FilterOutboxToggle(opts *bind.FilterOpts, outbox []common.Address) (*IBridgeOutboxToggleIterator, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}

	logs, sub, err := _IBridge.contract.FilterLogs(opts, "OutboxToggle", outboxRule)
	if err != nil {
		return nil, err
	}
	return &IBridgeOutboxToggleIterator{contract: _IBridge.contract, event: "OutboxToggle", logs: logs, sub: sub}, nil
}

// WatchOutboxToggle is a free log subscription operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_IBridge *IBridgeFilterer) WatchOutboxToggle(opts *bind.WatchOpts, sink chan<- *IBridgeOutboxToggle, outbox []common.Address) (event.Subscription, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}

	logs, sub, err := _IBridge.contract.WatchLogs(opts, "OutboxToggle", outboxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBridgeOutboxToggle)
				if err := _IBridge.contract.UnpackLog(event, "OutboxToggle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOutboxToggle is a log parse operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_IBridge *IBridgeFilterer) ParseOutboxToggle(log types.Log) (*IBridgeOutboxToggle, error) {
	event := new(IBridgeOutboxToggle)
	if err := _IBridge.contract.UnpackLog(event, "OutboxToggle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBridgeRollupUpdatedIterator is returned from FilterRollupUpdated and is used to iterate over the raw logs and unpacked data for RollupUpdated events raised by the IBridge contract.
type IBridgeRollupUpdatedIterator struct {
	Event *IBridgeRollupUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBridgeRollupUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBridgeRollupUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBridgeRollupUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBridgeRollupUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBridgeRollupUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBridgeRollupUpdated represents a RollupUpdated event raised by the IBridge contract.
type IBridgeRollupUpdated struct {
	Rollup common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRollupUpdated is a free log retrieval operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_IBridge *IBridgeFilterer) FilterRollupUpdated(opts *bind.FilterOpts) (*IBridgeRollupUpdatedIterator, error) {

	logs, sub, err := _IBridge.contract.FilterLogs(opts, "RollupUpdated")
	if err != nil {
		return nil, err
	}
	return &IBridgeRollupUpdatedIterator{contract: _IBridge.contract, event: "RollupUpdated", logs: logs, sub: sub}, nil
}

// WatchRollupUpdated is a free log subscription operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_IBridge *IBridgeFilterer) WatchRollupUpdated(opts *bind.WatchOpts, sink chan<- *IBridgeRollupUpdated) (event.Subscription, error) {

	logs, sub, err := _IBridge.contract.WatchLogs(opts, "RollupUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBridgeRollupUpdated)
				if err := _IBridge.contract.UnpackLog(event, "RollupUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupUpdated is a log parse operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_IBridge *IBridgeFilterer) ParseRollupUpdated(log types.Log) (*IBridgeRollupUpdated, error) {
	event := new(IBridgeRollupUpdated)
	if err := _IBridge.contract.UnpackLog(event, "RollupUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IBridgeSequencerInboxUpdatedIterator is returned from FilterSequencerInboxUpdated and is used to iterate over the raw logs and unpacked data for SequencerInboxUpdated events raised by the IBridge contract.
type IBridgeSequencerInboxUpdatedIterator struct {
	Event *IBridgeSequencerInboxUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IBridgeSequencerInboxUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IBridgeSequencerInboxUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IBridgeSequencerInboxUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IBridgeSequencerInboxUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IBridgeSequencerInboxUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IBridgeSequencerInboxUpdated represents a SequencerInboxUpdated event raised by the IBridge contract.
type IBridgeSequencerInboxUpdated struct {
	NewSequencerInbox common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterSequencerInboxUpdated is a free log retrieval operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_IBridge *IBridgeFilterer) FilterSequencerInboxUpdated(opts *bind.FilterOpts) (*IBridgeSequencerInboxUpdatedIterator, error) {

	logs, sub, err := _IBridge.contract.FilterLogs(opts, "SequencerInboxUpdated")
	if err != nil {
		return nil, err
	}
	return &IBridgeSequencerInboxUpdatedIterator{contract: _IBridge.contract, event: "SequencerInboxUpdated", logs: logs, sub: sub}, nil
}

// WatchSequencerInboxUpdated is a free log subscription operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_IBridge *IBridgeFilterer) WatchSequencerInboxUpdated(opts *bind.WatchOpts, sink chan<- *IBridgeSequencerInboxUpdated) (event.Subscription, error) {

	logs, sub, err := _IBridge.contract.WatchLogs(opts, "SequencerInboxUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IBridgeSequencerInboxUpdated)
				if err := _IBridge.contract.UnpackLog(event, "SequencerInboxUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSequencerInboxUpdated is a log parse operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_IBridge *IBridgeFilterer) ParseSequencerInboxUpdated(log types.Log) (*IBridgeSequencerInboxUpdated, error) {
	event := new(IBridgeSequencerInboxUpdated)
	if err := _IBridge.contract.UnpackLog(event, "SequencerInboxUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IDelayedMessageProviderMetaData contains all meta data concerning the IDelayedMessageProvider contract.
var IDelayedMessageProviderMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"}]",
}

// IDelayedMessageProviderABI is the input ABI used to generate the binding from.
// Deprecated: Use IDelayedMessageProviderMetaData.ABI instead.
var IDelayedMessageProviderABI = IDelayedMessageProviderMetaData.ABI

// IDelayedMessageProvider is an auto generated Go binding around an Ethereum contract.
type IDelayedMessageProvider struct {
	IDelayedMessageProviderCaller     // Read-only binding to the contract
	IDelayedMessageProviderTransactor // Write-only binding to the contract
	IDelayedMessageProviderFilterer   // Log filterer for contract events
}

// IDelayedMessageProviderCaller is an auto generated read-only Go binding around an Ethereum contract.
type IDelayedMessageProviderCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IDelayedMessageProviderTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IDelayedMessageProviderTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IDelayedMessageProviderFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IDelayedMessageProviderFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IDelayedMessageProviderSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IDelayedMessageProviderSession struct {
	Contract     *IDelayedMessageProvider // Generic contract binding to set the session for
	CallOpts     bind.CallOpts            // Call options to use throughout this session
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// IDelayedMessageProviderCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IDelayedMessageProviderCallerSession struct {
	Contract *IDelayedMessageProviderCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts                  // Call options to use throughout this session
}

// IDelayedMessageProviderTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IDelayedMessageProviderTransactorSession struct {
	Contract     *IDelayedMessageProviderTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts                  // Transaction auth options to use throughout this session
}

// IDelayedMessageProviderRaw is an auto generated low-level Go binding around an Ethereum contract.
type IDelayedMessageProviderRaw struct {
	Contract *IDelayedMessageProvider // Generic contract binding to access the raw methods on
}

// IDelayedMessageProviderCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IDelayedMessageProviderCallerRaw struct {
	Contract *IDelayedMessageProviderCaller // Generic read-only contract binding to access the raw methods on
}

// IDelayedMessageProviderTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IDelayedMessageProviderTransactorRaw struct {
	Contract *IDelayedMessageProviderTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIDelayedMessageProvider creates a new instance of IDelayedMessageProvider, bound to a specific deployed contract.
func NewIDelayedMessageProvider(address common.Address, backend bind.ContractBackend) (*IDelayedMessageProvider, error) {
	contract, err := bindIDelayedMessageProvider(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IDelayedMessageProvider{IDelayedMessageProviderCaller: IDelayedMessageProviderCaller{contract: contract}, IDelayedMessageProviderTransactor: IDelayedMessageProviderTransactor{contract: contract}, IDelayedMessageProviderFilterer: IDelayedMessageProviderFilterer{contract: contract}}, nil
}

// NewIDelayedMessageProviderCaller creates a new read-only instance of IDelayedMessageProvider, bound to a specific deployed contract.
func NewIDelayedMessageProviderCaller(address common.Address, caller bind.ContractCaller) (*IDelayedMessageProviderCaller, error) {
	contract, err := bindIDelayedMessageProvider(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IDelayedMessageProviderCaller{contract: contract}, nil
}

// NewIDelayedMessageProviderTransactor creates a new write-only instance of IDelayedMessageProvider, bound to a specific deployed contract.
func NewIDelayedMessageProviderTransactor(address common.Address, transactor bind.ContractTransactor) (*IDelayedMessageProviderTransactor, error) {
	contract, err := bindIDelayedMessageProvider(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IDelayedMessageProviderTransactor{contract: contract}, nil
}

// NewIDelayedMessageProviderFilterer creates a new log filterer instance of IDelayedMessageProvider, bound to a specific deployed contract.
func NewIDelayedMessageProviderFilterer(address common.Address, filterer bind.ContractFilterer) (*IDelayedMessageProviderFilterer, error) {
	contract, err := bindIDelayedMessageProvider(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IDelayedMessageProviderFilterer{contract: contract}, nil
}

// bindIDelayedMessageProvider binds a generic wrapper to an already deployed contract.
func bindIDelayedMessageProvider(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IDelayedMessageProviderMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IDelayedMessageProvider *IDelayedMessageProviderRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IDelayedMessageProvider.Contract.IDelayedMessageProviderCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IDelayedMessageProvider *IDelayedMessageProviderRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IDelayedMessageProvider.Contract.IDelayedMessageProviderTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IDelayedMessageProvider *IDelayedMessageProviderRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IDelayedMessageProvider.Contract.IDelayedMessageProviderTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IDelayedMessageProvider *IDelayedMessageProviderCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IDelayedMessageProvider.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IDelayedMessageProvider *IDelayedMessageProviderTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IDelayedMessageProvider.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IDelayedMessageProvider *IDelayedMessageProviderTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IDelayedMessageProvider.Contract.contract.Transact(opts, method, params...)
}

// IDelayedMessageProviderInboxMessageDeliveredIterator is returned from FilterInboxMessageDelivered and is used to iterate over the raw logs and unpacked data for InboxMessageDelivered events raised by the IDelayedMessageProvider contract.
type IDelayedMessageProviderInboxMessageDeliveredIterator struct {
	Event *IDelayedMessageProviderInboxMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IDelayedMessageProviderInboxMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IDelayedMessageProviderInboxMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IDelayedMessageProviderInboxMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IDelayedMessageProviderInboxMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IDelayedMessageProviderInboxMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IDelayedMessageProviderInboxMessageDelivered represents a InboxMessageDelivered event raised by the IDelayedMessageProvider contract.
type IDelayedMessageProviderInboxMessageDelivered struct {
	MessageNum *big.Int
	Data       []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDelivered is a free log retrieval operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_IDelayedMessageProvider *IDelayedMessageProviderFilterer) FilterInboxMessageDelivered(opts *bind.FilterOpts, messageNum []*big.Int) (*IDelayedMessageProviderInboxMessageDeliveredIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IDelayedMessageProvider.contract.FilterLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &IDelayedMessageProviderInboxMessageDeliveredIterator{contract: _IDelayedMessageProvider.contract, event: "InboxMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDelivered is a free log subscription operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_IDelayedMessageProvider *IDelayedMessageProviderFilterer) WatchInboxMessageDelivered(opts *bind.WatchOpts, sink chan<- *IDelayedMessageProviderInboxMessageDelivered, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IDelayedMessageProvider.contract.WatchLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IDelayedMessageProviderInboxMessageDelivered)
				if err := _IDelayedMessageProvider.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDelivered is a log parse operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_IDelayedMessageProvider *IDelayedMessageProviderFilterer) ParseInboxMessageDelivered(log types.Log) (*IDelayedMessageProviderInboxMessageDelivered, error) {
	event := new(IDelayedMessageProviderInboxMessageDelivered)
	if err := _IDelayedMessageProvider.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IDelayedMessageProviderInboxMessageDeliveredFromOriginIterator is returned from FilterInboxMessageDeliveredFromOrigin and is used to iterate over the raw logs and unpacked data for InboxMessageDeliveredFromOrigin events raised by the IDelayedMessageProvider contract.
type IDelayedMessageProviderInboxMessageDeliveredFromOriginIterator struct {
	Event *IDelayedMessageProviderInboxMessageDeliveredFromOrigin // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IDelayedMessageProviderInboxMessageDeliveredFromOriginIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IDelayedMessageProviderInboxMessageDeliveredFromOrigin)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IDelayedMessageProviderInboxMessageDeliveredFromOrigin)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IDelayedMessageProviderInboxMessageDeliveredFromOriginIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IDelayedMessageProviderInboxMessageDeliveredFromOriginIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IDelayedMessageProviderInboxMessageDeliveredFromOrigin represents a InboxMessageDeliveredFromOrigin event raised by the IDelayedMessageProvider contract.
type IDelayedMessageProviderInboxMessageDeliveredFromOrigin struct {
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDeliveredFromOrigin is a free log retrieval operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_IDelayedMessageProvider *IDelayedMessageProviderFilterer) FilterInboxMessageDeliveredFromOrigin(opts *bind.FilterOpts, messageNum []*big.Int) (*IDelayedMessageProviderInboxMessageDeliveredFromOriginIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IDelayedMessageProvider.contract.FilterLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &IDelayedMessageProviderInboxMessageDeliveredFromOriginIterator{contract: _IDelayedMessageProvider.contract, event: "InboxMessageDeliveredFromOrigin", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDeliveredFromOrigin is a free log subscription operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_IDelayedMessageProvider *IDelayedMessageProviderFilterer) WatchInboxMessageDeliveredFromOrigin(opts *bind.WatchOpts, sink chan<- *IDelayedMessageProviderInboxMessageDeliveredFromOrigin, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IDelayedMessageProvider.contract.WatchLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IDelayedMessageProviderInboxMessageDeliveredFromOrigin)
				if err := _IDelayedMessageProvider.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDeliveredFromOrigin is a log parse operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_IDelayedMessageProvider *IDelayedMessageProviderFilterer) ParseInboxMessageDeliveredFromOrigin(log types.Log) (*IDelayedMessageProviderInboxMessageDeliveredFromOrigin, error) {
	event := new(IDelayedMessageProviderInboxMessageDeliveredFromOrigin)
	if err := _IDelayedMessageProvider.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20BridgeMetaData contains all meta data concerning the IERC20Bridge contract.
var IERC20BridgeMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BridgeCallTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"InboxToggle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beforeInboxAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"MessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OutboxToggle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"}],\"name\":\"RollupUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSequencerInbox\",\"type\":\"address\"}],\"name\":\"SequencerInboxUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activeOutbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedDelayedInboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"}],\"name\":\"allowedDelayedInboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedOutboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"}],\"name\":\"allowedOutboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"delayedInboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayedMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"tokenFeeAmount\",\"type\":\"uint256\"}],\"name\":\"enqueueDelayedMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"}],\"name\":\"enqueueSequencerMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seqMessageIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"beforeAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"delayedAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"acc\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"rollup_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nativeToken_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeTokenDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sequencerInboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerReportedSubMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setDelayedInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setOutbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"setSequencerInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"batchPoster\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"submitBatchSpendingReport\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"msgNum\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"_rollup\",\"type\":\"address\"}],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IERC20BridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20BridgeMetaData.ABI instead.
var IERC20BridgeABI = IERC20BridgeMetaData.ABI

// IERC20Bridge is an auto generated Go binding around an Ethereum contract.
type IERC20Bridge struct {
	IERC20BridgeCaller     // Read-only binding to the contract
	IERC20BridgeTransactor // Write-only binding to the contract
	IERC20BridgeFilterer   // Log filterer for contract events
}

// IERC20BridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20BridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20BridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20BridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20BridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20BridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20BridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20BridgeSession struct {
	Contract     *IERC20Bridge     // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20BridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20BridgeCallerSession struct {
	Contract *IERC20BridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts       // Call options to use throughout this session
}

// IERC20BridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20BridgeTransactorSession struct {
	Contract     *IERC20BridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts       // Transaction auth options to use throughout this session
}

// IERC20BridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20BridgeRaw struct {
	Contract *IERC20Bridge // Generic contract binding to access the raw methods on
}

// IERC20BridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20BridgeCallerRaw struct {
	Contract *IERC20BridgeCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20BridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20BridgeTransactorRaw struct {
	Contract *IERC20BridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20Bridge creates a new instance of IERC20Bridge, bound to a specific deployed contract.
func NewIERC20Bridge(address common.Address, backend bind.ContractBackend) (*IERC20Bridge, error) {
	contract, err := bindIERC20Bridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20Bridge{IERC20BridgeCaller: IERC20BridgeCaller{contract: contract}, IERC20BridgeTransactor: IERC20BridgeTransactor{contract: contract}, IERC20BridgeFilterer: IERC20BridgeFilterer{contract: contract}}, nil
}

// NewIERC20BridgeCaller creates a new read-only instance of IERC20Bridge, bound to a specific deployed contract.
func NewIERC20BridgeCaller(address common.Address, caller bind.ContractCaller) (*IERC20BridgeCaller, error) {
	contract, err := bindIERC20Bridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeCaller{contract: contract}, nil
}

// NewIERC20BridgeTransactor creates a new write-only instance of IERC20Bridge, bound to a specific deployed contract.
func NewIERC20BridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20BridgeTransactor, error) {
	contract, err := bindIERC20Bridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeTransactor{contract: contract}, nil
}

// NewIERC20BridgeFilterer creates a new log filterer instance of IERC20Bridge, bound to a specific deployed contract.
func NewIERC20BridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20BridgeFilterer, error) {
	contract, err := bindIERC20Bridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeFilterer{contract: contract}, nil
}

// bindIERC20Bridge binds a generic wrapper to an already deployed contract.
func bindIERC20Bridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC20BridgeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Bridge *IERC20BridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Bridge.Contract.IERC20BridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Bridge *IERC20BridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.IERC20BridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Bridge *IERC20BridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.IERC20BridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Bridge *IERC20BridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Bridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Bridge *IERC20BridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Bridge *IERC20BridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.contract.Transact(opts, method, params...)
}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_IERC20Bridge *IERC20BridgeCaller) ActiveOutbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IERC20Bridge.contract.Call(opts, &out, "activeOutbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_IERC20Bridge *IERC20BridgeSession) ActiveOutbox() (common.Address, error) {
	return _IERC20Bridge.Contract.ActiveOutbox(&_IERC20Bridge.CallOpts)
}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_IERC20Bridge *IERC20BridgeCallerSession) ActiveOutbox() (common.Address, error) {
	return _IERC20Bridge.Contract.ActiveOutbox(&_IERC20Bridge.CallOpts)
}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_IERC20Bridge *IERC20BridgeCaller) AllowedDelayedInboxes(opts *bind.CallOpts, inbox common.Address) (bool, error) {
	var out []interface{}
	err := _IERC20Bridge.contract.Call(opts, &out, "allowedDelayedInboxes", inbox)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_IERC20Bridge *IERC20BridgeSession) AllowedDelayedInboxes(inbox common.Address) (bool, error) {
	return _IERC20Bridge.Contract.AllowedDelayedInboxes(&_IERC20Bridge.CallOpts, inbox)
}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_IERC20Bridge *IERC20BridgeCallerSession) AllowedDelayedInboxes(inbox common.Address) (bool, error) {
	return _IERC20Bridge.Contract.AllowedDelayedInboxes(&_IERC20Bridge.CallOpts, inbox)
}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_IERC20Bridge *IERC20BridgeCaller) AllowedOutboxes(opts *bind.CallOpts, outbox common.Address) (bool, error) {
	var out []interface{}
	err := _IERC20Bridge.contract.Call(opts, &out, "allowedOutboxes", outbox)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_IERC20Bridge *IERC20BridgeSession) AllowedOutboxes(outbox common.Address) (bool, error) {
	return _IERC20Bridge.Contract.AllowedOutboxes(&_IERC20Bridge.CallOpts, outbox)
}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_IERC20Bridge *IERC20BridgeCallerSession) AllowedOutboxes(outbox common.Address) (bool, error) {
	return _IERC20Bridge.Contract.AllowedOutboxes(&_IERC20Bridge.CallOpts, outbox)
}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_IERC20Bridge *IERC20BridgeCaller) DelayedInboxAccs(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _IERC20Bridge.contract.Call(opts, &out, "delayedInboxAccs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_IERC20Bridge *IERC20BridgeSession) DelayedInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _IERC20Bridge.Contract.DelayedInboxAccs(&_IERC20Bridge.CallOpts, arg0)
}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_IERC20Bridge *IERC20BridgeCallerSession) DelayedInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _IERC20Bridge.Contract.DelayedInboxAccs(&_IERC20Bridge.CallOpts, arg0)
}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_IERC20Bridge *IERC20BridgeCaller) DelayedMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Bridge.contract.Call(opts, &out, "delayedMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_IERC20Bridge *IERC20BridgeSession) DelayedMessageCount() (*big.Int, error) {
	return _IERC20Bridge.Contract.DelayedMessageCount(&_IERC20Bridge.CallOpts)
}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_IERC20Bridge *IERC20BridgeCallerSession) DelayedMessageCount() (*big.Int, error) {
	return _IERC20Bridge.Contract.DelayedMessageCount(&_IERC20Bridge.CallOpts)
}

// NativeToken is a free data retrieval call binding the contract method 0xe1758bd8.
//
// Solidity: function nativeToken() view returns(address)
func (_IERC20Bridge *IERC20BridgeCaller) NativeToken(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IERC20Bridge.contract.Call(opts, &out, "nativeToken")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// NativeToken is a free data retrieval call binding the contract method 0xe1758bd8.
//
// Solidity: function nativeToken() view returns(address)
func (_IERC20Bridge *IERC20BridgeSession) NativeToken() (common.Address, error) {
	return _IERC20Bridge.Contract.NativeToken(&_IERC20Bridge.CallOpts)
}

// NativeToken is a free data retrieval call binding the contract method 0xe1758bd8.
//
// Solidity: function nativeToken() view returns(address)
func (_IERC20Bridge *IERC20BridgeCallerSession) NativeToken() (common.Address, error) {
	return _IERC20Bridge.Contract.NativeToken(&_IERC20Bridge.CallOpts)
}

// NativeTokenDecimals is a free data retrieval call binding the contract method 0xad48cb5e.
//
// Solidity: function nativeTokenDecimals() view returns(uint8)
func (_IERC20Bridge *IERC20BridgeCaller) NativeTokenDecimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _IERC20Bridge.contract.Call(opts, &out, "nativeTokenDecimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// NativeTokenDecimals is a free data retrieval call binding the contract method 0xad48cb5e.
//
// Solidity: function nativeTokenDecimals() view returns(uint8)
func (_IERC20Bridge *IERC20BridgeSession) NativeTokenDecimals() (uint8, error) {
	return _IERC20Bridge.Contract.NativeTokenDecimals(&_IERC20Bridge.CallOpts)
}

// NativeTokenDecimals is a free data retrieval call binding the contract method 0xad48cb5e.
//
// Solidity: function nativeTokenDecimals() view returns(uint8)
func (_IERC20Bridge *IERC20BridgeCallerSession) NativeTokenDecimals() (uint8, error) {
	return _IERC20Bridge.Contract.NativeTokenDecimals(&_IERC20Bridge.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_IERC20Bridge *IERC20BridgeCaller) Rollup(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IERC20Bridge.contract.Call(opts, &out, "rollup")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_IERC20Bridge *IERC20BridgeSession) Rollup() (common.Address, error) {
	return _IERC20Bridge.Contract.Rollup(&_IERC20Bridge.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_IERC20Bridge *IERC20BridgeCallerSession) Rollup() (common.Address, error) {
	return _IERC20Bridge.Contract.Rollup(&_IERC20Bridge.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IERC20Bridge *IERC20BridgeCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IERC20Bridge.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IERC20Bridge *IERC20BridgeSession) SequencerInbox() (common.Address, error) {
	return _IERC20Bridge.Contract.SequencerInbox(&_IERC20Bridge.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IERC20Bridge *IERC20BridgeCallerSession) SequencerInbox() (common.Address, error) {
	return _IERC20Bridge.Contract.SequencerInbox(&_IERC20Bridge.CallOpts)
}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_IERC20Bridge *IERC20BridgeCaller) SequencerInboxAccs(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _IERC20Bridge.contract.Call(opts, &out, "sequencerInboxAccs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_IERC20Bridge *IERC20BridgeSession) SequencerInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _IERC20Bridge.Contract.SequencerInboxAccs(&_IERC20Bridge.CallOpts, arg0)
}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_IERC20Bridge *IERC20BridgeCallerSession) SequencerInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _IERC20Bridge.Contract.SequencerInboxAccs(&_IERC20Bridge.CallOpts, arg0)
}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_IERC20Bridge *IERC20BridgeCaller) SequencerMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Bridge.contract.Call(opts, &out, "sequencerMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_IERC20Bridge *IERC20BridgeSession) SequencerMessageCount() (*big.Int, error) {
	return _IERC20Bridge.Contract.SequencerMessageCount(&_IERC20Bridge.CallOpts)
}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_IERC20Bridge *IERC20BridgeCallerSession) SequencerMessageCount() (*big.Int, error) {
	return _IERC20Bridge.Contract.SequencerMessageCount(&_IERC20Bridge.CallOpts)
}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_IERC20Bridge *IERC20BridgeCaller) SequencerReportedSubMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Bridge.contract.Call(opts, &out, "sequencerReportedSubMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_IERC20Bridge *IERC20BridgeSession) SequencerReportedSubMessageCount() (*big.Int, error) {
	return _IERC20Bridge.Contract.SequencerReportedSubMessageCount(&_IERC20Bridge.CallOpts)
}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_IERC20Bridge *IERC20BridgeCallerSession) SequencerReportedSubMessageCount() (*big.Int, error) {
	return _IERC20Bridge.Contract.SequencerReportedSubMessageCount(&_IERC20Bridge.CallOpts)
}

// AllowedDelayedInboxList is a paid mutator transaction binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) returns(address)
func (_IERC20Bridge *IERC20BridgeTransactor) AllowedDelayedInboxList(opts *bind.TransactOpts, arg0 *big.Int) (*types.Transaction, error) {
	return _IERC20Bridge.contract.Transact(opts, "allowedDelayedInboxList", arg0)
}

// AllowedDelayedInboxList is a paid mutator transaction binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) returns(address)
func (_IERC20Bridge *IERC20BridgeSession) AllowedDelayedInboxList(arg0 *big.Int) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.AllowedDelayedInboxList(&_IERC20Bridge.TransactOpts, arg0)
}

// AllowedDelayedInboxList is a paid mutator transaction binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) returns(address)
func (_IERC20Bridge *IERC20BridgeTransactorSession) AllowedDelayedInboxList(arg0 *big.Int) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.AllowedDelayedInboxList(&_IERC20Bridge.TransactOpts, arg0)
}

// AllowedOutboxList is a paid mutator transaction binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) returns(address)
func (_IERC20Bridge *IERC20BridgeTransactor) AllowedOutboxList(opts *bind.TransactOpts, arg0 *big.Int) (*types.Transaction, error) {
	return _IERC20Bridge.contract.Transact(opts, "allowedOutboxList", arg0)
}

// AllowedOutboxList is a paid mutator transaction binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) returns(address)
func (_IERC20Bridge *IERC20BridgeSession) AllowedOutboxList(arg0 *big.Int) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.AllowedOutboxList(&_IERC20Bridge.TransactOpts, arg0)
}

// AllowedOutboxList is a paid mutator transaction binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) returns(address)
func (_IERC20Bridge *IERC20BridgeTransactorSession) AllowedOutboxList(arg0 *big.Int) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.AllowedOutboxList(&_IERC20Bridge.TransactOpts, arg0)
}

// EnqueueDelayedMessage is a paid mutator transaction binding the contract method 0x75d81e25.
//
// Solidity: function enqueueDelayedMessage(uint8 kind, address sender, bytes32 messageDataHash, uint256 tokenFeeAmount) returns(uint256)
func (_IERC20Bridge *IERC20BridgeTransactor) EnqueueDelayedMessage(opts *bind.TransactOpts, kind uint8, sender common.Address, messageDataHash [32]byte, tokenFeeAmount *big.Int) (*types.Transaction, error) {
	return _IERC20Bridge.contract.Transact(opts, "enqueueDelayedMessage", kind, sender, messageDataHash, tokenFeeAmount)
}

// EnqueueDelayedMessage is a paid mutator transaction binding the contract method 0x75d81e25.
//
// Solidity: function enqueueDelayedMessage(uint8 kind, address sender, bytes32 messageDataHash, uint256 tokenFeeAmount) returns(uint256)
func (_IERC20Bridge *IERC20BridgeSession) EnqueueDelayedMessage(kind uint8, sender common.Address, messageDataHash [32]byte, tokenFeeAmount *big.Int) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.EnqueueDelayedMessage(&_IERC20Bridge.TransactOpts, kind, sender, messageDataHash, tokenFeeAmount)
}

// EnqueueDelayedMessage is a paid mutator transaction binding the contract method 0x75d81e25.
//
// Solidity: function enqueueDelayedMessage(uint8 kind, address sender, bytes32 messageDataHash, uint256 tokenFeeAmount) returns(uint256)
func (_IERC20Bridge *IERC20BridgeTransactorSession) EnqueueDelayedMessage(kind uint8, sender common.Address, messageDataHash [32]byte, tokenFeeAmount *big.Int) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.EnqueueDelayedMessage(&_IERC20Bridge.TransactOpts, kind, sender, messageDataHash, tokenFeeAmount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_IERC20Bridge *IERC20BridgeTransactor) EnqueueSequencerMessage(opts *bind.TransactOpts, dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _IERC20Bridge.contract.Transact(opts, "enqueueSequencerMessage", dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_IERC20Bridge *IERC20BridgeSession) EnqueueSequencerMessage(dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.EnqueueSequencerMessage(&_IERC20Bridge.TransactOpts, dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_IERC20Bridge *IERC20BridgeTransactorSession) EnqueueSequencerMessage(dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.EnqueueSequencerMessage(&_IERC20Bridge.TransactOpts, dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_IERC20Bridge *IERC20BridgeTransactor) ExecuteCall(opts *bind.TransactOpts, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Bridge.contract.Transact(opts, "executeCall", to, value, data)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_IERC20Bridge *IERC20BridgeSession) ExecuteCall(to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.ExecuteCall(&_IERC20Bridge.TransactOpts, to, value, data)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_IERC20Bridge *IERC20BridgeTransactorSession) ExecuteCall(to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.ExecuteCall(&_IERC20Bridge.TransactOpts, to, value, data)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address rollup_, address nativeToken_) returns()
func (_IERC20Bridge *IERC20BridgeTransactor) Initialize(opts *bind.TransactOpts, rollup_ common.Address, nativeToken_ common.Address) (*types.Transaction, error) {
	return _IERC20Bridge.contract.Transact(opts, "initialize", rollup_, nativeToken_)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address rollup_, address nativeToken_) returns()
func (_IERC20Bridge *IERC20BridgeSession) Initialize(rollup_ common.Address, nativeToken_ common.Address) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.Initialize(&_IERC20Bridge.TransactOpts, rollup_, nativeToken_)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address rollup_, address nativeToken_) returns()
func (_IERC20Bridge *IERC20BridgeTransactorSession) Initialize(rollup_ common.Address, nativeToken_ common.Address) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.Initialize(&_IERC20Bridge.TransactOpts, rollup_, nativeToken_)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_IERC20Bridge *IERC20BridgeTransactor) SetDelayedInbox(opts *bind.TransactOpts, inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IERC20Bridge.contract.Transact(opts, "setDelayedInbox", inbox, enabled)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_IERC20Bridge *IERC20BridgeSession) SetDelayedInbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.SetDelayedInbox(&_IERC20Bridge.TransactOpts, inbox, enabled)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_IERC20Bridge *IERC20BridgeTransactorSession) SetDelayedInbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.SetDelayedInbox(&_IERC20Bridge.TransactOpts, inbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address inbox, bool enabled) returns()
func (_IERC20Bridge *IERC20BridgeTransactor) SetOutbox(opts *bind.TransactOpts, inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IERC20Bridge.contract.Transact(opts, "setOutbox", inbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address inbox, bool enabled) returns()
func (_IERC20Bridge *IERC20BridgeSession) SetOutbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.SetOutbox(&_IERC20Bridge.TransactOpts, inbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address inbox, bool enabled) returns()
func (_IERC20Bridge *IERC20BridgeTransactorSession) SetOutbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.SetOutbox(&_IERC20Bridge.TransactOpts, inbox, enabled)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_IERC20Bridge *IERC20BridgeTransactor) SetSequencerInbox(opts *bind.TransactOpts, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _IERC20Bridge.contract.Transact(opts, "setSequencerInbox", _sequencerInbox)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_IERC20Bridge *IERC20BridgeSession) SetSequencerInbox(_sequencerInbox common.Address) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.SetSequencerInbox(&_IERC20Bridge.TransactOpts, _sequencerInbox)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_IERC20Bridge *IERC20BridgeTransactorSession) SetSequencerInbox(_sequencerInbox common.Address) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.SetSequencerInbox(&_IERC20Bridge.TransactOpts, _sequencerInbox)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address batchPoster, bytes32 dataHash) returns(uint256 msgNum)
func (_IERC20Bridge *IERC20BridgeTransactor) SubmitBatchSpendingReport(opts *bind.TransactOpts, batchPoster common.Address, dataHash [32]byte) (*types.Transaction, error) {
	return _IERC20Bridge.contract.Transact(opts, "submitBatchSpendingReport", batchPoster, dataHash)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address batchPoster, bytes32 dataHash) returns(uint256 msgNum)
func (_IERC20Bridge *IERC20BridgeSession) SubmitBatchSpendingReport(batchPoster common.Address, dataHash [32]byte) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.SubmitBatchSpendingReport(&_IERC20Bridge.TransactOpts, batchPoster, dataHash)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address batchPoster, bytes32 dataHash) returns(uint256 msgNum)
func (_IERC20Bridge *IERC20BridgeTransactorSession) SubmitBatchSpendingReport(batchPoster common.Address, dataHash [32]byte) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.SubmitBatchSpendingReport(&_IERC20Bridge.TransactOpts, batchPoster, dataHash)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_IERC20Bridge *IERC20BridgeTransactor) UpdateRollupAddress(opts *bind.TransactOpts, _rollup common.Address) (*types.Transaction, error) {
	return _IERC20Bridge.contract.Transact(opts, "updateRollupAddress", _rollup)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_IERC20Bridge *IERC20BridgeSession) UpdateRollupAddress(_rollup common.Address) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.UpdateRollupAddress(&_IERC20Bridge.TransactOpts, _rollup)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_IERC20Bridge *IERC20BridgeTransactorSession) UpdateRollupAddress(_rollup common.Address) (*types.Transaction, error) {
	return _IERC20Bridge.Contract.UpdateRollupAddress(&_IERC20Bridge.TransactOpts, _rollup)
}

// IERC20BridgeBridgeCallTriggeredIterator is returned from FilterBridgeCallTriggered and is used to iterate over the raw logs and unpacked data for BridgeCallTriggered events raised by the IERC20Bridge contract.
type IERC20BridgeBridgeCallTriggeredIterator struct {
	Event *IERC20BridgeBridgeCallTriggered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20BridgeBridgeCallTriggeredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20BridgeBridgeCallTriggered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20BridgeBridgeCallTriggered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20BridgeBridgeCallTriggeredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20BridgeBridgeCallTriggeredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20BridgeBridgeCallTriggered represents a BridgeCallTriggered event raised by the IERC20Bridge contract.
type IERC20BridgeBridgeCallTriggered struct {
	Outbox common.Address
	To     common.Address
	Value  *big.Int
	Data   []byte
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBridgeCallTriggered is a free log retrieval operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_IERC20Bridge *IERC20BridgeFilterer) FilterBridgeCallTriggered(opts *bind.FilterOpts, outbox []common.Address, to []common.Address) (*IERC20BridgeBridgeCallTriggeredIterator, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Bridge.contract.FilterLogs(opts, "BridgeCallTriggered", outboxRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeBridgeCallTriggeredIterator{contract: _IERC20Bridge.contract, event: "BridgeCallTriggered", logs: logs, sub: sub}, nil
}

// WatchBridgeCallTriggered is a free log subscription operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_IERC20Bridge *IERC20BridgeFilterer) WatchBridgeCallTriggered(opts *bind.WatchOpts, sink chan<- *IERC20BridgeBridgeCallTriggered, outbox []common.Address, to []common.Address) (event.Subscription, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IERC20Bridge.contract.WatchLogs(opts, "BridgeCallTriggered", outboxRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20BridgeBridgeCallTriggered)
				if err := _IERC20Bridge.contract.UnpackLog(event, "BridgeCallTriggered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBridgeCallTriggered is a log parse operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_IERC20Bridge *IERC20BridgeFilterer) ParseBridgeCallTriggered(log types.Log) (*IERC20BridgeBridgeCallTriggered, error) {
	event := new(IERC20BridgeBridgeCallTriggered)
	if err := _IERC20Bridge.contract.UnpackLog(event, "BridgeCallTriggered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20BridgeInboxToggleIterator is returned from FilterInboxToggle and is used to iterate over the raw logs and unpacked data for InboxToggle events raised by the IERC20Bridge contract.
type IERC20BridgeInboxToggleIterator struct {
	Event *IERC20BridgeInboxToggle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20BridgeInboxToggleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20BridgeInboxToggle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20BridgeInboxToggle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20BridgeInboxToggleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20BridgeInboxToggleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20BridgeInboxToggle represents a InboxToggle event raised by the IERC20Bridge contract.
type IERC20BridgeInboxToggle struct {
	Inbox   common.Address
	Enabled bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInboxToggle is a free log retrieval operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_IERC20Bridge *IERC20BridgeFilterer) FilterInboxToggle(opts *bind.FilterOpts, inbox []common.Address) (*IERC20BridgeInboxToggleIterator, error) {

	var inboxRule []interface{}
	for _, inboxItem := range inbox {
		inboxRule = append(inboxRule, inboxItem)
	}

	logs, sub, err := _IERC20Bridge.contract.FilterLogs(opts, "InboxToggle", inboxRule)
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeInboxToggleIterator{contract: _IERC20Bridge.contract, event: "InboxToggle", logs: logs, sub: sub}, nil
}

// WatchInboxToggle is a free log subscription operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_IERC20Bridge *IERC20BridgeFilterer) WatchInboxToggle(opts *bind.WatchOpts, sink chan<- *IERC20BridgeInboxToggle, inbox []common.Address) (event.Subscription, error) {

	var inboxRule []interface{}
	for _, inboxItem := range inbox {
		inboxRule = append(inboxRule, inboxItem)
	}

	logs, sub, err := _IERC20Bridge.contract.WatchLogs(opts, "InboxToggle", inboxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20BridgeInboxToggle)
				if err := _IERC20Bridge.contract.UnpackLog(event, "InboxToggle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxToggle is a log parse operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_IERC20Bridge *IERC20BridgeFilterer) ParseInboxToggle(log types.Log) (*IERC20BridgeInboxToggle, error) {
	event := new(IERC20BridgeInboxToggle)
	if err := _IERC20Bridge.contract.UnpackLog(event, "InboxToggle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20BridgeMessageDeliveredIterator is returned from FilterMessageDelivered and is used to iterate over the raw logs and unpacked data for MessageDelivered events raised by the IERC20Bridge contract.
type IERC20BridgeMessageDeliveredIterator struct {
	Event *IERC20BridgeMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20BridgeMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20BridgeMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20BridgeMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20BridgeMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20BridgeMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20BridgeMessageDelivered represents a MessageDelivered event raised by the IERC20Bridge contract.
type IERC20BridgeMessageDelivered struct {
	MessageIndex    *big.Int
	BeforeInboxAcc  [32]byte
	Inbox           common.Address
	Kind            uint8
	Sender          common.Address
	MessageDataHash [32]byte
	BaseFeeL1       *big.Int
	Timestamp       uint64
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterMessageDelivered is a free log retrieval operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_IERC20Bridge *IERC20BridgeFilterer) FilterMessageDelivered(opts *bind.FilterOpts, messageIndex []*big.Int, beforeInboxAcc [][32]byte) (*IERC20BridgeMessageDeliveredIterator, error) {

	var messageIndexRule []interface{}
	for _, messageIndexItem := range messageIndex {
		messageIndexRule = append(messageIndexRule, messageIndexItem)
	}
	var beforeInboxAccRule []interface{}
	for _, beforeInboxAccItem := range beforeInboxAcc {
		beforeInboxAccRule = append(beforeInboxAccRule, beforeInboxAccItem)
	}

	logs, sub, err := _IERC20Bridge.contract.FilterLogs(opts, "MessageDelivered", messageIndexRule, beforeInboxAccRule)
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeMessageDeliveredIterator{contract: _IERC20Bridge.contract, event: "MessageDelivered", logs: logs, sub: sub}, nil
}

// WatchMessageDelivered is a free log subscription operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_IERC20Bridge *IERC20BridgeFilterer) WatchMessageDelivered(opts *bind.WatchOpts, sink chan<- *IERC20BridgeMessageDelivered, messageIndex []*big.Int, beforeInboxAcc [][32]byte) (event.Subscription, error) {

	var messageIndexRule []interface{}
	for _, messageIndexItem := range messageIndex {
		messageIndexRule = append(messageIndexRule, messageIndexItem)
	}
	var beforeInboxAccRule []interface{}
	for _, beforeInboxAccItem := range beforeInboxAcc {
		beforeInboxAccRule = append(beforeInboxAccRule, beforeInboxAccItem)
	}

	logs, sub, err := _IERC20Bridge.contract.WatchLogs(opts, "MessageDelivered", messageIndexRule, beforeInboxAccRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20BridgeMessageDelivered)
				if err := _IERC20Bridge.contract.UnpackLog(event, "MessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageDelivered is a log parse operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_IERC20Bridge *IERC20BridgeFilterer) ParseMessageDelivered(log types.Log) (*IERC20BridgeMessageDelivered, error) {
	event := new(IERC20BridgeMessageDelivered)
	if err := _IERC20Bridge.contract.UnpackLog(event, "MessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20BridgeOutboxToggleIterator is returned from FilterOutboxToggle and is used to iterate over the raw logs and unpacked data for OutboxToggle events raised by the IERC20Bridge contract.
type IERC20BridgeOutboxToggleIterator struct {
	Event *IERC20BridgeOutboxToggle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20BridgeOutboxToggleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20BridgeOutboxToggle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20BridgeOutboxToggle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20BridgeOutboxToggleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20BridgeOutboxToggleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20BridgeOutboxToggle represents a OutboxToggle event raised by the IERC20Bridge contract.
type IERC20BridgeOutboxToggle struct {
	Outbox  common.Address
	Enabled bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterOutboxToggle is a free log retrieval operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_IERC20Bridge *IERC20BridgeFilterer) FilterOutboxToggle(opts *bind.FilterOpts, outbox []common.Address) (*IERC20BridgeOutboxToggleIterator, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}

	logs, sub, err := _IERC20Bridge.contract.FilterLogs(opts, "OutboxToggle", outboxRule)
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeOutboxToggleIterator{contract: _IERC20Bridge.contract, event: "OutboxToggle", logs: logs, sub: sub}, nil
}

// WatchOutboxToggle is a free log subscription operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_IERC20Bridge *IERC20BridgeFilterer) WatchOutboxToggle(opts *bind.WatchOpts, sink chan<- *IERC20BridgeOutboxToggle, outbox []common.Address) (event.Subscription, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}

	logs, sub, err := _IERC20Bridge.contract.WatchLogs(opts, "OutboxToggle", outboxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20BridgeOutboxToggle)
				if err := _IERC20Bridge.contract.UnpackLog(event, "OutboxToggle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOutboxToggle is a log parse operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_IERC20Bridge *IERC20BridgeFilterer) ParseOutboxToggle(log types.Log) (*IERC20BridgeOutboxToggle, error) {
	event := new(IERC20BridgeOutboxToggle)
	if err := _IERC20Bridge.contract.UnpackLog(event, "OutboxToggle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20BridgeRollupUpdatedIterator is returned from FilterRollupUpdated and is used to iterate over the raw logs and unpacked data for RollupUpdated events raised by the IERC20Bridge contract.
type IERC20BridgeRollupUpdatedIterator struct {
	Event *IERC20BridgeRollupUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20BridgeRollupUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20BridgeRollupUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20BridgeRollupUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20BridgeRollupUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20BridgeRollupUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20BridgeRollupUpdated represents a RollupUpdated event raised by the IERC20Bridge contract.
type IERC20BridgeRollupUpdated struct {
	Rollup common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRollupUpdated is a free log retrieval operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_IERC20Bridge *IERC20BridgeFilterer) FilterRollupUpdated(opts *bind.FilterOpts) (*IERC20BridgeRollupUpdatedIterator, error) {

	logs, sub, err := _IERC20Bridge.contract.FilterLogs(opts, "RollupUpdated")
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeRollupUpdatedIterator{contract: _IERC20Bridge.contract, event: "RollupUpdated", logs: logs, sub: sub}, nil
}

// WatchRollupUpdated is a free log subscription operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_IERC20Bridge *IERC20BridgeFilterer) WatchRollupUpdated(opts *bind.WatchOpts, sink chan<- *IERC20BridgeRollupUpdated) (event.Subscription, error) {

	logs, sub, err := _IERC20Bridge.contract.WatchLogs(opts, "RollupUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20BridgeRollupUpdated)
				if err := _IERC20Bridge.contract.UnpackLog(event, "RollupUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupUpdated is a log parse operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_IERC20Bridge *IERC20BridgeFilterer) ParseRollupUpdated(log types.Log) (*IERC20BridgeRollupUpdated, error) {
	event := new(IERC20BridgeRollupUpdated)
	if err := _IERC20Bridge.contract.UnpackLog(event, "RollupUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20BridgeSequencerInboxUpdatedIterator is returned from FilterSequencerInboxUpdated and is used to iterate over the raw logs and unpacked data for SequencerInboxUpdated events raised by the IERC20Bridge contract.
type IERC20BridgeSequencerInboxUpdatedIterator struct {
	Event *IERC20BridgeSequencerInboxUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20BridgeSequencerInboxUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20BridgeSequencerInboxUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20BridgeSequencerInboxUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20BridgeSequencerInboxUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20BridgeSequencerInboxUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20BridgeSequencerInboxUpdated represents a SequencerInboxUpdated event raised by the IERC20Bridge contract.
type IERC20BridgeSequencerInboxUpdated struct {
	NewSequencerInbox common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterSequencerInboxUpdated is a free log retrieval operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_IERC20Bridge *IERC20BridgeFilterer) FilterSequencerInboxUpdated(opts *bind.FilterOpts) (*IERC20BridgeSequencerInboxUpdatedIterator, error) {

	logs, sub, err := _IERC20Bridge.contract.FilterLogs(opts, "SequencerInboxUpdated")
	if err != nil {
		return nil, err
	}
	return &IERC20BridgeSequencerInboxUpdatedIterator{contract: _IERC20Bridge.contract, event: "SequencerInboxUpdated", logs: logs, sub: sub}, nil
}

// WatchSequencerInboxUpdated is a free log subscription operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_IERC20Bridge *IERC20BridgeFilterer) WatchSequencerInboxUpdated(opts *bind.WatchOpts, sink chan<- *IERC20BridgeSequencerInboxUpdated) (event.Subscription, error) {

	logs, sub, err := _IERC20Bridge.contract.WatchLogs(opts, "SequencerInboxUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20BridgeSequencerInboxUpdated)
				if err := _IERC20Bridge.contract.UnpackLog(event, "SequencerInboxUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSequencerInboxUpdated is a log parse operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_IERC20Bridge *IERC20BridgeFilterer) ParseSequencerInboxUpdated(log types.Log) (*IERC20BridgeSequencerInboxUpdated, error) {
	event := new(IERC20BridgeSequencerInboxUpdated)
	if err := _IERC20Bridge.contract.UnpackLog(event, "SequencerInboxUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20InboxMetaData contains all meta data concerning the IERC20Inbox contract.
var IERC20InboxMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowListEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"}],\"name\":\"calculateRetryableSubmissionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenTotalFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createRetryableTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositERC20\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"contractISequencerInbox\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDataSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendContractTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2Message\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2MessageFromOrigin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendUnsignedTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"contractISequencerInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"val\",\"type\":\"bool[]\"}],\"name\":\"setAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowListEnabled\",\"type\":\"bool\"}],\"name\":\"setAllowListEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenTotalFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unsafeCreateRetryableTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IERC20InboxABI is the input ABI used to generate the binding from.
// Deprecated: Use IERC20InboxMetaData.ABI instead.
var IERC20InboxABI = IERC20InboxMetaData.ABI

// IERC20Inbox is an auto generated Go binding around an Ethereum contract.
type IERC20Inbox struct {
	IERC20InboxCaller     // Read-only binding to the contract
	IERC20InboxTransactor // Write-only binding to the contract
	IERC20InboxFilterer   // Log filterer for contract events
}

// IERC20InboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type IERC20InboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20InboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IERC20InboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20InboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IERC20InboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IERC20InboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IERC20InboxSession struct {
	Contract     *IERC20Inbox      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IERC20InboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IERC20InboxCallerSession struct {
	Contract *IERC20InboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// IERC20InboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IERC20InboxTransactorSession struct {
	Contract     *IERC20InboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// IERC20InboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type IERC20InboxRaw struct {
	Contract *IERC20Inbox // Generic contract binding to access the raw methods on
}

// IERC20InboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IERC20InboxCallerRaw struct {
	Contract *IERC20InboxCaller // Generic read-only contract binding to access the raw methods on
}

// IERC20InboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IERC20InboxTransactorRaw struct {
	Contract *IERC20InboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIERC20Inbox creates a new instance of IERC20Inbox, bound to a specific deployed contract.
func NewIERC20Inbox(address common.Address, backend bind.ContractBackend) (*IERC20Inbox, error) {
	contract, err := bindIERC20Inbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IERC20Inbox{IERC20InboxCaller: IERC20InboxCaller{contract: contract}, IERC20InboxTransactor: IERC20InboxTransactor{contract: contract}, IERC20InboxFilterer: IERC20InboxFilterer{contract: contract}}, nil
}

// NewIERC20InboxCaller creates a new read-only instance of IERC20Inbox, bound to a specific deployed contract.
func NewIERC20InboxCaller(address common.Address, caller bind.ContractCaller) (*IERC20InboxCaller, error) {
	contract, err := bindIERC20Inbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20InboxCaller{contract: contract}, nil
}

// NewIERC20InboxTransactor creates a new write-only instance of IERC20Inbox, bound to a specific deployed contract.
func NewIERC20InboxTransactor(address common.Address, transactor bind.ContractTransactor) (*IERC20InboxTransactor, error) {
	contract, err := bindIERC20Inbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IERC20InboxTransactor{contract: contract}, nil
}

// NewIERC20InboxFilterer creates a new log filterer instance of IERC20Inbox, bound to a specific deployed contract.
func NewIERC20InboxFilterer(address common.Address, filterer bind.ContractFilterer) (*IERC20InboxFilterer, error) {
	contract, err := bindIERC20Inbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IERC20InboxFilterer{contract: contract}, nil
}

// bindIERC20Inbox binds a generic wrapper to an already deployed contract.
func bindIERC20Inbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IERC20InboxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Inbox *IERC20InboxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Inbox.Contract.IERC20InboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Inbox *IERC20InboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.IERC20InboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Inbox *IERC20InboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.IERC20InboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IERC20Inbox *IERC20InboxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IERC20Inbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IERC20Inbox *IERC20InboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IERC20Inbox *IERC20InboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.contract.Transact(opts, method, params...)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_IERC20Inbox *IERC20InboxCaller) AllowListEnabled(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _IERC20Inbox.contract.Call(opts, &out, "allowListEnabled")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_IERC20Inbox *IERC20InboxSession) AllowListEnabled() (bool, error) {
	return _IERC20Inbox.Contract.AllowListEnabled(&_IERC20Inbox.CallOpts)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_IERC20Inbox *IERC20InboxCallerSession) AllowListEnabled() (bool, error) {
	return _IERC20Inbox.Contract.AllowListEnabled(&_IERC20Inbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_IERC20Inbox *IERC20InboxCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IERC20Inbox.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_IERC20Inbox *IERC20InboxSession) Bridge() (common.Address, error) {
	return _IERC20Inbox.Contract.Bridge(&_IERC20Inbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_IERC20Inbox *IERC20InboxCallerSession) Bridge() (common.Address, error) {
	return _IERC20Inbox.Contract.Bridge(&_IERC20Inbox.CallOpts)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_IERC20Inbox *IERC20InboxCaller) CalculateRetryableSubmissionFee(opts *bind.CallOpts, dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Inbox.contract.Call(opts, &out, "calculateRetryableSubmissionFee", dataLength, baseFee)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_IERC20Inbox *IERC20InboxSession) CalculateRetryableSubmissionFee(dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	return _IERC20Inbox.Contract.CalculateRetryableSubmissionFee(&_IERC20Inbox.CallOpts, dataLength, baseFee)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_IERC20Inbox *IERC20InboxCallerSession) CalculateRetryableSubmissionFee(dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	return _IERC20Inbox.Contract.CalculateRetryableSubmissionFee(&_IERC20Inbox.CallOpts, dataLength, baseFee)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_IERC20Inbox *IERC20InboxCaller) GetProxyAdmin(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IERC20Inbox.contract.Call(opts, &out, "getProxyAdmin")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_IERC20Inbox *IERC20InboxSession) GetProxyAdmin() (common.Address, error) {
	return _IERC20Inbox.Contract.GetProxyAdmin(&_IERC20Inbox.CallOpts)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_IERC20Inbox *IERC20InboxCallerSession) GetProxyAdmin() (common.Address, error) {
	return _IERC20Inbox.Contract.GetProxyAdmin(&_IERC20Inbox.CallOpts)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address user) view returns(bool)
func (_IERC20Inbox *IERC20InboxCaller) IsAllowed(opts *bind.CallOpts, user common.Address) (bool, error) {
	var out []interface{}
	err := _IERC20Inbox.contract.Call(opts, &out, "isAllowed", user)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address user) view returns(bool)
func (_IERC20Inbox *IERC20InboxSession) IsAllowed(user common.Address) (bool, error) {
	return _IERC20Inbox.Contract.IsAllowed(&_IERC20Inbox.CallOpts, user)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address user) view returns(bool)
func (_IERC20Inbox *IERC20InboxCallerSession) IsAllowed(user common.Address) (bool, error) {
	return _IERC20Inbox.Contract.IsAllowed(&_IERC20Inbox.CallOpts, user)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_IERC20Inbox *IERC20InboxCaller) MaxDataSize(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IERC20Inbox.contract.Call(opts, &out, "maxDataSize")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_IERC20Inbox *IERC20InboxSession) MaxDataSize() (*big.Int, error) {
	return _IERC20Inbox.Contract.MaxDataSize(&_IERC20Inbox.CallOpts)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_IERC20Inbox *IERC20InboxCallerSession) MaxDataSize() (*big.Int, error) {
	return _IERC20Inbox.Contract.MaxDataSize(&_IERC20Inbox.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IERC20Inbox *IERC20InboxCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IERC20Inbox.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IERC20Inbox *IERC20InboxSession) SequencerInbox() (common.Address, error) {
	return _IERC20Inbox.Contract.SequencerInbox(&_IERC20Inbox.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IERC20Inbox *IERC20InboxCallerSession) SequencerInbox() (common.Address, error) {
	return _IERC20Inbox.Contract.SequencerInbox(&_IERC20Inbox.CallOpts)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x549e8426.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactor) CreateRetryableTicket(opts *bind.TransactOpts, to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Inbox.contract.Transact(opts, "createRetryableTicket", to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x549e8426.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_IERC20Inbox *IERC20InboxSession) CreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.CreateRetryableTicket(&_IERC20Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x549e8426.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactorSession) CreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.CreateRetryableTicket(&_IERC20Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// DepositERC20 is a paid mutator transaction binding the contract method 0xb79092fd.
//
// Solidity: function depositERC20(uint256 amount) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactor) DepositERC20(opts *bind.TransactOpts, amount *big.Int) (*types.Transaction, error) {
	return _IERC20Inbox.contract.Transact(opts, "depositERC20", amount)
}

// DepositERC20 is a paid mutator transaction binding the contract method 0xb79092fd.
//
// Solidity: function depositERC20(uint256 amount) returns(uint256)
func (_IERC20Inbox *IERC20InboxSession) DepositERC20(amount *big.Int) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.DepositERC20(&_IERC20Inbox.TransactOpts, amount)
}

// DepositERC20 is a paid mutator transaction binding the contract method 0xb79092fd.
//
// Solidity: function depositERC20(uint256 amount) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactorSession) DepositERC20(amount *big.Int) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.DepositERC20(&_IERC20Inbox.TransactOpts, amount)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_IERC20Inbox *IERC20InboxTransactor) Initialize(opts *bind.TransactOpts, _bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _IERC20Inbox.contract.Transact(opts, "initialize", _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_IERC20Inbox *IERC20InboxSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.Initialize(&_IERC20Inbox.TransactOpts, _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_IERC20Inbox *IERC20InboxTransactorSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.Initialize(&_IERC20Inbox.TransactOpts, _bridge, _sequencerInbox)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_IERC20Inbox *IERC20InboxTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Inbox.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_IERC20Inbox *IERC20InboxSession) Pause() (*types.Transaction, error) {
	return _IERC20Inbox.Contract.Pause(&_IERC20Inbox.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_IERC20Inbox *IERC20InboxTransactorSession) Pause() (*types.Transaction, error) {
	return _IERC20Inbox.Contract.Pause(&_IERC20Inbox.TransactOpts)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactor) SendContractTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Inbox.contract.Transact(opts, "sendContractTransaction", gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_IERC20Inbox *IERC20InboxSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.SendContractTransaction(&_IERC20Inbox.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactorSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.SendContractTransaction(&_IERC20Inbox.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactor) SendL2Message(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _IERC20Inbox.contract.Transact(opts, "sendL2Message", messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_IERC20Inbox *IERC20InboxSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.SendL2Message(&_IERC20Inbox.TransactOpts, messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactorSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.SendL2Message(&_IERC20Inbox.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactor) SendL2MessageFromOrigin(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _IERC20Inbox.contract.Transact(opts, "sendL2MessageFromOrigin", messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_IERC20Inbox *IERC20InboxSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.SendL2MessageFromOrigin(&_IERC20Inbox.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactorSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.SendL2MessageFromOrigin(&_IERC20Inbox.TransactOpts, messageData)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactor) SendUnsignedTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Inbox.contract.Transact(opts, "sendUnsignedTransaction", gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_IERC20Inbox *IERC20InboxSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.SendUnsignedTransaction(&_IERC20Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactorSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.SendUnsignedTransaction(&_IERC20Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_IERC20Inbox *IERC20InboxTransactor) SetAllowList(opts *bind.TransactOpts, user []common.Address, val []bool) (*types.Transaction, error) {
	return _IERC20Inbox.contract.Transact(opts, "setAllowList", user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_IERC20Inbox *IERC20InboxSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.SetAllowList(&_IERC20Inbox.TransactOpts, user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_IERC20Inbox *IERC20InboxTransactorSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.SetAllowList(&_IERC20Inbox.TransactOpts, user, val)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_IERC20Inbox *IERC20InboxTransactor) SetAllowListEnabled(opts *bind.TransactOpts, _allowListEnabled bool) (*types.Transaction, error) {
	return _IERC20Inbox.contract.Transact(opts, "setAllowListEnabled", _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_IERC20Inbox *IERC20InboxSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.SetAllowListEnabled(&_IERC20Inbox.TransactOpts, _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_IERC20Inbox *IERC20InboxTransactorSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.SetAllowListEnabled(&_IERC20Inbox.TransactOpts, _allowListEnabled)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_IERC20Inbox *IERC20InboxTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IERC20Inbox.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_IERC20Inbox *IERC20InboxSession) Unpause() (*types.Transaction, error) {
	return _IERC20Inbox.Contract.Unpause(&_IERC20Inbox.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_IERC20Inbox *IERC20InboxTransactorSession) Unpause() (*types.Transaction, error) {
	return _IERC20Inbox.Contract.Unpause(&_IERC20Inbox.TransactOpts)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0xb9b9a688.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactor) UnsafeCreateRetryableTicket(opts *bind.TransactOpts, to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Inbox.contract.Transact(opts, "unsafeCreateRetryableTicket", to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0xb9b9a688.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_IERC20Inbox *IERC20InboxSession) UnsafeCreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.UnsafeCreateRetryableTicket(&_IERC20Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0xb9b9a688.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, uint256 tokenTotalFeeAmount, bytes data) returns(uint256)
func (_IERC20Inbox *IERC20InboxTransactorSession) UnsafeCreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, tokenTotalFeeAmount *big.Int, data []byte) (*types.Transaction, error) {
	return _IERC20Inbox.Contract.UnsafeCreateRetryableTicket(&_IERC20Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, tokenTotalFeeAmount, data)
}

// IERC20InboxInboxMessageDeliveredIterator is returned from FilterInboxMessageDelivered and is used to iterate over the raw logs and unpacked data for InboxMessageDelivered events raised by the IERC20Inbox contract.
type IERC20InboxInboxMessageDeliveredIterator struct {
	Event *IERC20InboxInboxMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20InboxInboxMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20InboxInboxMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20InboxInboxMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20InboxInboxMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20InboxInboxMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20InboxInboxMessageDelivered represents a InboxMessageDelivered event raised by the IERC20Inbox contract.
type IERC20InboxInboxMessageDelivered struct {
	MessageNum *big.Int
	Data       []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDelivered is a free log retrieval operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_IERC20Inbox *IERC20InboxFilterer) FilterInboxMessageDelivered(opts *bind.FilterOpts, messageNum []*big.Int) (*IERC20InboxInboxMessageDeliveredIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IERC20Inbox.contract.FilterLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &IERC20InboxInboxMessageDeliveredIterator{contract: _IERC20Inbox.contract, event: "InboxMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDelivered is a free log subscription operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_IERC20Inbox *IERC20InboxFilterer) WatchInboxMessageDelivered(opts *bind.WatchOpts, sink chan<- *IERC20InboxInboxMessageDelivered, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IERC20Inbox.contract.WatchLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20InboxInboxMessageDelivered)
				if err := _IERC20Inbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDelivered is a log parse operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_IERC20Inbox *IERC20InboxFilterer) ParseInboxMessageDelivered(log types.Log) (*IERC20InboxInboxMessageDelivered, error) {
	event := new(IERC20InboxInboxMessageDelivered)
	if err := _IERC20Inbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IERC20InboxInboxMessageDeliveredFromOriginIterator is returned from FilterInboxMessageDeliveredFromOrigin and is used to iterate over the raw logs and unpacked data for InboxMessageDeliveredFromOrigin events raised by the IERC20Inbox contract.
type IERC20InboxInboxMessageDeliveredFromOriginIterator struct {
	Event *IERC20InboxInboxMessageDeliveredFromOrigin // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IERC20InboxInboxMessageDeliveredFromOriginIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IERC20InboxInboxMessageDeliveredFromOrigin)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IERC20InboxInboxMessageDeliveredFromOrigin)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IERC20InboxInboxMessageDeliveredFromOriginIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IERC20InboxInboxMessageDeliveredFromOriginIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IERC20InboxInboxMessageDeliveredFromOrigin represents a InboxMessageDeliveredFromOrigin event raised by the IERC20Inbox contract.
type IERC20InboxInboxMessageDeliveredFromOrigin struct {
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDeliveredFromOrigin is a free log retrieval operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_IERC20Inbox *IERC20InboxFilterer) FilterInboxMessageDeliveredFromOrigin(opts *bind.FilterOpts, messageNum []*big.Int) (*IERC20InboxInboxMessageDeliveredFromOriginIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IERC20Inbox.contract.FilterLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &IERC20InboxInboxMessageDeliveredFromOriginIterator{contract: _IERC20Inbox.contract, event: "InboxMessageDeliveredFromOrigin", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDeliveredFromOrigin is a free log subscription operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_IERC20Inbox *IERC20InboxFilterer) WatchInboxMessageDeliveredFromOrigin(opts *bind.WatchOpts, sink chan<- *IERC20InboxInboxMessageDeliveredFromOrigin, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IERC20Inbox.contract.WatchLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IERC20InboxInboxMessageDeliveredFromOrigin)
				if err := _IERC20Inbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDeliveredFromOrigin is a log parse operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_IERC20Inbox *IERC20InboxFilterer) ParseInboxMessageDeliveredFromOrigin(log types.Log) (*IERC20InboxInboxMessageDeliveredFromOrigin, error) {
	event := new(IERC20InboxInboxMessageDeliveredFromOrigin)
	if err := _IERC20Inbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IEthBridgeMetaData contains all meta data concerning the IEthBridge contract.
var IEthBridgeMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"BridgeCallTriggered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"InboxToggle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beforeInboxAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"name\":\"MessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"OutboxToggle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"}],\"name\":\"RollupUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSequencerInbox\",\"type\":\"address\"}],\"name\":\"SequencerInboxUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activeOutbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedDelayedInboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"}],\"name\":\"allowedDelayedInboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowedOutboxList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"outbox\",\"type\":\"address\"}],\"name\":\"allowedOutboxes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"delayedInboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delayedMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"name\":\"enqueueDelayedMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"}],\"name\":\"enqueueSequencerMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seqMessageIndex\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"beforeAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"delayedAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"acc\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"rollup_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sequencerInboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerReportedSubMessageCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setDelayedInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setOutbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"setSequencerInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"batchPoster\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"submitBatchSpendingReport\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"msgNum\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"_rollup\",\"type\":\"address\"}],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IEthBridgeABI is the input ABI used to generate the binding from.
// Deprecated: Use IEthBridgeMetaData.ABI instead.
var IEthBridgeABI = IEthBridgeMetaData.ABI

// IEthBridge is an auto generated Go binding around an Ethereum contract.
type IEthBridge struct {
	IEthBridgeCaller     // Read-only binding to the contract
	IEthBridgeTransactor // Write-only binding to the contract
	IEthBridgeFilterer   // Log filterer for contract events
}

// IEthBridgeCaller is an auto generated read-only Go binding around an Ethereum contract.
type IEthBridgeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IEthBridgeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IEthBridgeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IEthBridgeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IEthBridgeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IEthBridgeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IEthBridgeSession struct {
	Contract     *IEthBridge       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IEthBridgeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IEthBridgeCallerSession struct {
	Contract *IEthBridgeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// IEthBridgeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IEthBridgeTransactorSession struct {
	Contract     *IEthBridgeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IEthBridgeRaw is an auto generated low-level Go binding around an Ethereum contract.
type IEthBridgeRaw struct {
	Contract *IEthBridge // Generic contract binding to access the raw methods on
}

// IEthBridgeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IEthBridgeCallerRaw struct {
	Contract *IEthBridgeCaller // Generic read-only contract binding to access the raw methods on
}

// IEthBridgeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IEthBridgeTransactorRaw struct {
	Contract *IEthBridgeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIEthBridge creates a new instance of IEthBridge, bound to a specific deployed contract.
func NewIEthBridge(address common.Address, backend bind.ContractBackend) (*IEthBridge, error) {
	contract, err := bindIEthBridge(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IEthBridge{IEthBridgeCaller: IEthBridgeCaller{contract: contract}, IEthBridgeTransactor: IEthBridgeTransactor{contract: contract}, IEthBridgeFilterer: IEthBridgeFilterer{contract: contract}}, nil
}

// NewIEthBridgeCaller creates a new read-only instance of IEthBridge, bound to a specific deployed contract.
func NewIEthBridgeCaller(address common.Address, caller bind.ContractCaller) (*IEthBridgeCaller, error) {
	contract, err := bindIEthBridge(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IEthBridgeCaller{contract: contract}, nil
}

// NewIEthBridgeTransactor creates a new write-only instance of IEthBridge, bound to a specific deployed contract.
func NewIEthBridgeTransactor(address common.Address, transactor bind.ContractTransactor) (*IEthBridgeTransactor, error) {
	contract, err := bindIEthBridge(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IEthBridgeTransactor{contract: contract}, nil
}

// NewIEthBridgeFilterer creates a new log filterer instance of IEthBridge, bound to a specific deployed contract.
func NewIEthBridgeFilterer(address common.Address, filterer bind.ContractFilterer) (*IEthBridgeFilterer, error) {
	contract, err := bindIEthBridge(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IEthBridgeFilterer{contract: contract}, nil
}

// bindIEthBridge binds a generic wrapper to an already deployed contract.
func bindIEthBridge(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IEthBridgeMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IEthBridge *IEthBridgeRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IEthBridge.Contract.IEthBridgeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IEthBridge *IEthBridgeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IEthBridge.Contract.IEthBridgeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IEthBridge *IEthBridgeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IEthBridge.Contract.IEthBridgeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IEthBridge *IEthBridgeCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IEthBridge.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IEthBridge *IEthBridgeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IEthBridge.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IEthBridge *IEthBridgeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IEthBridge.Contract.contract.Transact(opts, method, params...)
}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_IEthBridge *IEthBridgeCaller) ActiveOutbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IEthBridge.contract.Call(opts, &out, "activeOutbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_IEthBridge *IEthBridgeSession) ActiveOutbox() (common.Address, error) {
	return _IEthBridge.Contract.ActiveOutbox(&_IEthBridge.CallOpts)
}

// ActiveOutbox is a free data retrieval call binding the contract method 0xab5d8943.
//
// Solidity: function activeOutbox() view returns(address)
func (_IEthBridge *IEthBridgeCallerSession) ActiveOutbox() (common.Address, error) {
	return _IEthBridge.Contract.ActiveOutbox(&_IEthBridge.CallOpts)
}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_IEthBridge *IEthBridgeCaller) AllowedDelayedInboxes(opts *bind.CallOpts, inbox common.Address) (bool, error) {
	var out []interface{}
	err := _IEthBridge.contract.Call(opts, &out, "allowedDelayedInboxes", inbox)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_IEthBridge *IEthBridgeSession) AllowedDelayedInboxes(inbox common.Address) (bool, error) {
	return _IEthBridge.Contract.AllowedDelayedInboxes(&_IEthBridge.CallOpts, inbox)
}

// AllowedDelayedInboxes is a free data retrieval call binding the contract method 0xae60bd13.
//
// Solidity: function allowedDelayedInboxes(address inbox) view returns(bool)
func (_IEthBridge *IEthBridgeCallerSession) AllowedDelayedInboxes(inbox common.Address) (bool, error) {
	return _IEthBridge.Contract.AllowedDelayedInboxes(&_IEthBridge.CallOpts, inbox)
}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_IEthBridge *IEthBridgeCaller) AllowedOutboxes(opts *bind.CallOpts, outbox common.Address) (bool, error) {
	var out []interface{}
	err := _IEthBridge.contract.Call(opts, &out, "allowedOutboxes", outbox)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_IEthBridge *IEthBridgeSession) AllowedOutboxes(outbox common.Address) (bool, error) {
	return _IEthBridge.Contract.AllowedOutboxes(&_IEthBridge.CallOpts, outbox)
}

// AllowedOutboxes is a free data retrieval call binding the contract method 0x413b35bd.
//
// Solidity: function allowedOutboxes(address outbox) view returns(bool)
func (_IEthBridge *IEthBridgeCallerSession) AllowedOutboxes(outbox common.Address) (bool, error) {
	return _IEthBridge.Contract.AllowedOutboxes(&_IEthBridge.CallOpts, outbox)
}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_IEthBridge *IEthBridgeCaller) DelayedInboxAccs(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _IEthBridge.contract.Call(opts, &out, "delayedInboxAccs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_IEthBridge *IEthBridgeSession) DelayedInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _IEthBridge.Contract.DelayedInboxAccs(&_IEthBridge.CallOpts, arg0)
}

// DelayedInboxAccs is a free data retrieval call binding the contract method 0xd5719dc2.
//
// Solidity: function delayedInboxAccs(uint256 ) view returns(bytes32)
func (_IEthBridge *IEthBridgeCallerSession) DelayedInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _IEthBridge.Contract.DelayedInboxAccs(&_IEthBridge.CallOpts, arg0)
}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_IEthBridge *IEthBridgeCaller) DelayedMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IEthBridge.contract.Call(opts, &out, "delayedMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_IEthBridge *IEthBridgeSession) DelayedMessageCount() (*big.Int, error) {
	return _IEthBridge.Contract.DelayedMessageCount(&_IEthBridge.CallOpts)
}

// DelayedMessageCount is a free data retrieval call binding the contract method 0xeca067ad.
//
// Solidity: function delayedMessageCount() view returns(uint256)
func (_IEthBridge *IEthBridgeCallerSession) DelayedMessageCount() (*big.Int, error) {
	return _IEthBridge.Contract.DelayedMessageCount(&_IEthBridge.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_IEthBridge *IEthBridgeCaller) Rollup(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IEthBridge.contract.Call(opts, &out, "rollup")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_IEthBridge *IEthBridgeSession) Rollup() (common.Address, error) {
	return _IEthBridge.Contract.Rollup(&_IEthBridge.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_IEthBridge *IEthBridgeCallerSession) Rollup() (common.Address, error) {
	return _IEthBridge.Contract.Rollup(&_IEthBridge.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IEthBridge *IEthBridgeCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IEthBridge.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IEthBridge *IEthBridgeSession) SequencerInbox() (common.Address, error) {
	return _IEthBridge.Contract.SequencerInbox(&_IEthBridge.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IEthBridge *IEthBridgeCallerSession) SequencerInbox() (common.Address, error) {
	return _IEthBridge.Contract.SequencerInbox(&_IEthBridge.CallOpts)
}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_IEthBridge *IEthBridgeCaller) SequencerInboxAccs(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _IEthBridge.contract.Call(opts, &out, "sequencerInboxAccs", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_IEthBridge *IEthBridgeSession) SequencerInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _IEthBridge.Contract.SequencerInboxAccs(&_IEthBridge.CallOpts, arg0)
}

// SequencerInboxAccs is a free data retrieval call binding the contract method 0x16bf5579.
//
// Solidity: function sequencerInboxAccs(uint256 ) view returns(bytes32)
func (_IEthBridge *IEthBridgeCallerSession) SequencerInboxAccs(arg0 *big.Int) ([32]byte, error) {
	return _IEthBridge.Contract.SequencerInboxAccs(&_IEthBridge.CallOpts, arg0)
}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_IEthBridge *IEthBridgeCaller) SequencerMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IEthBridge.contract.Call(opts, &out, "sequencerMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_IEthBridge *IEthBridgeSession) SequencerMessageCount() (*big.Int, error) {
	return _IEthBridge.Contract.SequencerMessageCount(&_IEthBridge.CallOpts)
}

// SequencerMessageCount is a free data retrieval call binding the contract method 0x0084120c.
//
// Solidity: function sequencerMessageCount() view returns(uint256)
func (_IEthBridge *IEthBridgeCallerSession) SequencerMessageCount() (*big.Int, error) {
	return _IEthBridge.Contract.SequencerMessageCount(&_IEthBridge.CallOpts)
}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_IEthBridge *IEthBridgeCaller) SequencerReportedSubMessageCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IEthBridge.contract.Call(opts, &out, "sequencerReportedSubMessageCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_IEthBridge *IEthBridgeSession) SequencerReportedSubMessageCount() (*big.Int, error) {
	return _IEthBridge.Contract.SequencerReportedSubMessageCount(&_IEthBridge.CallOpts)
}

// SequencerReportedSubMessageCount is a free data retrieval call binding the contract method 0x5fca4a16.
//
// Solidity: function sequencerReportedSubMessageCount() view returns(uint256)
func (_IEthBridge *IEthBridgeCallerSession) SequencerReportedSubMessageCount() (*big.Int, error) {
	return _IEthBridge.Contract.SequencerReportedSubMessageCount(&_IEthBridge.CallOpts)
}

// AllowedDelayedInboxList is a paid mutator transaction binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) returns(address)
func (_IEthBridge *IEthBridgeTransactor) AllowedDelayedInboxList(opts *bind.TransactOpts, arg0 *big.Int) (*types.Transaction, error) {
	return _IEthBridge.contract.Transact(opts, "allowedDelayedInboxList", arg0)
}

// AllowedDelayedInboxList is a paid mutator transaction binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) returns(address)
func (_IEthBridge *IEthBridgeSession) AllowedDelayedInboxList(arg0 *big.Int) (*types.Transaction, error) {
	return _IEthBridge.Contract.AllowedDelayedInboxList(&_IEthBridge.TransactOpts, arg0)
}

// AllowedDelayedInboxList is a paid mutator transaction binding the contract method 0xe76f5c8d.
//
// Solidity: function allowedDelayedInboxList(uint256 ) returns(address)
func (_IEthBridge *IEthBridgeTransactorSession) AllowedDelayedInboxList(arg0 *big.Int) (*types.Transaction, error) {
	return _IEthBridge.Contract.AllowedDelayedInboxList(&_IEthBridge.TransactOpts, arg0)
}

// AllowedOutboxList is a paid mutator transaction binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) returns(address)
func (_IEthBridge *IEthBridgeTransactor) AllowedOutboxList(opts *bind.TransactOpts, arg0 *big.Int) (*types.Transaction, error) {
	return _IEthBridge.contract.Transact(opts, "allowedOutboxList", arg0)
}

// AllowedOutboxList is a paid mutator transaction binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) returns(address)
func (_IEthBridge *IEthBridgeSession) AllowedOutboxList(arg0 *big.Int) (*types.Transaction, error) {
	return _IEthBridge.Contract.AllowedOutboxList(&_IEthBridge.TransactOpts, arg0)
}

// AllowedOutboxList is a paid mutator transaction binding the contract method 0x945e1147.
//
// Solidity: function allowedOutboxList(uint256 ) returns(address)
func (_IEthBridge *IEthBridgeTransactorSession) AllowedOutboxList(arg0 *big.Int) (*types.Transaction, error) {
	return _IEthBridge.Contract.AllowedOutboxList(&_IEthBridge.TransactOpts, arg0)
}

// EnqueueDelayedMessage is a paid mutator transaction binding the contract method 0x8db5993b.
//
// Solidity: function enqueueDelayedMessage(uint8 kind, address sender, bytes32 messageDataHash) payable returns(uint256)
func (_IEthBridge *IEthBridgeTransactor) EnqueueDelayedMessage(opts *bind.TransactOpts, kind uint8, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _IEthBridge.contract.Transact(opts, "enqueueDelayedMessage", kind, sender, messageDataHash)
}

// EnqueueDelayedMessage is a paid mutator transaction binding the contract method 0x8db5993b.
//
// Solidity: function enqueueDelayedMessage(uint8 kind, address sender, bytes32 messageDataHash) payable returns(uint256)
func (_IEthBridge *IEthBridgeSession) EnqueueDelayedMessage(kind uint8, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _IEthBridge.Contract.EnqueueDelayedMessage(&_IEthBridge.TransactOpts, kind, sender, messageDataHash)
}

// EnqueueDelayedMessage is a paid mutator transaction binding the contract method 0x8db5993b.
//
// Solidity: function enqueueDelayedMessage(uint8 kind, address sender, bytes32 messageDataHash) payable returns(uint256)
func (_IEthBridge *IEthBridgeTransactorSession) EnqueueDelayedMessage(kind uint8, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _IEthBridge.Contract.EnqueueDelayedMessage(&_IEthBridge.TransactOpts, kind, sender, messageDataHash)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_IEthBridge *IEthBridgeTransactor) EnqueueSequencerMessage(opts *bind.TransactOpts, dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _IEthBridge.contract.Transact(opts, "enqueueSequencerMessage", dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_IEthBridge *IEthBridgeSession) EnqueueSequencerMessage(dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _IEthBridge.Contract.EnqueueSequencerMessage(&_IEthBridge.TransactOpts, dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// EnqueueSequencerMessage is a paid mutator transaction binding the contract method 0x86598a56.
//
// Solidity: function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead, uint256 prevMessageCount, uint256 newMessageCount) returns(uint256 seqMessageIndex, bytes32 beforeAcc, bytes32 delayedAcc, bytes32 acc)
func (_IEthBridge *IEthBridgeTransactorSession) EnqueueSequencerMessage(dataHash [32]byte, afterDelayedMessagesRead *big.Int, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _IEthBridge.Contract.EnqueueSequencerMessage(&_IEthBridge.TransactOpts, dataHash, afterDelayedMessagesRead, prevMessageCount, newMessageCount)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_IEthBridge *IEthBridgeTransactor) ExecuteCall(opts *bind.TransactOpts, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IEthBridge.contract.Transact(opts, "executeCall", to, value, data)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_IEthBridge *IEthBridgeSession) ExecuteCall(to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IEthBridge.Contract.ExecuteCall(&_IEthBridge.TransactOpts, to, value, data)
}

// ExecuteCall is a paid mutator transaction binding the contract method 0x9e5d4c49.
//
// Solidity: function executeCall(address to, uint256 value, bytes data) returns(bool success, bytes returnData)
func (_IEthBridge *IEthBridgeTransactorSession) ExecuteCall(to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IEthBridge.Contract.ExecuteCall(&_IEthBridge.TransactOpts, to, value, data)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address rollup_) returns()
func (_IEthBridge *IEthBridgeTransactor) Initialize(opts *bind.TransactOpts, rollup_ common.Address) (*types.Transaction, error) {
	return _IEthBridge.contract.Transact(opts, "initialize", rollup_)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address rollup_) returns()
func (_IEthBridge *IEthBridgeSession) Initialize(rollup_ common.Address) (*types.Transaction, error) {
	return _IEthBridge.Contract.Initialize(&_IEthBridge.TransactOpts, rollup_)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address rollup_) returns()
func (_IEthBridge *IEthBridgeTransactorSession) Initialize(rollup_ common.Address) (*types.Transaction, error) {
	return _IEthBridge.Contract.Initialize(&_IEthBridge.TransactOpts, rollup_)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_IEthBridge *IEthBridgeTransactor) SetDelayedInbox(opts *bind.TransactOpts, inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IEthBridge.contract.Transact(opts, "setDelayedInbox", inbox, enabled)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_IEthBridge *IEthBridgeSession) SetDelayedInbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IEthBridge.Contract.SetDelayedInbox(&_IEthBridge.TransactOpts, inbox, enabled)
}

// SetDelayedInbox is a paid mutator transaction binding the contract method 0x47fb24c5.
//
// Solidity: function setDelayedInbox(address inbox, bool enabled) returns()
func (_IEthBridge *IEthBridgeTransactorSession) SetDelayedInbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IEthBridge.Contract.SetDelayedInbox(&_IEthBridge.TransactOpts, inbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address inbox, bool enabled) returns()
func (_IEthBridge *IEthBridgeTransactor) SetOutbox(opts *bind.TransactOpts, inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IEthBridge.contract.Transact(opts, "setOutbox", inbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address inbox, bool enabled) returns()
func (_IEthBridge *IEthBridgeSession) SetOutbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IEthBridge.Contract.SetOutbox(&_IEthBridge.TransactOpts, inbox, enabled)
}

// SetOutbox is a paid mutator transaction binding the contract method 0xcee3d728.
//
// Solidity: function setOutbox(address inbox, bool enabled) returns()
func (_IEthBridge *IEthBridgeTransactorSession) SetOutbox(inbox common.Address, enabled bool) (*types.Transaction, error) {
	return _IEthBridge.Contract.SetOutbox(&_IEthBridge.TransactOpts, inbox, enabled)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_IEthBridge *IEthBridgeTransactor) SetSequencerInbox(opts *bind.TransactOpts, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _IEthBridge.contract.Transact(opts, "setSequencerInbox", _sequencerInbox)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_IEthBridge *IEthBridgeSession) SetSequencerInbox(_sequencerInbox common.Address) (*types.Transaction, error) {
	return _IEthBridge.Contract.SetSequencerInbox(&_IEthBridge.TransactOpts, _sequencerInbox)
}

// SetSequencerInbox is a paid mutator transaction binding the contract method 0x4f61f850.
//
// Solidity: function setSequencerInbox(address _sequencerInbox) returns()
func (_IEthBridge *IEthBridgeTransactorSession) SetSequencerInbox(_sequencerInbox common.Address) (*types.Transaction, error) {
	return _IEthBridge.Contract.SetSequencerInbox(&_IEthBridge.TransactOpts, _sequencerInbox)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address batchPoster, bytes32 dataHash) returns(uint256 msgNum)
func (_IEthBridge *IEthBridgeTransactor) SubmitBatchSpendingReport(opts *bind.TransactOpts, batchPoster common.Address, dataHash [32]byte) (*types.Transaction, error) {
	return _IEthBridge.contract.Transact(opts, "submitBatchSpendingReport", batchPoster, dataHash)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address batchPoster, bytes32 dataHash) returns(uint256 msgNum)
func (_IEthBridge *IEthBridgeSession) SubmitBatchSpendingReport(batchPoster common.Address, dataHash [32]byte) (*types.Transaction, error) {
	return _IEthBridge.Contract.SubmitBatchSpendingReport(&_IEthBridge.TransactOpts, batchPoster, dataHash)
}

// SubmitBatchSpendingReport is a paid mutator transaction binding the contract method 0x7a88b107.
//
// Solidity: function submitBatchSpendingReport(address batchPoster, bytes32 dataHash) returns(uint256 msgNum)
func (_IEthBridge *IEthBridgeTransactorSession) SubmitBatchSpendingReport(batchPoster common.Address, dataHash [32]byte) (*types.Transaction, error) {
	return _IEthBridge.Contract.SubmitBatchSpendingReport(&_IEthBridge.TransactOpts, batchPoster, dataHash)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_IEthBridge *IEthBridgeTransactor) UpdateRollupAddress(opts *bind.TransactOpts, _rollup common.Address) (*types.Transaction, error) {
	return _IEthBridge.contract.Transact(opts, "updateRollupAddress", _rollup)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_IEthBridge *IEthBridgeSession) UpdateRollupAddress(_rollup common.Address) (*types.Transaction, error) {
	return _IEthBridge.Contract.UpdateRollupAddress(&_IEthBridge.TransactOpts, _rollup)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x919cc706.
//
// Solidity: function updateRollupAddress(address _rollup) returns()
func (_IEthBridge *IEthBridgeTransactorSession) UpdateRollupAddress(_rollup common.Address) (*types.Transaction, error) {
	return _IEthBridge.Contract.UpdateRollupAddress(&_IEthBridge.TransactOpts, _rollup)
}

// IEthBridgeBridgeCallTriggeredIterator is returned from FilterBridgeCallTriggered and is used to iterate over the raw logs and unpacked data for BridgeCallTriggered events raised by the IEthBridge contract.
type IEthBridgeBridgeCallTriggeredIterator struct {
	Event *IEthBridgeBridgeCallTriggered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IEthBridgeBridgeCallTriggeredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IEthBridgeBridgeCallTriggered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IEthBridgeBridgeCallTriggered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IEthBridgeBridgeCallTriggeredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IEthBridgeBridgeCallTriggeredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IEthBridgeBridgeCallTriggered represents a BridgeCallTriggered event raised by the IEthBridge contract.
type IEthBridgeBridgeCallTriggered struct {
	Outbox common.Address
	To     common.Address
	Value  *big.Int
	Data   []byte
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterBridgeCallTriggered is a free log retrieval operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_IEthBridge *IEthBridgeFilterer) FilterBridgeCallTriggered(opts *bind.FilterOpts, outbox []common.Address, to []common.Address) (*IEthBridgeBridgeCallTriggeredIterator, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IEthBridge.contract.FilterLogs(opts, "BridgeCallTriggered", outboxRule, toRule)
	if err != nil {
		return nil, err
	}
	return &IEthBridgeBridgeCallTriggeredIterator{contract: _IEthBridge.contract, event: "BridgeCallTriggered", logs: logs, sub: sub}, nil
}

// WatchBridgeCallTriggered is a free log subscription operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_IEthBridge *IEthBridgeFilterer) WatchBridgeCallTriggered(opts *bind.WatchOpts, sink chan<- *IEthBridgeBridgeCallTriggered, outbox []common.Address, to []common.Address) (event.Subscription, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _IEthBridge.contract.WatchLogs(opts, "BridgeCallTriggered", outboxRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IEthBridgeBridgeCallTriggered)
				if err := _IEthBridge.contract.UnpackLog(event, "BridgeCallTriggered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBridgeCallTriggered is a log parse operation binding the contract event 0x2d9d115ef3e4a606d698913b1eae831a3cdfe20d9a83d48007b0526749c3d466.
//
// Solidity: event BridgeCallTriggered(address indexed outbox, address indexed to, uint256 value, bytes data)
func (_IEthBridge *IEthBridgeFilterer) ParseBridgeCallTriggered(log types.Log) (*IEthBridgeBridgeCallTriggered, error) {
	event := new(IEthBridgeBridgeCallTriggered)
	if err := _IEthBridge.contract.UnpackLog(event, "BridgeCallTriggered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IEthBridgeInboxToggleIterator is returned from FilterInboxToggle and is used to iterate over the raw logs and unpacked data for InboxToggle events raised by the IEthBridge contract.
type IEthBridgeInboxToggleIterator struct {
	Event *IEthBridgeInboxToggle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IEthBridgeInboxToggleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IEthBridgeInboxToggle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IEthBridgeInboxToggle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IEthBridgeInboxToggleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IEthBridgeInboxToggleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IEthBridgeInboxToggle represents a InboxToggle event raised by the IEthBridge contract.
type IEthBridgeInboxToggle struct {
	Inbox   common.Address
	Enabled bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInboxToggle is a free log retrieval operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_IEthBridge *IEthBridgeFilterer) FilterInboxToggle(opts *bind.FilterOpts, inbox []common.Address) (*IEthBridgeInboxToggleIterator, error) {

	var inboxRule []interface{}
	for _, inboxItem := range inbox {
		inboxRule = append(inboxRule, inboxItem)
	}

	logs, sub, err := _IEthBridge.contract.FilterLogs(opts, "InboxToggle", inboxRule)
	if err != nil {
		return nil, err
	}
	return &IEthBridgeInboxToggleIterator{contract: _IEthBridge.contract, event: "InboxToggle", logs: logs, sub: sub}, nil
}

// WatchInboxToggle is a free log subscription operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_IEthBridge *IEthBridgeFilterer) WatchInboxToggle(opts *bind.WatchOpts, sink chan<- *IEthBridgeInboxToggle, inbox []common.Address) (event.Subscription, error) {

	var inboxRule []interface{}
	for _, inboxItem := range inbox {
		inboxRule = append(inboxRule, inboxItem)
	}

	logs, sub, err := _IEthBridge.contract.WatchLogs(opts, "InboxToggle", inboxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IEthBridgeInboxToggle)
				if err := _IEthBridge.contract.UnpackLog(event, "InboxToggle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxToggle is a log parse operation binding the contract event 0x6675ce8882cb71637de5903a193d218cc0544be9c0650cb83e0955f6aa2bf521.
//
// Solidity: event InboxToggle(address indexed inbox, bool enabled)
func (_IEthBridge *IEthBridgeFilterer) ParseInboxToggle(log types.Log) (*IEthBridgeInboxToggle, error) {
	event := new(IEthBridgeInboxToggle)
	if err := _IEthBridge.contract.UnpackLog(event, "InboxToggle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IEthBridgeMessageDeliveredIterator is returned from FilterMessageDelivered and is used to iterate over the raw logs and unpacked data for MessageDelivered events raised by the IEthBridge contract.
type IEthBridgeMessageDeliveredIterator struct {
	Event *IEthBridgeMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IEthBridgeMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IEthBridgeMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IEthBridgeMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IEthBridgeMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IEthBridgeMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IEthBridgeMessageDelivered represents a MessageDelivered event raised by the IEthBridge contract.
type IEthBridgeMessageDelivered struct {
	MessageIndex    *big.Int
	BeforeInboxAcc  [32]byte
	Inbox           common.Address
	Kind            uint8
	Sender          common.Address
	MessageDataHash [32]byte
	BaseFeeL1       *big.Int
	Timestamp       uint64
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterMessageDelivered is a free log retrieval operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_IEthBridge *IEthBridgeFilterer) FilterMessageDelivered(opts *bind.FilterOpts, messageIndex []*big.Int, beforeInboxAcc [][32]byte) (*IEthBridgeMessageDeliveredIterator, error) {

	var messageIndexRule []interface{}
	for _, messageIndexItem := range messageIndex {
		messageIndexRule = append(messageIndexRule, messageIndexItem)
	}
	var beforeInboxAccRule []interface{}
	for _, beforeInboxAccItem := range beforeInboxAcc {
		beforeInboxAccRule = append(beforeInboxAccRule, beforeInboxAccItem)
	}

	logs, sub, err := _IEthBridge.contract.FilterLogs(opts, "MessageDelivered", messageIndexRule, beforeInboxAccRule)
	if err != nil {
		return nil, err
	}
	return &IEthBridgeMessageDeliveredIterator{contract: _IEthBridge.contract, event: "MessageDelivered", logs: logs, sub: sub}, nil
}

// WatchMessageDelivered is a free log subscription operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_IEthBridge *IEthBridgeFilterer) WatchMessageDelivered(opts *bind.WatchOpts, sink chan<- *IEthBridgeMessageDelivered, messageIndex []*big.Int, beforeInboxAcc [][32]byte) (event.Subscription, error) {

	var messageIndexRule []interface{}
	for _, messageIndexItem := range messageIndex {
		messageIndexRule = append(messageIndexRule, messageIndexItem)
	}
	var beforeInboxAccRule []interface{}
	for _, beforeInboxAccItem := range beforeInboxAcc {
		beforeInboxAccRule = append(beforeInboxAccRule, beforeInboxAccItem)
	}

	logs, sub, err := _IEthBridge.contract.WatchLogs(opts, "MessageDelivered", messageIndexRule, beforeInboxAccRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IEthBridgeMessageDelivered)
				if err := _IEthBridge.contract.UnpackLog(event, "MessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMessageDelivered is a log parse operation binding the contract event 0x5e3c1311ea442664e8b1611bfabef659120ea7a0a2cfc0667700bebc69cbffe1.
//
// Solidity: event MessageDelivered(uint256 indexed messageIndex, bytes32 indexed beforeInboxAcc, address inbox, uint8 kind, address sender, bytes32 messageDataHash, uint256 baseFeeL1, uint64 timestamp)
func (_IEthBridge *IEthBridgeFilterer) ParseMessageDelivered(log types.Log) (*IEthBridgeMessageDelivered, error) {
	event := new(IEthBridgeMessageDelivered)
	if err := _IEthBridge.contract.UnpackLog(event, "MessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IEthBridgeOutboxToggleIterator is returned from FilterOutboxToggle and is used to iterate over the raw logs and unpacked data for OutboxToggle events raised by the IEthBridge contract.
type IEthBridgeOutboxToggleIterator struct {
	Event *IEthBridgeOutboxToggle // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IEthBridgeOutboxToggleIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IEthBridgeOutboxToggle)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IEthBridgeOutboxToggle)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IEthBridgeOutboxToggleIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IEthBridgeOutboxToggleIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IEthBridgeOutboxToggle represents a OutboxToggle event raised by the IEthBridge contract.
type IEthBridgeOutboxToggle struct {
	Outbox  common.Address
	Enabled bool
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterOutboxToggle is a free log retrieval operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_IEthBridge *IEthBridgeFilterer) FilterOutboxToggle(opts *bind.FilterOpts, outbox []common.Address) (*IEthBridgeOutboxToggleIterator, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}

	logs, sub, err := _IEthBridge.contract.FilterLogs(opts, "OutboxToggle", outboxRule)
	if err != nil {
		return nil, err
	}
	return &IEthBridgeOutboxToggleIterator{contract: _IEthBridge.contract, event: "OutboxToggle", logs: logs, sub: sub}, nil
}

// WatchOutboxToggle is a free log subscription operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_IEthBridge *IEthBridgeFilterer) WatchOutboxToggle(opts *bind.WatchOpts, sink chan<- *IEthBridgeOutboxToggle, outbox []common.Address) (event.Subscription, error) {

	var outboxRule []interface{}
	for _, outboxItem := range outbox {
		outboxRule = append(outboxRule, outboxItem)
	}

	logs, sub, err := _IEthBridge.contract.WatchLogs(opts, "OutboxToggle", outboxRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IEthBridgeOutboxToggle)
				if err := _IEthBridge.contract.UnpackLog(event, "OutboxToggle", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOutboxToggle is a log parse operation binding the contract event 0x49477e7356dbcb654ab85d7534b50126772d938130d1350e23e2540370c8dffa.
//
// Solidity: event OutboxToggle(address indexed outbox, bool enabled)
func (_IEthBridge *IEthBridgeFilterer) ParseOutboxToggle(log types.Log) (*IEthBridgeOutboxToggle, error) {
	event := new(IEthBridgeOutboxToggle)
	if err := _IEthBridge.contract.UnpackLog(event, "OutboxToggle", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IEthBridgeRollupUpdatedIterator is returned from FilterRollupUpdated and is used to iterate over the raw logs and unpacked data for RollupUpdated events raised by the IEthBridge contract.
type IEthBridgeRollupUpdatedIterator struct {
	Event *IEthBridgeRollupUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IEthBridgeRollupUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IEthBridgeRollupUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IEthBridgeRollupUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IEthBridgeRollupUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IEthBridgeRollupUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IEthBridgeRollupUpdated represents a RollupUpdated event raised by the IEthBridge contract.
type IEthBridgeRollupUpdated struct {
	Rollup common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRollupUpdated is a free log retrieval operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_IEthBridge *IEthBridgeFilterer) FilterRollupUpdated(opts *bind.FilterOpts) (*IEthBridgeRollupUpdatedIterator, error) {

	logs, sub, err := _IEthBridge.contract.FilterLogs(opts, "RollupUpdated")
	if err != nil {
		return nil, err
	}
	return &IEthBridgeRollupUpdatedIterator{contract: _IEthBridge.contract, event: "RollupUpdated", logs: logs, sub: sub}, nil
}

// WatchRollupUpdated is a free log subscription operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_IEthBridge *IEthBridgeFilterer) WatchRollupUpdated(opts *bind.WatchOpts, sink chan<- *IEthBridgeRollupUpdated) (event.Subscription, error) {

	logs, sub, err := _IEthBridge.contract.WatchLogs(opts, "RollupUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IEthBridgeRollupUpdated)
				if err := _IEthBridge.contract.UnpackLog(event, "RollupUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupUpdated is a log parse operation binding the contract event 0xae1f5aa15f6ff844896347ceca2a3c24c8d3a27785efdeacd581a0a95172784a.
//
// Solidity: event RollupUpdated(address rollup)
func (_IEthBridge *IEthBridgeFilterer) ParseRollupUpdated(log types.Log) (*IEthBridgeRollupUpdated, error) {
	event := new(IEthBridgeRollupUpdated)
	if err := _IEthBridge.contract.UnpackLog(event, "RollupUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IEthBridgeSequencerInboxUpdatedIterator is returned from FilterSequencerInboxUpdated and is used to iterate over the raw logs and unpacked data for SequencerInboxUpdated events raised by the IEthBridge contract.
type IEthBridgeSequencerInboxUpdatedIterator struct {
	Event *IEthBridgeSequencerInboxUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IEthBridgeSequencerInboxUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IEthBridgeSequencerInboxUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IEthBridgeSequencerInboxUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IEthBridgeSequencerInboxUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IEthBridgeSequencerInboxUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IEthBridgeSequencerInboxUpdated represents a SequencerInboxUpdated event raised by the IEthBridge contract.
type IEthBridgeSequencerInboxUpdated struct {
	NewSequencerInbox common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterSequencerInboxUpdated is a free log retrieval operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_IEthBridge *IEthBridgeFilterer) FilterSequencerInboxUpdated(opts *bind.FilterOpts) (*IEthBridgeSequencerInboxUpdatedIterator, error) {

	logs, sub, err := _IEthBridge.contract.FilterLogs(opts, "SequencerInboxUpdated")
	if err != nil {
		return nil, err
	}
	return &IEthBridgeSequencerInboxUpdatedIterator{contract: _IEthBridge.contract, event: "SequencerInboxUpdated", logs: logs, sub: sub}, nil
}

// WatchSequencerInboxUpdated is a free log subscription operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_IEthBridge *IEthBridgeFilterer) WatchSequencerInboxUpdated(opts *bind.WatchOpts, sink chan<- *IEthBridgeSequencerInboxUpdated) (event.Subscription, error) {

	logs, sub, err := _IEthBridge.contract.WatchLogs(opts, "SequencerInboxUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IEthBridgeSequencerInboxUpdated)
				if err := _IEthBridge.contract.UnpackLog(event, "SequencerInboxUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSequencerInboxUpdated is a log parse operation binding the contract event 0x8c1e6003ed33ca6748d4ad3dd4ecc949065c89dceb31fdf546a5289202763c6a.
//
// Solidity: event SequencerInboxUpdated(address newSequencerInbox)
func (_IEthBridge *IEthBridgeFilterer) ParseSequencerInboxUpdated(log types.Log) (*IEthBridgeSequencerInboxUpdated, error) {
	event := new(IEthBridgeSequencerInboxUpdated)
	if err := _IEthBridge.contract.UnpackLog(event, "SequencerInboxUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IFeeTokenPricerMetaData contains all meta data concerning the IFeeTokenPricer contract.
var IFeeTokenPricerMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"getExchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IFeeTokenPricerABI is the input ABI used to generate the binding from.
// Deprecated: Use IFeeTokenPricerMetaData.ABI instead.
var IFeeTokenPricerABI = IFeeTokenPricerMetaData.ABI

// IFeeTokenPricer is an auto generated Go binding around an Ethereum contract.
type IFeeTokenPricer struct {
	IFeeTokenPricerCaller     // Read-only binding to the contract
	IFeeTokenPricerTransactor // Write-only binding to the contract
	IFeeTokenPricerFilterer   // Log filterer for contract events
}

// IFeeTokenPricerCaller is an auto generated read-only Go binding around an Ethereum contract.
type IFeeTokenPricerCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFeeTokenPricerTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IFeeTokenPricerTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFeeTokenPricerFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IFeeTokenPricerFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IFeeTokenPricerSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IFeeTokenPricerSession struct {
	Contract     *IFeeTokenPricer  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IFeeTokenPricerCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IFeeTokenPricerCallerSession struct {
	Contract *IFeeTokenPricerCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// IFeeTokenPricerTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IFeeTokenPricerTransactorSession struct {
	Contract     *IFeeTokenPricerTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// IFeeTokenPricerRaw is an auto generated low-level Go binding around an Ethereum contract.
type IFeeTokenPricerRaw struct {
	Contract *IFeeTokenPricer // Generic contract binding to access the raw methods on
}

// IFeeTokenPricerCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IFeeTokenPricerCallerRaw struct {
	Contract *IFeeTokenPricerCaller // Generic read-only contract binding to access the raw methods on
}

// IFeeTokenPricerTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IFeeTokenPricerTransactorRaw struct {
	Contract *IFeeTokenPricerTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIFeeTokenPricer creates a new instance of IFeeTokenPricer, bound to a specific deployed contract.
func NewIFeeTokenPricer(address common.Address, backend bind.ContractBackend) (*IFeeTokenPricer, error) {
	contract, err := bindIFeeTokenPricer(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IFeeTokenPricer{IFeeTokenPricerCaller: IFeeTokenPricerCaller{contract: contract}, IFeeTokenPricerTransactor: IFeeTokenPricerTransactor{contract: contract}, IFeeTokenPricerFilterer: IFeeTokenPricerFilterer{contract: contract}}, nil
}

// NewIFeeTokenPricerCaller creates a new read-only instance of IFeeTokenPricer, bound to a specific deployed contract.
func NewIFeeTokenPricerCaller(address common.Address, caller bind.ContractCaller) (*IFeeTokenPricerCaller, error) {
	contract, err := bindIFeeTokenPricer(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IFeeTokenPricerCaller{contract: contract}, nil
}

// NewIFeeTokenPricerTransactor creates a new write-only instance of IFeeTokenPricer, bound to a specific deployed contract.
func NewIFeeTokenPricerTransactor(address common.Address, transactor bind.ContractTransactor) (*IFeeTokenPricerTransactor, error) {
	contract, err := bindIFeeTokenPricer(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IFeeTokenPricerTransactor{contract: contract}, nil
}

// NewIFeeTokenPricerFilterer creates a new log filterer instance of IFeeTokenPricer, bound to a specific deployed contract.
func NewIFeeTokenPricerFilterer(address common.Address, filterer bind.ContractFilterer) (*IFeeTokenPricerFilterer, error) {
	contract, err := bindIFeeTokenPricer(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IFeeTokenPricerFilterer{contract: contract}, nil
}

// bindIFeeTokenPricer binds a generic wrapper to an already deployed contract.
func bindIFeeTokenPricer(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IFeeTokenPricerMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IFeeTokenPricer *IFeeTokenPricerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IFeeTokenPricer.Contract.IFeeTokenPricerCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IFeeTokenPricer *IFeeTokenPricerRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFeeTokenPricer.Contract.IFeeTokenPricerTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IFeeTokenPricer *IFeeTokenPricerRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IFeeTokenPricer.Contract.IFeeTokenPricerTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IFeeTokenPricer *IFeeTokenPricerCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IFeeTokenPricer.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IFeeTokenPricer *IFeeTokenPricerTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFeeTokenPricer.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IFeeTokenPricer *IFeeTokenPricerTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IFeeTokenPricer.Contract.contract.Transact(opts, method, params...)
}

// GetExchangeRate is a paid mutator transaction binding the contract method 0xe6aa216c.
//
// Solidity: function getExchangeRate() returns(uint256)
func (_IFeeTokenPricer *IFeeTokenPricerTransactor) GetExchangeRate(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IFeeTokenPricer.contract.Transact(opts, "getExchangeRate")
}

// GetExchangeRate is a paid mutator transaction binding the contract method 0xe6aa216c.
//
// Solidity: function getExchangeRate() returns(uint256)
func (_IFeeTokenPricer *IFeeTokenPricerSession) GetExchangeRate() (*types.Transaction, error) {
	return _IFeeTokenPricer.Contract.GetExchangeRate(&_IFeeTokenPricer.TransactOpts)
}

// GetExchangeRate is a paid mutator transaction binding the contract method 0xe6aa216c.
//
// Solidity: function getExchangeRate() returns(uint256)
func (_IFeeTokenPricer *IFeeTokenPricerTransactorSession) GetExchangeRate() (*types.Transaction, error) {
	return _IFeeTokenPricer.Contract.GetExchangeRate(&_IFeeTokenPricer.TransactOpts)
}

// IInboxMetaData contains all meta data concerning the IInbox contract.
var IInboxMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowListEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"}],\"name\":\"calculateRetryableSubmissionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createRetryableTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"contractISequencerInbox\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDataSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"postUpgradeInit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendContractTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendL1FundedContractTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendL1FundedUnsignedTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendL1FundedUnsignedTransactionToFork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2Message\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2MessageFromOrigin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendUnsignedTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendUnsignedTransactionToFork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"withdrawTo\",\"type\":\"address\"}],\"name\":\"sendWithdrawEthToFork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"contractISequencerInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"val\",\"type\":\"bool[]\"}],\"name\":\"setAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowListEnabled\",\"type\":\"bool\"}],\"name\":\"setAllowListEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unsafeCreateRetryableTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]",
}

// IInboxABI is the input ABI used to generate the binding from.
// Deprecated: Use IInboxMetaData.ABI instead.
var IInboxABI = IInboxMetaData.ABI

// IInbox is an auto generated Go binding around an Ethereum contract.
type IInbox struct {
	IInboxCaller     // Read-only binding to the contract
	IInboxTransactor // Write-only binding to the contract
	IInboxFilterer   // Log filterer for contract events
}

// IInboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type IInboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IInboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IInboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IInboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IInboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IInboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IInboxSession struct {
	Contract     *IInbox           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IInboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IInboxCallerSession struct {
	Contract *IInboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// IInboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IInboxTransactorSession struct {
	Contract     *IInboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IInboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type IInboxRaw struct {
	Contract *IInbox // Generic contract binding to access the raw methods on
}

// IInboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IInboxCallerRaw struct {
	Contract *IInboxCaller // Generic read-only contract binding to access the raw methods on
}

// IInboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IInboxTransactorRaw struct {
	Contract *IInboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIInbox creates a new instance of IInbox, bound to a specific deployed contract.
func NewIInbox(address common.Address, backend bind.ContractBackend) (*IInbox, error) {
	contract, err := bindIInbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IInbox{IInboxCaller: IInboxCaller{contract: contract}, IInboxTransactor: IInboxTransactor{contract: contract}, IInboxFilterer: IInboxFilterer{contract: contract}}, nil
}

// NewIInboxCaller creates a new read-only instance of IInbox, bound to a specific deployed contract.
func NewIInboxCaller(address common.Address, caller bind.ContractCaller) (*IInboxCaller, error) {
	contract, err := bindIInbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IInboxCaller{contract: contract}, nil
}

// NewIInboxTransactor creates a new write-only instance of IInbox, bound to a specific deployed contract.
func NewIInboxTransactor(address common.Address, transactor bind.ContractTransactor) (*IInboxTransactor, error) {
	contract, err := bindIInbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IInboxTransactor{contract: contract}, nil
}

// NewIInboxFilterer creates a new log filterer instance of IInbox, bound to a specific deployed contract.
func NewIInboxFilterer(address common.Address, filterer bind.ContractFilterer) (*IInboxFilterer, error) {
	contract, err := bindIInbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IInboxFilterer{contract: contract}, nil
}

// bindIInbox binds a generic wrapper to an already deployed contract.
func bindIInbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IInboxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IInbox *IInboxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IInbox.Contract.IInboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IInbox *IInboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IInbox.Contract.IInboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IInbox *IInboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IInbox.Contract.IInboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IInbox *IInboxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IInbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IInbox *IInboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IInbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IInbox *IInboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IInbox.Contract.contract.Transact(opts, method, params...)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_IInbox *IInboxCaller) AllowListEnabled(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _IInbox.contract.Call(opts, &out, "allowListEnabled")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_IInbox *IInboxSession) AllowListEnabled() (bool, error) {
	return _IInbox.Contract.AllowListEnabled(&_IInbox.CallOpts)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_IInbox *IInboxCallerSession) AllowListEnabled() (bool, error) {
	return _IInbox.Contract.AllowListEnabled(&_IInbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_IInbox *IInboxCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IInbox.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_IInbox *IInboxSession) Bridge() (common.Address, error) {
	return _IInbox.Contract.Bridge(&_IInbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_IInbox *IInboxCallerSession) Bridge() (common.Address, error) {
	return _IInbox.Contract.Bridge(&_IInbox.CallOpts)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_IInbox *IInboxCaller) CalculateRetryableSubmissionFee(opts *bind.CallOpts, dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _IInbox.contract.Call(opts, &out, "calculateRetryableSubmissionFee", dataLength, baseFee)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_IInbox *IInboxSession) CalculateRetryableSubmissionFee(dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	return _IInbox.Contract.CalculateRetryableSubmissionFee(&_IInbox.CallOpts, dataLength, baseFee)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_IInbox *IInboxCallerSession) CalculateRetryableSubmissionFee(dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	return _IInbox.Contract.CalculateRetryableSubmissionFee(&_IInbox.CallOpts, dataLength, baseFee)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_IInbox *IInboxCaller) GetProxyAdmin(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IInbox.contract.Call(opts, &out, "getProxyAdmin")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_IInbox *IInboxSession) GetProxyAdmin() (common.Address, error) {
	return _IInbox.Contract.GetProxyAdmin(&_IInbox.CallOpts)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_IInbox *IInboxCallerSession) GetProxyAdmin() (common.Address, error) {
	return _IInbox.Contract.GetProxyAdmin(&_IInbox.CallOpts)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address user) view returns(bool)
func (_IInbox *IInboxCaller) IsAllowed(opts *bind.CallOpts, user common.Address) (bool, error) {
	var out []interface{}
	err := _IInbox.contract.Call(opts, &out, "isAllowed", user)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address user) view returns(bool)
func (_IInbox *IInboxSession) IsAllowed(user common.Address) (bool, error) {
	return _IInbox.Contract.IsAllowed(&_IInbox.CallOpts, user)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address user) view returns(bool)
func (_IInbox *IInboxCallerSession) IsAllowed(user common.Address) (bool, error) {
	return _IInbox.Contract.IsAllowed(&_IInbox.CallOpts, user)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_IInbox *IInboxCaller) MaxDataSize(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IInbox.contract.Call(opts, &out, "maxDataSize")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_IInbox *IInboxSession) MaxDataSize() (*big.Int, error) {
	return _IInbox.Contract.MaxDataSize(&_IInbox.CallOpts)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_IInbox *IInboxCallerSession) MaxDataSize() (*big.Int, error) {
	return _IInbox.Contract.MaxDataSize(&_IInbox.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IInbox *IInboxCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IInbox.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IInbox *IInboxSession) SequencerInbox() (common.Address, error) {
	return _IInbox.Contract.SequencerInbox(&_IInbox.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IInbox *IInboxCallerSession) SequencerInbox() (common.Address, error) {
	return _IInbox.Contract.SequencerInbox(&_IInbox.CallOpts)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x679b6ded.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_IInbox *IInboxTransactor) CreateRetryableTicket(opts *bind.TransactOpts, to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "createRetryableTicket", to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x679b6ded.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_IInbox *IInboxSession) CreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.CreateRetryableTicket(&_IInbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x679b6ded.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_IInbox *IInboxTransactorSession) CreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.CreateRetryableTicket(&_IInbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// DepositEth is a paid mutator transaction binding the contract method 0x439370b1.
//
// Solidity: function depositEth() payable returns(uint256)
func (_IInbox *IInboxTransactor) DepositEth(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "depositEth")
}

// DepositEth is a paid mutator transaction binding the contract method 0x439370b1.
//
// Solidity: function depositEth() payable returns(uint256)
func (_IInbox *IInboxSession) DepositEth() (*types.Transaction, error) {
	return _IInbox.Contract.DepositEth(&_IInbox.TransactOpts)
}

// DepositEth is a paid mutator transaction binding the contract method 0x439370b1.
//
// Solidity: function depositEth() payable returns(uint256)
func (_IInbox *IInboxTransactorSession) DepositEth() (*types.Transaction, error) {
	return _IInbox.Contract.DepositEth(&_IInbox.TransactOpts)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_IInbox *IInboxTransactor) Initialize(opts *bind.TransactOpts, _bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "initialize", _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_IInbox *IInboxSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _IInbox.Contract.Initialize(&_IInbox.TransactOpts, _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_IInbox *IInboxTransactorSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _IInbox.Contract.Initialize(&_IInbox.TransactOpts, _bridge, _sequencerInbox)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_IInbox *IInboxTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_IInbox *IInboxSession) Pause() (*types.Transaction, error) {
	return _IInbox.Contract.Pause(&_IInbox.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_IInbox *IInboxTransactorSession) Pause() (*types.Transaction, error) {
	return _IInbox.Contract.Pause(&_IInbox.TransactOpts)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0xc474d2c5.
//
// Solidity: function postUpgradeInit(address _bridge) returns()
func (_IInbox *IInboxTransactor) PostUpgradeInit(opts *bind.TransactOpts, _bridge common.Address) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "postUpgradeInit", _bridge)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0xc474d2c5.
//
// Solidity: function postUpgradeInit(address _bridge) returns()
func (_IInbox *IInboxSession) PostUpgradeInit(_bridge common.Address) (*types.Transaction, error) {
	return _IInbox.Contract.PostUpgradeInit(&_IInbox.TransactOpts, _bridge)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0xc474d2c5.
//
// Solidity: function postUpgradeInit(address _bridge) returns()
func (_IInbox *IInboxTransactorSession) PostUpgradeInit(_bridge common.Address) (*types.Transaction, error) {
	return _IInbox.Contract.PostUpgradeInit(&_IInbox.TransactOpts, _bridge)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_IInbox *IInboxTransactor) SendContractTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "sendContractTransaction", gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_IInbox *IInboxSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendContractTransaction(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_IInbox *IInboxTransactorSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendContractTransaction(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendL1FundedContractTransaction is a paid mutator transaction binding the contract method 0x5e916758.
//
// Solidity: function sendL1FundedContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, bytes data) payable returns(uint256)
func (_IInbox *IInboxTransactor) SendL1FundedContractTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "sendL1FundedContractTransaction", gasLimit, maxFeePerGas, to, data)
}

// SendL1FundedContractTransaction is a paid mutator transaction binding the contract method 0x5e916758.
//
// Solidity: function sendL1FundedContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, bytes data) payable returns(uint256)
func (_IInbox *IInboxSession) SendL1FundedContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendL1FundedContractTransaction(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, to, data)
}

// SendL1FundedContractTransaction is a paid mutator transaction binding the contract method 0x5e916758.
//
// Solidity: function sendL1FundedContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, bytes data) payable returns(uint256)
func (_IInbox *IInboxTransactorSession) SendL1FundedContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendL1FundedContractTransaction(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, to, data)
}

// SendL1FundedUnsignedTransaction is a paid mutator transaction binding the contract method 0x67ef3ab8.
//
// Solidity: function sendL1FundedUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes data) payable returns(uint256)
func (_IInbox *IInboxTransactor) SendL1FundedUnsignedTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "sendL1FundedUnsignedTransaction", gasLimit, maxFeePerGas, nonce, to, data)
}

// SendL1FundedUnsignedTransaction is a paid mutator transaction binding the contract method 0x67ef3ab8.
//
// Solidity: function sendL1FundedUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes data) payable returns(uint256)
func (_IInbox *IInboxSession) SendL1FundedUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendL1FundedUnsignedTransaction(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, data)
}

// SendL1FundedUnsignedTransaction is a paid mutator transaction binding the contract method 0x67ef3ab8.
//
// Solidity: function sendL1FundedUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes data) payable returns(uint256)
func (_IInbox *IInboxTransactorSession) SendL1FundedUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendL1FundedUnsignedTransaction(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, data)
}

// SendL1FundedUnsignedTransactionToFork is a paid mutator transaction binding the contract method 0xe6bd12cf.
//
// Solidity: function sendL1FundedUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes data) payable returns(uint256)
func (_IInbox *IInboxTransactor) SendL1FundedUnsignedTransactionToFork(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "sendL1FundedUnsignedTransactionToFork", gasLimit, maxFeePerGas, nonce, to, data)
}

// SendL1FundedUnsignedTransactionToFork is a paid mutator transaction binding the contract method 0xe6bd12cf.
//
// Solidity: function sendL1FundedUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes data) payable returns(uint256)
func (_IInbox *IInboxSession) SendL1FundedUnsignedTransactionToFork(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendL1FundedUnsignedTransactionToFork(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, data)
}

// SendL1FundedUnsignedTransactionToFork is a paid mutator transaction binding the contract method 0xe6bd12cf.
//
// Solidity: function sendL1FundedUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes data) payable returns(uint256)
func (_IInbox *IInboxTransactorSession) SendL1FundedUnsignedTransactionToFork(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendL1FundedUnsignedTransactionToFork(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, data)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_IInbox *IInboxTransactor) SendL2Message(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "sendL2Message", messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_IInbox *IInboxSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendL2Message(&_IInbox.TransactOpts, messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_IInbox *IInboxTransactorSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendL2Message(&_IInbox.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_IInbox *IInboxTransactor) SendL2MessageFromOrigin(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "sendL2MessageFromOrigin", messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_IInbox *IInboxSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendL2MessageFromOrigin(&_IInbox.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_IInbox *IInboxTransactorSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendL2MessageFromOrigin(&_IInbox.TransactOpts, messageData)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_IInbox *IInboxTransactor) SendUnsignedTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "sendUnsignedTransaction", gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_IInbox *IInboxSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendUnsignedTransaction(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_IInbox *IInboxTransactorSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendUnsignedTransaction(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransactionToFork is a paid mutator transaction binding the contract method 0x00f72382.
//
// Solidity: function sendUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_IInbox *IInboxTransactor) SendUnsignedTransactionToFork(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "sendUnsignedTransactionToFork", gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransactionToFork is a paid mutator transaction binding the contract method 0x00f72382.
//
// Solidity: function sendUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_IInbox *IInboxSession) SendUnsignedTransactionToFork(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendUnsignedTransactionToFork(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransactionToFork is a paid mutator transaction binding the contract method 0x00f72382.
//
// Solidity: function sendUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_IInbox *IInboxTransactorSession) SendUnsignedTransactionToFork(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.SendUnsignedTransactionToFork(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendWithdrawEthToFork is a paid mutator transaction binding the contract method 0x70665f14.
//
// Solidity: function sendWithdrawEthToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, uint256 value, address withdrawTo) returns(uint256)
func (_IInbox *IInboxTransactor) SendWithdrawEthToFork(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, value *big.Int, withdrawTo common.Address) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "sendWithdrawEthToFork", gasLimit, maxFeePerGas, nonce, value, withdrawTo)
}

// SendWithdrawEthToFork is a paid mutator transaction binding the contract method 0x70665f14.
//
// Solidity: function sendWithdrawEthToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, uint256 value, address withdrawTo) returns(uint256)
func (_IInbox *IInboxSession) SendWithdrawEthToFork(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, value *big.Int, withdrawTo common.Address) (*types.Transaction, error) {
	return _IInbox.Contract.SendWithdrawEthToFork(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, nonce, value, withdrawTo)
}

// SendWithdrawEthToFork is a paid mutator transaction binding the contract method 0x70665f14.
//
// Solidity: function sendWithdrawEthToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, uint256 value, address withdrawTo) returns(uint256)
func (_IInbox *IInboxTransactorSession) SendWithdrawEthToFork(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, value *big.Int, withdrawTo common.Address) (*types.Transaction, error) {
	return _IInbox.Contract.SendWithdrawEthToFork(&_IInbox.TransactOpts, gasLimit, maxFeePerGas, nonce, value, withdrawTo)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_IInbox *IInboxTransactor) SetAllowList(opts *bind.TransactOpts, user []common.Address, val []bool) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "setAllowList", user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_IInbox *IInboxSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _IInbox.Contract.SetAllowList(&_IInbox.TransactOpts, user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_IInbox *IInboxTransactorSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _IInbox.Contract.SetAllowList(&_IInbox.TransactOpts, user, val)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_IInbox *IInboxTransactor) SetAllowListEnabled(opts *bind.TransactOpts, _allowListEnabled bool) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "setAllowListEnabled", _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_IInbox *IInboxSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _IInbox.Contract.SetAllowListEnabled(&_IInbox.TransactOpts, _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_IInbox *IInboxTransactorSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _IInbox.Contract.SetAllowListEnabled(&_IInbox.TransactOpts, _allowListEnabled)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_IInbox *IInboxTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_IInbox *IInboxSession) Unpause() (*types.Transaction, error) {
	return _IInbox.Contract.Unpause(&_IInbox.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_IInbox *IInboxTransactorSession) Unpause() (*types.Transaction, error) {
	return _IInbox.Contract.Unpause(&_IInbox.TransactOpts)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0x6e6e8a6a.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_IInbox *IInboxTransactor) UnsafeCreateRetryableTicket(opts *bind.TransactOpts, to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.contract.Transact(opts, "unsafeCreateRetryableTicket", to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0x6e6e8a6a.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_IInbox *IInboxSession) UnsafeCreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.UnsafeCreateRetryableTicket(&_IInbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0x6e6e8a6a.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_IInbox *IInboxTransactorSession) UnsafeCreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _IInbox.Contract.UnsafeCreateRetryableTicket(&_IInbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// IInboxInboxMessageDeliveredIterator is returned from FilterInboxMessageDelivered and is used to iterate over the raw logs and unpacked data for InboxMessageDelivered events raised by the IInbox contract.
type IInboxInboxMessageDeliveredIterator struct {
	Event *IInboxInboxMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IInboxInboxMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IInboxInboxMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IInboxInboxMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IInboxInboxMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IInboxInboxMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IInboxInboxMessageDelivered represents a InboxMessageDelivered event raised by the IInbox contract.
type IInboxInboxMessageDelivered struct {
	MessageNum *big.Int
	Data       []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDelivered is a free log retrieval operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_IInbox *IInboxFilterer) FilterInboxMessageDelivered(opts *bind.FilterOpts, messageNum []*big.Int) (*IInboxInboxMessageDeliveredIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IInbox.contract.FilterLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &IInboxInboxMessageDeliveredIterator{contract: _IInbox.contract, event: "InboxMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDelivered is a free log subscription operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_IInbox *IInboxFilterer) WatchInboxMessageDelivered(opts *bind.WatchOpts, sink chan<- *IInboxInboxMessageDelivered, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IInbox.contract.WatchLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IInboxInboxMessageDelivered)
				if err := _IInbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDelivered is a log parse operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_IInbox *IInboxFilterer) ParseInboxMessageDelivered(log types.Log) (*IInboxInboxMessageDelivered, error) {
	event := new(IInboxInboxMessageDelivered)
	if err := _IInbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IInboxInboxMessageDeliveredFromOriginIterator is returned from FilterInboxMessageDeliveredFromOrigin and is used to iterate over the raw logs and unpacked data for InboxMessageDeliveredFromOrigin events raised by the IInbox contract.
type IInboxInboxMessageDeliveredFromOriginIterator struct {
	Event *IInboxInboxMessageDeliveredFromOrigin // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IInboxInboxMessageDeliveredFromOriginIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IInboxInboxMessageDeliveredFromOrigin)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IInboxInboxMessageDeliveredFromOrigin)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IInboxInboxMessageDeliveredFromOriginIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IInboxInboxMessageDeliveredFromOriginIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IInboxInboxMessageDeliveredFromOrigin represents a InboxMessageDeliveredFromOrigin event raised by the IInbox contract.
type IInboxInboxMessageDeliveredFromOrigin struct {
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDeliveredFromOrigin is a free log retrieval operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_IInbox *IInboxFilterer) FilterInboxMessageDeliveredFromOrigin(opts *bind.FilterOpts, messageNum []*big.Int) (*IInboxInboxMessageDeliveredFromOriginIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IInbox.contract.FilterLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &IInboxInboxMessageDeliveredFromOriginIterator{contract: _IInbox.contract, event: "InboxMessageDeliveredFromOrigin", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDeliveredFromOrigin is a free log subscription operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_IInbox *IInboxFilterer) WatchInboxMessageDeliveredFromOrigin(opts *bind.WatchOpts, sink chan<- *IInboxInboxMessageDeliveredFromOrigin, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IInbox.contract.WatchLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IInboxInboxMessageDeliveredFromOrigin)
				if err := _IInbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDeliveredFromOrigin is a log parse operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_IInbox *IInboxFilterer) ParseInboxMessageDeliveredFromOrigin(log types.Log) (*IInboxInboxMessageDeliveredFromOrigin, error) {
	event := new(IInboxInboxMessageDeliveredFromOrigin)
	if err := _IInbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IInboxBaseMetaData contains all meta data concerning the IInboxBase contract.
var IInboxBaseMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowListEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"}],\"name\":\"calculateRetryableSubmissionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"contractISequencerInbox\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDataSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendContractTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2Message\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2MessageFromOrigin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendUnsignedTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"contractISequencerInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"val\",\"type\":\"bool[]\"}],\"name\":\"setAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowListEnabled\",\"type\":\"bool\"}],\"name\":\"setAllowListEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IInboxBaseABI is the input ABI used to generate the binding from.
// Deprecated: Use IInboxBaseMetaData.ABI instead.
var IInboxBaseABI = IInboxBaseMetaData.ABI

// IInboxBase is an auto generated Go binding around an Ethereum contract.
type IInboxBase struct {
	IInboxBaseCaller     // Read-only binding to the contract
	IInboxBaseTransactor // Write-only binding to the contract
	IInboxBaseFilterer   // Log filterer for contract events
}

// IInboxBaseCaller is an auto generated read-only Go binding around an Ethereum contract.
type IInboxBaseCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IInboxBaseTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IInboxBaseTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IInboxBaseFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IInboxBaseFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IInboxBaseSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IInboxBaseSession struct {
	Contract     *IInboxBase       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IInboxBaseCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IInboxBaseCallerSession struct {
	Contract *IInboxBaseCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// IInboxBaseTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IInboxBaseTransactorSession struct {
	Contract     *IInboxBaseTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// IInboxBaseRaw is an auto generated low-level Go binding around an Ethereum contract.
type IInboxBaseRaw struct {
	Contract *IInboxBase // Generic contract binding to access the raw methods on
}

// IInboxBaseCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IInboxBaseCallerRaw struct {
	Contract *IInboxBaseCaller // Generic read-only contract binding to access the raw methods on
}

// IInboxBaseTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IInboxBaseTransactorRaw struct {
	Contract *IInboxBaseTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIInboxBase creates a new instance of IInboxBase, bound to a specific deployed contract.
func NewIInboxBase(address common.Address, backend bind.ContractBackend) (*IInboxBase, error) {
	contract, err := bindIInboxBase(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IInboxBase{IInboxBaseCaller: IInboxBaseCaller{contract: contract}, IInboxBaseTransactor: IInboxBaseTransactor{contract: contract}, IInboxBaseFilterer: IInboxBaseFilterer{contract: contract}}, nil
}

// NewIInboxBaseCaller creates a new read-only instance of IInboxBase, bound to a specific deployed contract.
func NewIInboxBaseCaller(address common.Address, caller bind.ContractCaller) (*IInboxBaseCaller, error) {
	contract, err := bindIInboxBase(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IInboxBaseCaller{contract: contract}, nil
}

// NewIInboxBaseTransactor creates a new write-only instance of IInboxBase, bound to a specific deployed contract.
func NewIInboxBaseTransactor(address common.Address, transactor bind.ContractTransactor) (*IInboxBaseTransactor, error) {
	contract, err := bindIInboxBase(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IInboxBaseTransactor{contract: contract}, nil
}

// NewIInboxBaseFilterer creates a new log filterer instance of IInboxBase, bound to a specific deployed contract.
func NewIInboxBaseFilterer(address common.Address, filterer bind.ContractFilterer) (*IInboxBaseFilterer, error) {
	contract, err := bindIInboxBase(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IInboxBaseFilterer{contract: contract}, nil
}

// bindIInboxBase binds a generic wrapper to an already deployed contract.
func bindIInboxBase(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IInboxBaseMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IInboxBase *IInboxBaseRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IInboxBase.Contract.IInboxBaseCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IInboxBase *IInboxBaseRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IInboxBase.Contract.IInboxBaseTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IInboxBase *IInboxBaseRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IInboxBase.Contract.IInboxBaseTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IInboxBase *IInboxBaseCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IInboxBase.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IInboxBase *IInboxBaseTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IInboxBase.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IInboxBase *IInboxBaseTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IInboxBase.Contract.contract.Transact(opts, method, params...)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_IInboxBase *IInboxBaseCaller) AllowListEnabled(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _IInboxBase.contract.Call(opts, &out, "allowListEnabled")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_IInboxBase *IInboxBaseSession) AllowListEnabled() (bool, error) {
	return _IInboxBase.Contract.AllowListEnabled(&_IInboxBase.CallOpts)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_IInboxBase *IInboxBaseCallerSession) AllowListEnabled() (bool, error) {
	return _IInboxBase.Contract.AllowListEnabled(&_IInboxBase.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_IInboxBase *IInboxBaseCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IInboxBase.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_IInboxBase *IInboxBaseSession) Bridge() (common.Address, error) {
	return _IInboxBase.Contract.Bridge(&_IInboxBase.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_IInboxBase *IInboxBaseCallerSession) Bridge() (common.Address, error) {
	return _IInboxBase.Contract.Bridge(&_IInboxBase.CallOpts)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_IInboxBase *IInboxBaseCaller) CalculateRetryableSubmissionFee(opts *bind.CallOpts, dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _IInboxBase.contract.Call(opts, &out, "calculateRetryableSubmissionFee", dataLength, baseFee)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_IInboxBase *IInboxBaseSession) CalculateRetryableSubmissionFee(dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	return _IInboxBase.Contract.CalculateRetryableSubmissionFee(&_IInboxBase.CallOpts, dataLength, baseFee)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_IInboxBase *IInboxBaseCallerSession) CalculateRetryableSubmissionFee(dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	return _IInboxBase.Contract.CalculateRetryableSubmissionFee(&_IInboxBase.CallOpts, dataLength, baseFee)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_IInboxBase *IInboxBaseCaller) GetProxyAdmin(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IInboxBase.contract.Call(opts, &out, "getProxyAdmin")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_IInboxBase *IInboxBaseSession) GetProxyAdmin() (common.Address, error) {
	return _IInboxBase.Contract.GetProxyAdmin(&_IInboxBase.CallOpts)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_IInboxBase *IInboxBaseCallerSession) GetProxyAdmin() (common.Address, error) {
	return _IInboxBase.Contract.GetProxyAdmin(&_IInboxBase.CallOpts)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address user) view returns(bool)
func (_IInboxBase *IInboxBaseCaller) IsAllowed(opts *bind.CallOpts, user common.Address) (bool, error) {
	var out []interface{}
	err := _IInboxBase.contract.Call(opts, &out, "isAllowed", user)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address user) view returns(bool)
func (_IInboxBase *IInboxBaseSession) IsAllowed(user common.Address) (bool, error) {
	return _IInboxBase.Contract.IsAllowed(&_IInboxBase.CallOpts, user)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address user) view returns(bool)
func (_IInboxBase *IInboxBaseCallerSession) IsAllowed(user common.Address) (bool, error) {
	return _IInboxBase.Contract.IsAllowed(&_IInboxBase.CallOpts, user)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_IInboxBase *IInboxBaseCaller) MaxDataSize(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IInboxBase.contract.Call(opts, &out, "maxDataSize")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_IInboxBase *IInboxBaseSession) MaxDataSize() (*big.Int, error) {
	return _IInboxBase.Contract.MaxDataSize(&_IInboxBase.CallOpts)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_IInboxBase *IInboxBaseCallerSession) MaxDataSize() (*big.Int, error) {
	return _IInboxBase.Contract.MaxDataSize(&_IInboxBase.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IInboxBase *IInboxBaseCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IInboxBase.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IInboxBase *IInboxBaseSession) SequencerInbox() (common.Address, error) {
	return _IInboxBase.Contract.SequencerInbox(&_IInboxBase.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_IInboxBase *IInboxBaseCallerSession) SequencerInbox() (common.Address, error) {
	return _IInboxBase.Contract.SequencerInbox(&_IInboxBase.CallOpts)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_IInboxBase *IInboxBaseTransactor) Initialize(opts *bind.TransactOpts, _bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _IInboxBase.contract.Transact(opts, "initialize", _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_IInboxBase *IInboxBaseSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _IInboxBase.Contract.Initialize(&_IInboxBase.TransactOpts, _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_IInboxBase *IInboxBaseTransactorSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _IInboxBase.Contract.Initialize(&_IInboxBase.TransactOpts, _bridge, _sequencerInbox)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_IInboxBase *IInboxBaseTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IInboxBase.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_IInboxBase *IInboxBaseSession) Pause() (*types.Transaction, error) {
	return _IInboxBase.Contract.Pause(&_IInboxBase.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_IInboxBase *IInboxBaseTransactorSession) Pause() (*types.Transaction, error) {
	return _IInboxBase.Contract.Pause(&_IInboxBase.TransactOpts)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_IInboxBase *IInboxBaseTransactor) SendContractTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInboxBase.contract.Transact(opts, "sendContractTransaction", gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_IInboxBase *IInboxBaseSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInboxBase.Contract.SendContractTransaction(&_IInboxBase.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_IInboxBase *IInboxBaseTransactorSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInboxBase.Contract.SendContractTransaction(&_IInboxBase.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_IInboxBase *IInboxBaseTransactor) SendL2Message(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _IInboxBase.contract.Transact(opts, "sendL2Message", messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_IInboxBase *IInboxBaseSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _IInboxBase.Contract.SendL2Message(&_IInboxBase.TransactOpts, messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_IInboxBase *IInboxBaseTransactorSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _IInboxBase.Contract.SendL2Message(&_IInboxBase.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_IInboxBase *IInboxBaseTransactor) SendL2MessageFromOrigin(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _IInboxBase.contract.Transact(opts, "sendL2MessageFromOrigin", messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_IInboxBase *IInboxBaseSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _IInboxBase.Contract.SendL2MessageFromOrigin(&_IInboxBase.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_IInboxBase *IInboxBaseTransactorSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _IInboxBase.Contract.SendL2MessageFromOrigin(&_IInboxBase.TransactOpts, messageData)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_IInboxBase *IInboxBaseTransactor) SendUnsignedTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInboxBase.contract.Transact(opts, "sendUnsignedTransaction", gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_IInboxBase *IInboxBaseSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInboxBase.Contract.SendUnsignedTransaction(&_IInboxBase.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_IInboxBase *IInboxBaseTransactorSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IInboxBase.Contract.SendUnsignedTransaction(&_IInboxBase.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_IInboxBase *IInboxBaseTransactor) SetAllowList(opts *bind.TransactOpts, user []common.Address, val []bool) (*types.Transaction, error) {
	return _IInboxBase.contract.Transact(opts, "setAllowList", user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_IInboxBase *IInboxBaseSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _IInboxBase.Contract.SetAllowList(&_IInboxBase.TransactOpts, user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_IInboxBase *IInboxBaseTransactorSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _IInboxBase.Contract.SetAllowList(&_IInboxBase.TransactOpts, user, val)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_IInboxBase *IInboxBaseTransactor) SetAllowListEnabled(opts *bind.TransactOpts, _allowListEnabled bool) (*types.Transaction, error) {
	return _IInboxBase.contract.Transact(opts, "setAllowListEnabled", _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_IInboxBase *IInboxBaseSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _IInboxBase.Contract.SetAllowListEnabled(&_IInboxBase.TransactOpts, _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_IInboxBase *IInboxBaseTransactorSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _IInboxBase.Contract.SetAllowListEnabled(&_IInboxBase.TransactOpts, _allowListEnabled)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_IInboxBase *IInboxBaseTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IInboxBase.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_IInboxBase *IInboxBaseSession) Unpause() (*types.Transaction, error) {
	return _IInboxBase.Contract.Unpause(&_IInboxBase.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_IInboxBase *IInboxBaseTransactorSession) Unpause() (*types.Transaction, error) {
	return _IInboxBase.Contract.Unpause(&_IInboxBase.TransactOpts)
}

// IInboxBaseInboxMessageDeliveredIterator is returned from FilterInboxMessageDelivered and is used to iterate over the raw logs and unpacked data for InboxMessageDelivered events raised by the IInboxBase contract.
type IInboxBaseInboxMessageDeliveredIterator struct {
	Event *IInboxBaseInboxMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IInboxBaseInboxMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IInboxBaseInboxMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IInboxBaseInboxMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IInboxBaseInboxMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IInboxBaseInboxMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IInboxBaseInboxMessageDelivered represents a InboxMessageDelivered event raised by the IInboxBase contract.
type IInboxBaseInboxMessageDelivered struct {
	MessageNum *big.Int
	Data       []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDelivered is a free log retrieval operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_IInboxBase *IInboxBaseFilterer) FilterInboxMessageDelivered(opts *bind.FilterOpts, messageNum []*big.Int) (*IInboxBaseInboxMessageDeliveredIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IInboxBase.contract.FilterLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &IInboxBaseInboxMessageDeliveredIterator{contract: _IInboxBase.contract, event: "InboxMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDelivered is a free log subscription operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_IInboxBase *IInboxBaseFilterer) WatchInboxMessageDelivered(opts *bind.WatchOpts, sink chan<- *IInboxBaseInboxMessageDelivered, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IInboxBase.contract.WatchLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IInboxBaseInboxMessageDelivered)
				if err := _IInboxBase.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDelivered is a log parse operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_IInboxBase *IInboxBaseFilterer) ParseInboxMessageDelivered(log types.Log) (*IInboxBaseInboxMessageDelivered, error) {
	event := new(IInboxBaseInboxMessageDelivered)
	if err := _IInboxBase.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IInboxBaseInboxMessageDeliveredFromOriginIterator is returned from FilterInboxMessageDeliveredFromOrigin and is used to iterate over the raw logs and unpacked data for InboxMessageDeliveredFromOrigin events raised by the IInboxBase contract.
type IInboxBaseInboxMessageDeliveredFromOriginIterator struct {
	Event *IInboxBaseInboxMessageDeliveredFromOrigin // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IInboxBaseInboxMessageDeliveredFromOriginIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IInboxBaseInboxMessageDeliveredFromOrigin)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IInboxBaseInboxMessageDeliveredFromOrigin)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IInboxBaseInboxMessageDeliveredFromOriginIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IInboxBaseInboxMessageDeliveredFromOriginIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IInboxBaseInboxMessageDeliveredFromOrigin represents a InboxMessageDeliveredFromOrigin event raised by the IInboxBase contract.
type IInboxBaseInboxMessageDeliveredFromOrigin struct {
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDeliveredFromOrigin is a free log retrieval operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_IInboxBase *IInboxBaseFilterer) FilterInboxMessageDeliveredFromOrigin(opts *bind.FilterOpts, messageNum []*big.Int) (*IInboxBaseInboxMessageDeliveredFromOriginIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IInboxBase.contract.FilterLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &IInboxBaseInboxMessageDeliveredFromOriginIterator{contract: _IInboxBase.contract, event: "InboxMessageDeliveredFromOrigin", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDeliveredFromOrigin is a free log subscription operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_IInboxBase *IInboxBaseFilterer) WatchInboxMessageDeliveredFromOrigin(opts *bind.WatchOpts, sink chan<- *IInboxBaseInboxMessageDeliveredFromOrigin, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _IInboxBase.contract.WatchLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IInboxBaseInboxMessageDeliveredFromOrigin)
				if err := _IInboxBase.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDeliveredFromOrigin is a log parse operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_IInboxBase *IInboxBaseFilterer) ParseInboxMessageDeliveredFromOrigin(log types.Log) (*IInboxBaseInboxMessageDeliveredFromOrigin, error) {
	event := new(IInboxBaseInboxMessageDeliveredFromOrigin)
	if err := _IInboxBase.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IOutboxMetaData contains all meta data concerning the IOutbox contract.
var IOutboxMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"zero\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionIndex\",\"type\":\"uint256\"}],\"name\":\"OutBoxTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"outputRoot\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"l2BlockHash\",\"type\":\"bytes32\"}],\"name\":\"SendRootUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OUTBOX_VERSION\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"calculateItemHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"path\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"item\",\"type\":\"bytes32\"}],\"name\":\"calculateMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeTransactionSimulation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isSpent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Block\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1EthBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1OutputId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Sender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"postUpgradeInit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"roots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spent\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sendRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2BlockHash\",\"type\":\"bytes32\"}],\"name\":\"updateSendRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// IOutboxABI is the input ABI used to generate the binding from.
// Deprecated: Use IOutboxMetaData.ABI instead.
var IOutboxABI = IOutboxMetaData.ABI

// IOutbox is an auto generated Go binding around an Ethereum contract.
type IOutbox struct {
	IOutboxCaller     // Read-only binding to the contract
	IOutboxTransactor // Write-only binding to the contract
	IOutboxFilterer   // Log filterer for contract events
}

// IOutboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type IOutboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IOutboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IOutboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IOutboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IOutboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IOutboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IOutboxSession struct {
	Contract     *IOutbox          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IOutboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IOutboxCallerSession struct {
	Contract *IOutboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// IOutboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IOutboxTransactorSession struct {
	Contract     *IOutboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IOutboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type IOutboxRaw struct {
	Contract *IOutbox // Generic contract binding to access the raw methods on
}

// IOutboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IOutboxCallerRaw struct {
	Contract *IOutboxCaller // Generic read-only contract binding to access the raw methods on
}

// IOutboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IOutboxTransactorRaw struct {
	Contract *IOutboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIOutbox creates a new instance of IOutbox, bound to a specific deployed contract.
func NewIOutbox(address common.Address, backend bind.ContractBackend) (*IOutbox, error) {
	contract, err := bindIOutbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IOutbox{IOutboxCaller: IOutboxCaller{contract: contract}, IOutboxTransactor: IOutboxTransactor{contract: contract}, IOutboxFilterer: IOutboxFilterer{contract: contract}}, nil
}

// NewIOutboxCaller creates a new read-only instance of IOutbox, bound to a specific deployed contract.
func NewIOutboxCaller(address common.Address, caller bind.ContractCaller) (*IOutboxCaller, error) {
	contract, err := bindIOutbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IOutboxCaller{contract: contract}, nil
}

// NewIOutboxTransactor creates a new write-only instance of IOutbox, bound to a specific deployed contract.
func NewIOutboxTransactor(address common.Address, transactor bind.ContractTransactor) (*IOutboxTransactor, error) {
	contract, err := bindIOutbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IOutboxTransactor{contract: contract}, nil
}

// NewIOutboxFilterer creates a new log filterer instance of IOutbox, bound to a specific deployed contract.
func NewIOutboxFilterer(address common.Address, filterer bind.ContractFilterer) (*IOutboxFilterer, error) {
	contract, err := bindIOutbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IOutboxFilterer{contract: contract}, nil
}

// bindIOutbox binds a generic wrapper to an already deployed contract.
func bindIOutbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IOutboxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IOutbox *IOutboxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IOutbox.Contract.IOutboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IOutbox *IOutboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IOutbox.Contract.IOutboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IOutbox *IOutboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IOutbox.Contract.IOutboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IOutbox *IOutboxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IOutbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IOutbox *IOutboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IOutbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IOutbox *IOutboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IOutbox.Contract.contract.Transact(opts, method, params...)
}

// OUTBOXVERSION is a free data retrieval call binding the contract method 0xc75184df.
//
// Solidity: function OUTBOX_VERSION() view returns(uint128)
func (_IOutbox *IOutboxCaller) OUTBOXVERSION(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "OUTBOX_VERSION")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// OUTBOXVERSION is a free data retrieval call binding the contract method 0xc75184df.
//
// Solidity: function OUTBOX_VERSION() view returns(uint128)
func (_IOutbox *IOutboxSession) OUTBOXVERSION() (*big.Int, error) {
	return _IOutbox.Contract.OUTBOXVERSION(&_IOutbox.CallOpts)
}

// OUTBOXVERSION is a free data retrieval call binding the contract method 0xc75184df.
//
// Solidity: function OUTBOX_VERSION() view returns(uint128)
func (_IOutbox *IOutboxCallerSession) OUTBOXVERSION() (*big.Int, error) {
	return _IOutbox.Contract.OUTBOXVERSION(&_IOutbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_IOutbox *IOutboxCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_IOutbox *IOutboxSession) Bridge() (common.Address, error) {
	return _IOutbox.Contract.Bridge(&_IOutbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_IOutbox *IOutboxCallerSession) Bridge() (common.Address, error) {
	return _IOutbox.Contract.Bridge(&_IOutbox.CallOpts)
}

// CalculateItemHash is a free data retrieval call binding the contract method 0x9f0c04bf.
//
// Solidity: function calculateItemHash(address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) pure returns(bytes32)
func (_IOutbox *IOutboxCaller) CalculateItemHash(opts *bind.CallOpts, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) ([32]byte, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "calculateItemHash", l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CalculateItemHash is a free data retrieval call binding the contract method 0x9f0c04bf.
//
// Solidity: function calculateItemHash(address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) pure returns(bytes32)
func (_IOutbox *IOutboxSession) CalculateItemHash(l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) ([32]byte, error) {
	return _IOutbox.Contract.CalculateItemHash(&_IOutbox.CallOpts, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// CalculateItemHash is a free data retrieval call binding the contract method 0x9f0c04bf.
//
// Solidity: function calculateItemHash(address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) pure returns(bytes32)
func (_IOutbox *IOutboxCallerSession) CalculateItemHash(l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) ([32]byte, error) {
	return _IOutbox.Contract.CalculateItemHash(&_IOutbox.CallOpts, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// CalculateMerkleRoot is a free data retrieval call binding the contract method 0x007436d3.
//
// Solidity: function calculateMerkleRoot(bytes32[] proof, uint256 path, bytes32 item) pure returns(bytes32)
func (_IOutbox *IOutboxCaller) CalculateMerkleRoot(opts *bind.CallOpts, proof [][32]byte, path *big.Int, item [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "calculateMerkleRoot", proof, path, item)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CalculateMerkleRoot is a free data retrieval call binding the contract method 0x007436d3.
//
// Solidity: function calculateMerkleRoot(bytes32[] proof, uint256 path, bytes32 item) pure returns(bytes32)
func (_IOutbox *IOutboxSession) CalculateMerkleRoot(proof [][32]byte, path *big.Int, item [32]byte) ([32]byte, error) {
	return _IOutbox.Contract.CalculateMerkleRoot(&_IOutbox.CallOpts, proof, path, item)
}

// CalculateMerkleRoot is a free data retrieval call binding the contract method 0x007436d3.
//
// Solidity: function calculateMerkleRoot(bytes32[] proof, uint256 path, bytes32 item) pure returns(bytes32)
func (_IOutbox *IOutboxCallerSession) CalculateMerkleRoot(proof [][32]byte, path *big.Int, item [32]byte) ([32]byte, error) {
	return _IOutbox.Contract.CalculateMerkleRoot(&_IOutbox.CallOpts, proof, path, item)
}

// IsSpent is a free data retrieval call binding the contract method 0x5a129efe.
//
// Solidity: function isSpent(uint256 index) view returns(bool)
func (_IOutbox *IOutboxCaller) IsSpent(opts *bind.CallOpts, index *big.Int) (bool, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "isSpent", index)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSpent is a free data retrieval call binding the contract method 0x5a129efe.
//
// Solidity: function isSpent(uint256 index) view returns(bool)
func (_IOutbox *IOutboxSession) IsSpent(index *big.Int) (bool, error) {
	return _IOutbox.Contract.IsSpent(&_IOutbox.CallOpts, index)
}

// IsSpent is a free data retrieval call binding the contract method 0x5a129efe.
//
// Solidity: function isSpent(uint256 index) view returns(bool)
func (_IOutbox *IOutboxCallerSession) IsSpent(index *big.Int) (bool, error) {
	return _IOutbox.Contract.IsSpent(&_IOutbox.CallOpts, index)
}

// L2ToL1Block is a free data retrieval call binding the contract method 0x46547790.
//
// Solidity: function l2ToL1Block() view returns(uint256)
func (_IOutbox *IOutboxCaller) L2ToL1Block(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "l2ToL1Block")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1Block is a free data retrieval call binding the contract method 0x46547790.
//
// Solidity: function l2ToL1Block() view returns(uint256)
func (_IOutbox *IOutboxSession) L2ToL1Block() (*big.Int, error) {
	return _IOutbox.Contract.L2ToL1Block(&_IOutbox.CallOpts)
}

// L2ToL1Block is a free data retrieval call binding the contract method 0x46547790.
//
// Solidity: function l2ToL1Block() view returns(uint256)
func (_IOutbox *IOutboxCallerSession) L2ToL1Block() (*big.Int, error) {
	return _IOutbox.Contract.L2ToL1Block(&_IOutbox.CallOpts)
}

// L2ToL1EthBlock is a free data retrieval call binding the contract method 0x8515bc6a.
//
// Solidity: function l2ToL1EthBlock() view returns(uint256)
func (_IOutbox *IOutboxCaller) L2ToL1EthBlock(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "l2ToL1EthBlock")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1EthBlock is a free data retrieval call binding the contract method 0x8515bc6a.
//
// Solidity: function l2ToL1EthBlock() view returns(uint256)
func (_IOutbox *IOutboxSession) L2ToL1EthBlock() (*big.Int, error) {
	return _IOutbox.Contract.L2ToL1EthBlock(&_IOutbox.CallOpts)
}

// L2ToL1EthBlock is a free data retrieval call binding the contract method 0x8515bc6a.
//
// Solidity: function l2ToL1EthBlock() view returns(uint256)
func (_IOutbox *IOutboxCallerSession) L2ToL1EthBlock() (*big.Int, error) {
	return _IOutbox.Contract.L2ToL1EthBlock(&_IOutbox.CallOpts)
}

// L2ToL1OutputId is a free data retrieval call binding the contract method 0x72f2a8c7.
//
// Solidity: function l2ToL1OutputId() view returns(bytes32)
func (_IOutbox *IOutboxCaller) L2ToL1OutputId(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "l2ToL1OutputId")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// L2ToL1OutputId is a free data retrieval call binding the contract method 0x72f2a8c7.
//
// Solidity: function l2ToL1OutputId() view returns(bytes32)
func (_IOutbox *IOutboxSession) L2ToL1OutputId() ([32]byte, error) {
	return _IOutbox.Contract.L2ToL1OutputId(&_IOutbox.CallOpts)
}

// L2ToL1OutputId is a free data retrieval call binding the contract method 0x72f2a8c7.
//
// Solidity: function l2ToL1OutputId() view returns(bytes32)
func (_IOutbox *IOutboxCallerSession) L2ToL1OutputId() ([32]byte, error) {
	return _IOutbox.Contract.L2ToL1OutputId(&_IOutbox.CallOpts)
}

// L2ToL1Sender is a free data retrieval call binding the contract method 0x80648b02.
//
// Solidity: function l2ToL1Sender() view returns(address)
func (_IOutbox *IOutboxCaller) L2ToL1Sender(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "l2ToL1Sender")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// L2ToL1Sender is a free data retrieval call binding the contract method 0x80648b02.
//
// Solidity: function l2ToL1Sender() view returns(address)
func (_IOutbox *IOutboxSession) L2ToL1Sender() (common.Address, error) {
	return _IOutbox.Contract.L2ToL1Sender(&_IOutbox.CallOpts)
}

// L2ToL1Sender is a free data retrieval call binding the contract method 0x80648b02.
//
// Solidity: function l2ToL1Sender() view returns(address)
func (_IOutbox *IOutboxCallerSession) L2ToL1Sender() (common.Address, error) {
	return _IOutbox.Contract.L2ToL1Sender(&_IOutbox.CallOpts)
}

// L2ToL1Timestamp is a free data retrieval call binding the contract method 0xb0f30537.
//
// Solidity: function l2ToL1Timestamp() view returns(uint256)
func (_IOutbox *IOutboxCaller) L2ToL1Timestamp(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "l2ToL1Timestamp")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1Timestamp is a free data retrieval call binding the contract method 0xb0f30537.
//
// Solidity: function l2ToL1Timestamp() view returns(uint256)
func (_IOutbox *IOutboxSession) L2ToL1Timestamp() (*big.Int, error) {
	return _IOutbox.Contract.L2ToL1Timestamp(&_IOutbox.CallOpts)
}

// L2ToL1Timestamp is a free data retrieval call binding the contract method 0xb0f30537.
//
// Solidity: function l2ToL1Timestamp() view returns(uint256)
func (_IOutbox *IOutboxCallerSession) L2ToL1Timestamp() (*big.Int, error) {
	return _IOutbox.Contract.L2ToL1Timestamp(&_IOutbox.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_IOutbox *IOutboxCaller) Rollup(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "rollup")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_IOutbox *IOutboxSession) Rollup() (common.Address, error) {
	return _IOutbox.Contract.Rollup(&_IOutbox.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_IOutbox *IOutboxCallerSession) Rollup() (common.Address, error) {
	return _IOutbox.Contract.Rollup(&_IOutbox.CallOpts)
}

// Roots is a free data retrieval call binding the contract method 0xae6dead7.
//
// Solidity: function roots(bytes32 ) view returns(bytes32)
func (_IOutbox *IOutboxCaller) Roots(opts *bind.CallOpts, arg0 [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "roots", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Roots is a free data retrieval call binding the contract method 0xae6dead7.
//
// Solidity: function roots(bytes32 ) view returns(bytes32)
func (_IOutbox *IOutboxSession) Roots(arg0 [32]byte) ([32]byte, error) {
	return _IOutbox.Contract.Roots(&_IOutbox.CallOpts, arg0)
}

// Roots is a free data retrieval call binding the contract method 0xae6dead7.
//
// Solidity: function roots(bytes32 ) view returns(bytes32)
func (_IOutbox *IOutboxCallerSession) Roots(arg0 [32]byte) ([32]byte, error) {
	return _IOutbox.Contract.Roots(&_IOutbox.CallOpts, arg0)
}

// Spent is a free data retrieval call binding the contract method 0xd5b5cc23.
//
// Solidity: function spent(uint256 ) view returns(bytes32)
func (_IOutbox *IOutboxCaller) Spent(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _IOutbox.contract.Call(opts, &out, "spent", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Spent is a free data retrieval call binding the contract method 0xd5b5cc23.
//
// Solidity: function spent(uint256 ) view returns(bytes32)
func (_IOutbox *IOutboxSession) Spent(arg0 *big.Int) ([32]byte, error) {
	return _IOutbox.Contract.Spent(&_IOutbox.CallOpts, arg0)
}

// Spent is a free data retrieval call binding the contract method 0xd5b5cc23.
//
// Solidity: function spent(uint256 ) view returns(bytes32)
func (_IOutbox *IOutboxCallerSession) Spent(arg0 *big.Int) ([32]byte, error) {
	return _IOutbox.Contract.Spent(&_IOutbox.CallOpts, arg0)
}

// ExecuteTransaction is a paid mutator transaction binding the contract method 0x08635a95.
//
// Solidity: function executeTransaction(bytes32[] proof, uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_IOutbox *IOutboxTransactor) ExecuteTransaction(opts *bind.TransactOpts, proof [][32]byte, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IOutbox.contract.Transact(opts, "executeTransaction", proof, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransaction is a paid mutator transaction binding the contract method 0x08635a95.
//
// Solidity: function executeTransaction(bytes32[] proof, uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_IOutbox *IOutboxSession) ExecuteTransaction(proof [][32]byte, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IOutbox.Contract.ExecuteTransaction(&_IOutbox.TransactOpts, proof, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransaction is a paid mutator transaction binding the contract method 0x08635a95.
//
// Solidity: function executeTransaction(bytes32[] proof, uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_IOutbox *IOutboxTransactorSession) ExecuteTransaction(proof [][32]byte, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IOutbox.Contract.ExecuteTransaction(&_IOutbox.TransactOpts, proof, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransactionSimulation is a paid mutator transaction binding the contract method 0x288e5b10.
//
// Solidity: function executeTransactionSimulation(uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_IOutbox *IOutboxTransactor) ExecuteTransactionSimulation(opts *bind.TransactOpts, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IOutbox.contract.Transact(opts, "executeTransactionSimulation", index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransactionSimulation is a paid mutator transaction binding the contract method 0x288e5b10.
//
// Solidity: function executeTransactionSimulation(uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_IOutbox *IOutboxSession) ExecuteTransactionSimulation(index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IOutbox.Contract.ExecuteTransactionSimulation(&_IOutbox.TransactOpts, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransactionSimulation is a paid mutator transaction binding the contract method 0x288e5b10.
//
// Solidity: function executeTransactionSimulation(uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_IOutbox *IOutboxTransactorSession) ExecuteTransactionSimulation(index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _IOutbox.Contract.ExecuteTransactionSimulation(&_IOutbox.TransactOpts, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _bridge) returns()
func (_IOutbox *IOutboxTransactor) Initialize(opts *bind.TransactOpts, _bridge common.Address) (*types.Transaction, error) {
	return _IOutbox.contract.Transact(opts, "initialize", _bridge)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _bridge) returns()
func (_IOutbox *IOutboxSession) Initialize(_bridge common.Address) (*types.Transaction, error) {
	return _IOutbox.Contract.Initialize(&_IOutbox.TransactOpts, _bridge)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _bridge) returns()
func (_IOutbox *IOutboxTransactorSession) Initialize(_bridge common.Address) (*types.Transaction, error) {
	return _IOutbox.Contract.Initialize(&_IOutbox.TransactOpts, _bridge)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0x95fcea78.
//
// Solidity: function postUpgradeInit() returns()
func (_IOutbox *IOutboxTransactor) PostUpgradeInit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IOutbox.contract.Transact(opts, "postUpgradeInit")
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0x95fcea78.
//
// Solidity: function postUpgradeInit() returns()
func (_IOutbox *IOutboxSession) PostUpgradeInit() (*types.Transaction, error) {
	return _IOutbox.Contract.PostUpgradeInit(&_IOutbox.TransactOpts)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0x95fcea78.
//
// Solidity: function postUpgradeInit() returns()
func (_IOutbox *IOutboxTransactorSession) PostUpgradeInit() (*types.Transaction, error) {
	return _IOutbox.Contract.PostUpgradeInit(&_IOutbox.TransactOpts)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_IOutbox *IOutboxTransactor) UpdateRollupAddress(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IOutbox.contract.Transact(opts, "updateRollupAddress")
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_IOutbox *IOutboxSession) UpdateRollupAddress() (*types.Transaction, error) {
	return _IOutbox.Contract.UpdateRollupAddress(&_IOutbox.TransactOpts)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_IOutbox *IOutboxTransactorSession) UpdateRollupAddress() (*types.Transaction, error) {
	return _IOutbox.Contract.UpdateRollupAddress(&_IOutbox.TransactOpts)
}

// UpdateSendRoot is a paid mutator transaction binding the contract method 0xa04cee60.
//
// Solidity: function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) returns()
func (_IOutbox *IOutboxTransactor) UpdateSendRoot(opts *bind.TransactOpts, sendRoot [32]byte, l2BlockHash [32]byte) (*types.Transaction, error) {
	return _IOutbox.contract.Transact(opts, "updateSendRoot", sendRoot, l2BlockHash)
}

// UpdateSendRoot is a paid mutator transaction binding the contract method 0xa04cee60.
//
// Solidity: function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) returns()
func (_IOutbox *IOutboxSession) UpdateSendRoot(sendRoot [32]byte, l2BlockHash [32]byte) (*types.Transaction, error) {
	return _IOutbox.Contract.UpdateSendRoot(&_IOutbox.TransactOpts, sendRoot, l2BlockHash)
}

// UpdateSendRoot is a paid mutator transaction binding the contract method 0xa04cee60.
//
// Solidity: function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) returns()
func (_IOutbox *IOutboxTransactorSession) UpdateSendRoot(sendRoot [32]byte, l2BlockHash [32]byte) (*types.Transaction, error) {
	return _IOutbox.Contract.UpdateSendRoot(&_IOutbox.TransactOpts, sendRoot, l2BlockHash)
}

// IOutboxOutBoxTransactionExecutedIterator is returned from FilterOutBoxTransactionExecuted and is used to iterate over the raw logs and unpacked data for OutBoxTransactionExecuted events raised by the IOutbox contract.
type IOutboxOutBoxTransactionExecutedIterator struct {
	Event *IOutboxOutBoxTransactionExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IOutboxOutBoxTransactionExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IOutboxOutBoxTransactionExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IOutboxOutBoxTransactionExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IOutboxOutBoxTransactionExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IOutboxOutBoxTransactionExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IOutboxOutBoxTransactionExecuted represents a OutBoxTransactionExecuted event raised by the IOutbox contract.
type IOutboxOutBoxTransactionExecuted struct {
	To               common.Address
	L2Sender         common.Address
	Zero             *big.Int
	TransactionIndex *big.Int
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterOutBoxTransactionExecuted is a free log retrieval operation binding the contract event 0x20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab18964.
//
// Solidity: event OutBoxTransactionExecuted(address indexed to, address indexed l2Sender, uint256 indexed zero, uint256 transactionIndex)
func (_IOutbox *IOutboxFilterer) FilterOutBoxTransactionExecuted(opts *bind.FilterOpts, to []common.Address, l2Sender []common.Address, zero []*big.Int) (*IOutboxOutBoxTransactionExecutedIterator, error) {

	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var l2SenderRule []interface{}
	for _, l2SenderItem := range l2Sender {
		l2SenderRule = append(l2SenderRule, l2SenderItem)
	}
	var zeroRule []interface{}
	for _, zeroItem := range zero {
		zeroRule = append(zeroRule, zeroItem)
	}

	logs, sub, err := _IOutbox.contract.FilterLogs(opts, "OutBoxTransactionExecuted", toRule, l2SenderRule, zeroRule)
	if err != nil {
		return nil, err
	}
	return &IOutboxOutBoxTransactionExecutedIterator{contract: _IOutbox.contract, event: "OutBoxTransactionExecuted", logs: logs, sub: sub}, nil
}

// WatchOutBoxTransactionExecuted is a free log subscription operation binding the contract event 0x20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab18964.
//
// Solidity: event OutBoxTransactionExecuted(address indexed to, address indexed l2Sender, uint256 indexed zero, uint256 transactionIndex)
func (_IOutbox *IOutboxFilterer) WatchOutBoxTransactionExecuted(opts *bind.WatchOpts, sink chan<- *IOutboxOutBoxTransactionExecuted, to []common.Address, l2Sender []common.Address, zero []*big.Int) (event.Subscription, error) {

	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var l2SenderRule []interface{}
	for _, l2SenderItem := range l2Sender {
		l2SenderRule = append(l2SenderRule, l2SenderItem)
	}
	var zeroRule []interface{}
	for _, zeroItem := range zero {
		zeroRule = append(zeroRule, zeroItem)
	}

	logs, sub, err := _IOutbox.contract.WatchLogs(opts, "OutBoxTransactionExecuted", toRule, l2SenderRule, zeroRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IOutboxOutBoxTransactionExecuted)
				if err := _IOutbox.contract.UnpackLog(event, "OutBoxTransactionExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOutBoxTransactionExecuted is a log parse operation binding the contract event 0x20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab18964.
//
// Solidity: event OutBoxTransactionExecuted(address indexed to, address indexed l2Sender, uint256 indexed zero, uint256 transactionIndex)
func (_IOutbox *IOutboxFilterer) ParseOutBoxTransactionExecuted(log types.Log) (*IOutboxOutBoxTransactionExecuted, error) {
	event := new(IOutboxOutBoxTransactionExecuted)
	if err := _IOutbox.contract.UnpackLog(event, "OutBoxTransactionExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IOutboxSendRootUpdatedIterator is returned from FilterSendRootUpdated and is used to iterate over the raw logs and unpacked data for SendRootUpdated events raised by the IOutbox contract.
type IOutboxSendRootUpdatedIterator struct {
	Event *IOutboxSendRootUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IOutboxSendRootUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IOutboxSendRootUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IOutboxSendRootUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IOutboxSendRootUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IOutboxSendRootUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IOutboxSendRootUpdated represents a SendRootUpdated event raised by the IOutbox contract.
type IOutboxSendRootUpdated struct {
	OutputRoot  [32]byte
	L2BlockHash [32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSendRootUpdated is a free log retrieval operation binding the contract event 0xb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f6748.
//
// Solidity: event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash)
func (_IOutbox *IOutboxFilterer) FilterSendRootUpdated(opts *bind.FilterOpts, outputRoot [][32]byte, l2BlockHash [][32]byte) (*IOutboxSendRootUpdatedIterator, error) {

	var outputRootRule []interface{}
	for _, outputRootItem := range outputRoot {
		outputRootRule = append(outputRootRule, outputRootItem)
	}
	var l2BlockHashRule []interface{}
	for _, l2BlockHashItem := range l2BlockHash {
		l2BlockHashRule = append(l2BlockHashRule, l2BlockHashItem)
	}

	logs, sub, err := _IOutbox.contract.FilterLogs(opts, "SendRootUpdated", outputRootRule, l2BlockHashRule)
	if err != nil {
		return nil, err
	}
	return &IOutboxSendRootUpdatedIterator{contract: _IOutbox.contract, event: "SendRootUpdated", logs: logs, sub: sub}, nil
}

// WatchSendRootUpdated is a free log subscription operation binding the contract event 0xb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f6748.
//
// Solidity: event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash)
func (_IOutbox *IOutboxFilterer) WatchSendRootUpdated(opts *bind.WatchOpts, sink chan<- *IOutboxSendRootUpdated, outputRoot [][32]byte, l2BlockHash [][32]byte) (event.Subscription, error) {

	var outputRootRule []interface{}
	for _, outputRootItem := range outputRoot {
		outputRootRule = append(outputRootRule, outputRootItem)
	}
	var l2BlockHashRule []interface{}
	for _, l2BlockHashItem := range l2BlockHash {
		l2BlockHashRule = append(l2BlockHashRule, l2BlockHashItem)
	}

	logs, sub, err := _IOutbox.contract.WatchLogs(opts, "SendRootUpdated", outputRootRule, l2BlockHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IOutboxSendRootUpdated)
				if err := _IOutbox.contract.UnpackLog(event, "SendRootUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSendRootUpdated is a log parse operation binding the contract event 0xb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f6748.
//
// Solidity: event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash)
func (_IOutbox *IOutboxFilterer) ParseSendRootUpdated(log types.Log) (*IOutboxSendRootUpdated, error) {
	event := new(IOutboxSendRootUpdated)
	if err := _IOutbox.contract.UnpackLog(event, "SendRootUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// IOwnableMetaData contains all meta data concerning the IOwnable contract.
var IOwnableMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]",
}

// IOwnableABI is the input ABI used to generate the binding from.
// Deprecated: Use IOwnableMetaData.ABI instead.
var IOwnableABI = IOwnableMetaData.ABI

// IOwnable is an auto generated Go binding around an Ethereum contract.
type IOwnable struct {
	IOwnableCaller     // Read-only binding to the contract
	IOwnableTransactor // Write-only binding to the contract
	IOwnableFilterer   // Log filterer for contract events
}

// IOwnableCaller is an auto generated read-only Go binding around an Ethereum contract.
type IOwnableCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IOwnableTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IOwnableTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IOwnableFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IOwnableFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IOwnableSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IOwnableSession struct {
	Contract     *IOwnable         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// IOwnableCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IOwnableCallerSession struct {
	Contract *IOwnableCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// IOwnableTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IOwnableTransactorSession struct {
	Contract     *IOwnableTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// IOwnableRaw is an auto generated low-level Go binding around an Ethereum contract.
type IOwnableRaw struct {
	Contract *IOwnable // Generic contract binding to access the raw methods on
}

// IOwnableCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IOwnableCallerRaw struct {
	Contract *IOwnableCaller // Generic read-only contract binding to access the raw methods on
}

// IOwnableTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IOwnableTransactorRaw struct {
	Contract *IOwnableTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIOwnable creates a new instance of IOwnable, bound to a specific deployed contract.
func NewIOwnable(address common.Address, backend bind.ContractBackend) (*IOwnable, error) {
	contract, err := bindIOwnable(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IOwnable{IOwnableCaller: IOwnableCaller{contract: contract}, IOwnableTransactor: IOwnableTransactor{contract: contract}, IOwnableFilterer: IOwnableFilterer{contract: contract}}, nil
}

// NewIOwnableCaller creates a new read-only instance of IOwnable, bound to a specific deployed contract.
func NewIOwnableCaller(address common.Address, caller bind.ContractCaller) (*IOwnableCaller, error) {
	contract, err := bindIOwnable(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IOwnableCaller{contract: contract}, nil
}

// NewIOwnableTransactor creates a new write-only instance of IOwnable, bound to a specific deployed contract.
func NewIOwnableTransactor(address common.Address, transactor bind.ContractTransactor) (*IOwnableTransactor, error) {
	contract, err := bindIOwnable(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IOwnableTransactor{contract: contract}, nil
}

// NewIOwnableFilterer creates a new log filterer instance of IOwnable, bound to a specific deployed contract.
func NewIOwnableFilterer(address common.Address, filterer bind.ContractFilterer) (*IOwnableFilterer, error) {
	contract, err := bindIOwnable(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IOwnableFilterer{contract: contract}, nil
}

// bindIOwnable binds a generic wrapper to an already deployed contract.
func bindIOwnable(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := IOwnableMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IOwnable *IOwnableRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IOwnable.Contract.IOwnableCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IOwnable *IOwnableRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IOwnable.Contract.IOwnableTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IOwnable *IOwnableRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IOwnable.Contract.IOwnableTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IOwnable *IOwnableCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _IOwnable.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IOwnable *IOwnableTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IOwnable.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IOwnable *IOwnableTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IOwnable.Contract.contract.Transact(opts, method, params...)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_IOwnable *IOwnableCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _IOwnable.contract.Call(opts, &out, "owner")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_IOwnable *IOwnableSession) Owner() (common.Address, error) {
	return _IOwnable.Contract.Owner(&_IOwnable.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() view returns(address)
func (_IOwnable *IOwnableCallerSession) Owner() (common.Address, error) {
	return _IOwnable.Contract.Owner(&_IOwnable.CallOpts)
}

// ISequencerInboxMetaData contains all meta data concerning the ISequencerInbox contract.
var ISequencerInboxMetaData = &bind.MetaData{
	ABI: "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBatchPosterManager\",\"type\":\"address\"}],\"name\":\"BatchPosterManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"batchPoster\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBatchPoster\",\"type\":\"bool\"}],\"name\":\"BatchPosterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"threshold\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"replenishRateInBasis\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"structBufferConfig\",\"name\":\"bufferConfig\",\"type\":\"tuple\"}],\"name\":\"BufferConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeTokenPricer\",\"type\":\"address\"}],\"name\":\"FeeTokenPricerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"keysetHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidateKeyset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"structISequencerInbox.MaxTimeVariation\",\"name\":\"maxTimeVariation\",\"type\":\"tuple\"}],\"name\":\"MaxTimeVariationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OwnerFunctionCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchSequenceNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SequencerBatchData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchSequenceNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beforeAcc\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"afterAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"delayedAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"minTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minBlockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxBlockNumber\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"structIBridge.TimeBounds\",\"name\":\"timeBounds\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"enumIBridge.BatchDataLocation\",\"name\":\"dataLocation\",\"type\":\"uint8\"}],\"name\":\"SequencerBatchDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSequencer\",\"type\":\"bool\"}],\"name\":\"SequencerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"keysetHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"keysetBytes\",\"type\":\"bytes\"}],\"name\":\"SetValidKeyset\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BROTLI_MESSAGE_HEADER_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CELESTIA_MESSAGE_HEADER_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAS_MESSAGE_HEADER_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DATA_AUTHENTICATED_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DATA_BLOB_HEADER_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HEADER_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TREE_DAS_MESSAGE_HEADER_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO_HEAVY_MESSAGE_HEADER_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"}],\"name\":\"addSequencerL2Batch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"beforeDelayedAcc\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"inboxSeqNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"internalType\":\"structMessages.Message\",\"name\":\"delayedMessage\",\"type\":\"tuple\"}],\"internalType\":\"structDelayProof\",\"name\":\"delayProof\",\"type\":\"tuple\"}],\"name\":\"addSequencerL2BatchDelayProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"}],\"name\":\"addSequencerL2BatchFromBlobs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"beforeDelayedAcc\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"inboxSeqNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"internalType\":\"structMessages.Message\",\"name\":\"delayedMessage\",\"type\":\"tuple\"}],\"internalType\":\"structDelayProof\",\"name\":\"delayProof\",\"type\":\"tuple\"}],\"name\":\"addSequencerL2BatchFromBlobsDelayProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"}],\"name\":\"addSequencerL2BatchFromOrigin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"}],\"name\":\"addSequencerL2BatchFromOrigin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"beforeDelayedAcc\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"inboxSeqNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"internalType\":\"structMessages.Message\",\"name\":\"delayedMessage\",\"type\":\"tuple\"}],\"internalType\":\"structDelayProof\",\"name\":\"delayProof\",\"type\":\"tuple\"}],\"name\":\"addSequencerL2BatchFromOriginDelayProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchPosterManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"dasKeySetInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTokenPricer\",\"outputs\":[{\"internalType\":\"contractIFeeTokenPricer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"uint64[2]\",\"name\":\"l1BlockAndTime\",\"type\":\"uint64[2]\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"name\":\"forceInclusion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"}],\"name\":\"forceInclusionDeadline\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"blockNumberDeadline\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ksHash\",\"type\":\"bytes32\"}],\"name\":\"getKeysetCreationBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"inboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"bridge_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structISequencerInbox.MaxTimeVariation\",\"name\":\"maxTimeVariation_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"threshold\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"replenishRateInBasis\",\"type\":\"uint64\"}],\"internalType\":\"structBufferConfig\",\"name\":\"bufferConfig_\",\"type\":\"tuple\"},{\"internalType\":\"contractIFeeTokenPricer\",\"name\":\"feeTokenPricer_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ksHash\",\"type\":\"bytes32\"}],\"name\":\"invalidateKeysetHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBatchPoster\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDelayBufferable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSequencer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ksHash\",\"type\":\"bytes32\"}],\"name\":\"isValidKeysetHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDataSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTimeVariation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeDelayAfterFork\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBatchPosterManager\",\"type\":\"address\"}],\"name\":\"setBatchPosterManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIFeeTokenPricer\",\"name\":\"newFeeTokenPricer\",\"type\":\"address\"}],\"name\":\"setFeeTokenPricer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBatchPoster_\",\"type\":\"bool\"}],\"name\":\"setIsBatchPoster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSequencer_\",\"type\":\"bool\"}],\"name\":\"setIsSequencer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structISequencerInbox.MaxTimeVariation\",\"name\":\"maxTimeVariation_\",\"type\":\"tuple\"}],\"name\":\"setMaxTimeVariation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"keysetBytes\",\"type\":\"bytes\"}],\"name\":\"setValidKeyset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDelayedMessagesRead\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
}

// ISequencerInboxABI is the input ABI used to generate the binding from.
// Deprecated: Use ISequencerInboxMetaData.ABI instead.
var ISequencerInboxABI = ISequencerInboxMetaData.ABI

// ISequencerInbox is an auto generated Go binding around an Ethereum contract.
type ISequencerInbox struct {
	ISequencerInboxCaller     // Read-only binding to the contract
	ISequencerInboxTransactor // Write-only binding to the contract
	ISequencerInboxFilterer   // Log filterer for contract events
}

// ISequencerInboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type ISequencerInboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISequencerInboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ISequencerInboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISequencerInboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ISequencerInboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ISequencerInboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ISequencerInboxSession struct {
	Contract     *ISequencerInbox  // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ISequencerInboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ISequencerInboxCallerSession struct {
	Contract *ISequencerInboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts          // Call options to use throughout this session
}

// ISequencerInboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ISequencerInboxTransactorSession struct {
	Contract     *ISequencerInboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts          // Transaction auth options to use throughout this session
}

// ISequencerInboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type ISequencerInboxRaw struct {
	Contract *ISequencerInbox // Generic contract binding to access the raw methods on
}

// ISequencerInboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ISequencerInboxCallerRaw struct {
	Contract *ISequencerInboxCaller // Generic read-only contract binding to access the raw methods on
}

// ISequencerInboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ISequencerInboxTransactorRaw struct {
	Contract *ISequencerInboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewISequencerInbox creates a new instance of ISequencerInbox, bound to a specific deployed contract.
func NewISequencerInbox(address common.Address, backend bind.ContractBackend) (*ISequencerInbox, error) {
	contract, err := bindISequencerInbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ISequencerInbox{ISequencerInboxCaller: ISequencerInboxCaller{contract: contract}, ISequencerInboxTransactor: ISequencerInboxTransactor{contract: contract}, ISequencerInboxFilterer: ISequencerInboxFilterer{contract: contract}}, nil
}

// NewISequencerInboxCaller creates a new read-only instance of ISequencerInbox, bound to a specific deployed contract.
func NewISequencerInboxCaller(address common.Address, caller bind.ContractCaller) (*ISequencerInboxCaller, error) {
	contract, err := bindISequencerInbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxCaller{contract: contract}, nil
}

// NewISequencerInboxTransactor creates a new write-only instance of ISequencerInbox, bound to a specific deployed contract.
func NewISequencerInboxTransactor(address common.Address, transactor bind.ContractTransactor) (*ISequencerInboxTransactor, error) {
	contract, err := bindISequencerInbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxTransactor{contract: contract}, nil
}

// NewISequencerInboxFilterer creates a new log filterer instance of ISequencerInbox, bound to a specific deployed contract.
func NewISequencerInboxFilterer(address common.Address, filterer bind.ContractFilterer) (*ISequencerInboxFilterer, error) {
	contract, err := bindISequencerInbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxFilterer{contract: contract}, nil
}

// bindISequencerInbox binds a generic wrapper to an already deployed contract.
func bindISequencerInbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := ISequencerInboxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ISequencerInbox *ISequencerInboxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ISequencerInbox.Contract.ISequencerInboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ISequencerInbox *ISequencerInboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.ISequencerInboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ISequencerInbox *ISequencerInboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.ISequencerInboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ISequencerInbox *ISequencerInboxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _ISequencerInbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ISequencerInbox *ISequencerInboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ISequencerInbox *ISequencerInboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.contract.Transact(opts, method, params...)
}

// BROTLIMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x16af91a7.
//
// Solidity: function BROTLI_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCaller) BROTLIMESSAGEHEADERFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "BROTLI_MESSAGE_HEADER_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// BROTLIMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x16af91a7.
//
// Solidity: function BROTLI_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxSession) BROTLIMESSAGEHEADERFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.BROTLIMESSAGEHEADERFLAG(&_ISequencerInbox.CallOpts)
}

// BROTLIMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x16af91a7.
//
// Solidity: function BROTLI_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCallerSession) BROTLIMESSAGEHEADERFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.BROTLIMESSAGEHEADERFLAG(&_ISequencerInbox.CallOpts)
}

// CELESTIAMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x5fd9e56d.
//
// Solidity: function CELESTIA_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCaller) CELESTIAMESSAGEHEADERFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "CELESTIA_MESSAGE_HEADER_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// CELESTIAMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x5fd9e56d.
//
// Solidity: function CELESTIA_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxSession) CELESTIAMESSAGEHEADERFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.CELESTIAMESSAGEHEADERFLAG(&_ISequencerInbox.CallOpts)
}

// CELESTIAMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x5fd9e56d.
//
// Solidity: function CELESTIA_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCallerSession) CELESTIAMESSAGEHEADERFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.CELESTIAMESSAGEHEADERFLAG(&_ISequencerInbox.CallOpts)
}

// DASMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0xf60a5091.
//
// Solidity: function DAS_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCaller) DASMESSAGEHEADERFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "DAS_MESSAGE_HEADER_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// DASMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0xf60a5091.
//
// Solidity: function DAS_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxSession) DASMESSAGEHEADERFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.DASMESSAGEHEADERFLAG(&_ISequencerInbox.CallOpts)
}

// DASMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0xf60a5091.
//
// Solidity: function DAS_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCallerSession) DASMESSAGEHEADERFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.DASMESSAGEHEADERFLAG(&_ISequencerInbox.CallOpts)
}

// DATAAUTHENTICATEDFLAG is a free data retrieval call binding the contract method 0xe5a358c8.
//
// Solidity: function DATA_AUTHENTICATED_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCaller) DATAAUTHENTICATEDFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "DATA_AUTHENTICATED_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// DATAAUTHENTICATEDFLAG is a free data retrieval call binding the contract method 0xe5a358c8.
//
// Solidity: function DATA_AUTHENTICATED_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxSession) DATAAUTHENTICATEDFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.DATAAUTHENTICATEDFLAG(&_ISequencerInbox.CallOpts)
}

// DATAAUTHENTICATEDFLAG is a free data retrieval call binding the contract method 0xe5a358c8.
//
// Solidity: function DATA_AUTHENTICATED_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCallerSession) DATAAUTHENTICATEDFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.DATAAUTHENTICATEDFLAG(&_ISequencerInbox.CallOpts)
}

// DATABLOBHEADERFLAG is a free data retrieval call binding the contract method 0x2cbf74e5.
//
// Solidity: function DATA_BLOB_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCaller) DATABLOBHEADERFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "DATA_BLOB_HEADER_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// DATABLOBHEADERFLAG is a free data retrieval call binding the contract method 0x2cbf74e5.
//
// Solidity: function DATA_BLOB_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxSession) DATABLOBHEADERFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.DATABLOBHEADERFLAG(&_ISequencerInbox.CallOpts)
}

// DATABLOBHEADERFLAG is a free data retrieval call binding the contract method 0x2cbf74e5.
//
// Solidity: function DATA_BLOB_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCallerSession) DATABLOBHEADERFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.DATABLOBHEADERFLAG(&_ISequencerInbox.CallOpts)
}

// HEADERLENGTH is a free data retrieval call binding the contract method 0x27957a49.
//
// Solidity: function HEADER_LENGTH() view returns(uint256)
func (_ISequencerInbox *ISequencerInboxCaller) HEADERLENGTH(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "HEADER_LENGTH")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// HEADERLENGTH is a free data retrieval call binding the contract method 0x27957a49.
//
// Solidity: function HEADER_LENGTH() view returns(uint256)
func (_ISequencerInbox *ISequencerInboxSession) HEADERLENGTH() (*big.Int, error) {
	return _ISequencerInbox.Contract.HEADERLENGTH(&_ISequencerInbox.CallOpts)
}

// HEADERLENGTH is a free data retrieval call binding the contract method 0x27957a49.
//
// Solidity: function HEADER_LENGTH() view returns(uint256)
func (_ISequencerInbox *ISequencerInboxCallerSession) HEADERLENGTH() (*big.Int, error) {
	return _ISequencerInbox.Contract.HEADERLENGTH(&_ISequencerInbox.CallOpts)
}

// TREEDASMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x6c890450.
//
// Solidity: function TREE_DAS_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCaller) TREEDASMESSAGEHEADERFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "TREE_DAS_MESSAGE_HEADER_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// TREEDASMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x6c890450.
//
// Solidity: function TREE_DAS_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxSession) TREEDASMESSAGEHEADERFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.TREEDASMESSAGEHEADERFLAG(&_ISequencerInbox.CallOpts)
}

// TREEDASMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x6c890450.
//
// Solidity: function TREE_DAS_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCallerSession) TREEDASMESSAGEHEADERFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.TREEDASMESSAGEHEADERFLAG(&_ISequencerInbox.CallOpts)
}

// ZEROHEAVYMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x02c99275.
//
// Solidity: function ZERO_HEAVY_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCaller) ZEROHEAVYMESSAGEHEADERFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "ZERO_HEAVY_MESSAGE_HEADER_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// ZEROHEAVYMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x02c99275.
//
// Solidity: function ZERO_HEAVY_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxSession) ZEROHEAVYMESSAGEHEADERFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.ZEROHEAVYMESSAGEHEADERFLAG(&_ISequencerInbox.CallOpts)
}

// ZEROHEAVYMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x02c99275.
//
// Solidity: function ZERO_HEAVY_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_ISequencerInbox *ISequencerInboxCallerSession) ZEROHEAVYMESSAGEHEADERFLAG() ([1]byte, error) {
	return _ISequencerInbox.Contract.ZEROHEAVYMESSAGEHEADERFLAG(&_ISequencerInbox.CallOpts)
}

// BatchCount is a free data retrieval call binding the contract method 0x06f13056.
//
// Solidity: function batchCount() view returns(uint256)
func (_ISequencerInbox *ISequencerInboxCaller) BatchCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "batchCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BatchCount is a free data retrieval call binding the contract method 0x06f13056.
//
// Solidity: function batchCount() view returns(uint256)
func (_ISequencerInbox *ISequencerInboxSession) BatchCount() (*big.Int, error) {
	return _ISequencerInbox.Contract.BatchCount(&_ISequencerInbox.CallOpts)
}

// BatchCount is a free data retrieval call binding the contract method 0x06f13056.
//
// Solidity: function batchCount() view returns(uint256)
func (_ISequencerInbox *ISequencerInboxCallerSession) BatchCount() (*big.Int, error) {
	return _ISequencerInbox.Contract.BatchCount(&_ISequencerInbox.CallOpts)
}

// BatchPosterManager is a free data retrieval call binding the contract method 0xcc2a1a0c.
//
// Solidity: function batchPosterManager() view returns(address)
func (_ISequencerInbox *ISequencerInboxCaller) BatchPosterManager(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "batchPosterManager")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BatchPosterManager is a free data retrieval call binding the contract method 0xcc2a1a0c.
//
// Solidity: function batchPosterManager() view returns(address)
func (_ISequencerInbox *ISequencerInboxSession) BatchPosterManager() (common.Address, error) {
	return _ISequencerInbox.Contract.BatchPosterManager(&_ISequencerInbox.CallOpts)
}

// BatchPosterManager is a free data retrieval call binding the contract method 0xcc2a1a0c.
//
// Solidity: function batchPosterManager() view returns(address)
func (_ISequencerInbox *ISequencerInboxCallerSession) BatchPosterManager() (common.Address, error) {
	return _ISequencerInbox.Contract.BatchPosterManager(&_ISequencerInbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_ISequencerInbox *ISequencerInboxCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_ISequencerInbox *ISequencerInboxSession) Bridge() (common.Address, error) {
	return _ISequencerInbox.Contract.Bridge(&_ISequencerInbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_ISequencerInbox *ISequencerInboxCallerSession) Bridge() (common.Address, error) {
	return _ISequencerInbox.Contract.Bridge(&_ISequencerInbox.CallOpts)
}

// DasKeySetInfo is a free data retrieval call binding the contract method 0x715ea34b.
//
// Solidity: function dasKeySetInfo(bytes32 ) view returns(bool, uint64)
func (_ISequencerInbox *ISequencerInboxCaller) DasKeySetInfo(opts *bind.CallOpts, arg0 [32]byte) (bool, uint64, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "dasKeySetInfo", arg0)

	if err != nil {
		return *new(bool), *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)
	out1 := *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return out0, out1, err

}

// DasKeySetInfo is a free data retrieval call binding the contract method 0x715ea34b.
//
// Solidity: function dasKeySetInfo(bytes32 ) view returns(bool, uint64)
func (_ISequencerInbox *ISequencerInboxSession) DasKeySetInfo(arg0 [32]byte) (bool, uint64, error) {
	return _ISequencerInbox.Contract.DasKeySetInfo(&_ISequencerInbox.CallOpts, arg0)
}

// DasKeySetInfo is a free data retrieval call binding the contract method 0x715ea34b.
//
// Solidity: function dasKeySetInfo(bytes32 ) view returns(bool, uint64)
func (_ISequencerInbox *ISequencerInboxCallerSession) DasKeySetInfo(arg0 [32]byte) (bool, uint64, error) {
	return _ISequencerInbox.Contract.DasKeySetInfo(&_ISequencerInbox.CallOpts, arg0)
}

// FeeTokenPricer is a free data retrieval call binding the contract method 0x22291e8d.
//
// Solidity: function feeTokenPricer() view returns(address)
func (_ISequencerInbox *ISequencerInboxCaller) FeeTokenPricer(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "feeTokenPricer")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// FeeTokenPricer is a free data retrieval call binding the contract method 0x22291e8d.
//
// Solidity: function feeTokenPricer() view returns(address)
func (_ISequencerInbox *ISequencerInboxSession) FeeTokenPricer() (common.Address, error) {
	return _ISequencerInbox.Contract.FeeTokenPricer(&_ISequencerInbox.CallOpts)
}

// FeeTokenPricer is a free data retrieval call binding the contract method 0x22291e8d.
//
// Solidity: function feeTokenPricer() view returns(address)
func (_ISequencerInbox *ISequencerInboxCallerSession) FeeTokenPricer() (common.Address, error) {
	return _ISequencerInbox.Contract.FeeTokenPricer(&_ISequencerInbox.CallOpts)
}

// ForceInclusionDeadline is a free data retrieval call binding the contract method 0xdd44e6e0.
//
// Solidity: function forceInclusionDeadline(uint64 blockNumber) view returns(uint64 blockNumberDeadline)
func (_ISequencerInbox *ISequencerInboxCaller) ForceInclusionDeadline(opts *bind.CallOpts, blockNumber uint64) (uint64, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "forceInclusionDeadline", blockNumber)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// ForceInclusionDeadline is a free data retrieval call binding the contract method 0xdd44e6e0.
//
// Solidity: function forceInclusionDeadline(uint64 blockNumber) view returns(uint64 blockNumberDeadline)
func (_ISequencerInbox *ISequencerInboxSession) ForceInclusionDeadline(blockNumber uint64) (uint64, error) {
	return _ISequencerInbox.Contract.ForceInclusionDeadline(&_ISequencerInbox.CallOpts, blockNumber)
}

// ForceInclusionDeadline is a free data retrieval call binding the contract method 0xdd44e6e0.
//
// Solidity: function forceInclusionDeadline(uint64 blockNumber) view returns(uint64 blockNumberDeadline)
func (_ISequencerInbox *ISequencerInboxCallerSession) ForceInclusionDeadline(blockNumber uint64) (uint64, error) {
	return _ISequencerInbox.Contract.ForceInclusionDeadline(&_ISequencerInbox.CallOpts, blockNumber)
}

// GetKeysetCreationBlock is a free data retrieval call binding the contract method 0x258f0495.
//
// Solidity: function getKeysetCreationBlock(bytes32 ksHash) view returns(uint256)
func (_ISequencerInbox *ISequencerInboxCaller) GetKeysetCreationBlock(opts *bind.CallOpts, ksHash [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "getKeysetCreationBlock", ksHash)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetKeysetCreationBlock is a free data retrieval call binding the contract method 0x258f0495.
//
// Solidity: function getKeysetCreationBlock(bytes32 ksHash) view returns(uint256)
func (_ISequencerInbox *ISequencerInboxSession) GetKeysetCreationBlock(ksHash [32]byte) (*big.Int, error) {
	return _ISequencerInbox.Contract.GetKeysetCreationBlock(&_ISequencerInbox.CallOpts, ksHash)
}

// GetKeysetCreationBlock is a free data retrieval call binding the contract method 0x258f0495.
//
// Solidity: function getKeysetCreationBlock(bytes32 ksHash) view returns(uint256)
func (_ISequencerInbox *ISequencerInboxCallerSession) GetKeysetCreationBlock(ksHash [32]byte) (*big.Int, error) {
	return _ISequencerInbox.Contract.GetKeysetCreationBlock(&_ISequencerInbox.CallOpts, ksHash)
}

// InboxAccs is a free data retrieval call binding the contract method 0xd9dd67ab.
//
// Solidity: function inboxAccs(uint256 index) view returns(bytes32)
func (_ISequencerInbox *ISequencerInboxCaller) InboxAccs(opts *bind.CallOpts, index *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "inboxAccs", index)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// InboxAccs is a free data retrieval call binding the contract method 0xd9dd67ab.
//
// Solidity: function inboxAccs(uint256 index) view returns(bytes32)
func (_ISequencerInbox *ISequencerInboxSession) InboxAccs(index *big.Int) ([32]byte, error) {
	return _ISequencerInbox.Contract.InboxAccs(&_ISequencerInbox.CallOpts, index)
}

// InboxAccs is a free data retrieval call binding the contract method 0xd9dd67ab.
//
// Solidity: function inboxAccs(uint256 index) view returns(bytes32)
func (_ISequencerInbox *ISequencerInboxCallerSession) InboxAccs(index *big.Int) ([32]byte, error) {
	return _ISequencerInbox.Contract.InboxAccs(&_ISequencerInbox.CallOpts, index)
}

// IsBatchPoster is a free data retrieval call binding the contract method 0x71c3e6fe.
//
// Solidity: function isBatchPoster(address ) view returns(bool)
func (_ISequencerInbox *ISequencerInboxCaller) IsBatchPoster(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "isBatchPoster", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsBatchPoster is a free data retrieval call binding the contract method 0x71c3e6fe.
//
// Solidity: function isBatchPoster(address ) view returns(bool)
func (_ISequencerInbox *ISequencerInboxSession) IsBatchPoster(arg0 common.Address) (bool, error) {
	return _ISequencerInbox.Contract.IsBatchPoster(&_ISequencerInbox.CallOpts, arg0)
}

// IsBatchPoster is a free data retrieval call binding the contract method 0x71c3e6fe.
//
// Solidity: function isBatchPoster(address ) view returns(bool)
func (_ISequencerInbox *ISequencerInboxCallerSession) IsBatchPoster(arg0 common.Address) (bool, error) {
	return _ISequencerInbox.Contract.IsBatchPoster(&_ISequencerInbox.CallOpts, arg0)
}

// IsDelayBufferable is a free data retrieval call binding the contract method 0x4b678a66.
//
// Solidity: function isDelayBufferable() view returns(bool)
func (_ISequencerInbox *ISequencerInboxCaller) IsDelayBufferable(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "isDelayBufferable")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsDelayBufferable is a free data retrieval call binding the contract method 0x4b678a66.
//
// Solidity: function isDelayBufferable() view returns(bool)
func (_ISequencerInbox *ISequencerInboxSession) IsDelayBufferable() (bool, error) {
	return _ISequencerInbox.Contract.IsDelayBufferable(&_ISequencerInbox.CallOpts)
}

// IsDelayBufferable is a free data retrieval call binding the contract method 0x4b678a66.
//
// Solidity: function isDelayBufferable() view returns(bool)
func (_ISequencerInbox *ISequencerInboxCallerSession) IsDelayBufferable() (bool, error) {
	return _ISequencerInbox.Contract.IsDelayBufferable(&_ISequencerInbox.CallOpts)
}

// IsSequencer is a free data retrieval call binding the contract method 0x6d46e987.
//
// Solidity: function isSequencer(address ) view returns(bool)
func (_ISequencerInbox *ISequencerInboxCaller) IsSequencer(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "isSequencer", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSequencer is a free data retrieval call binding the contract method 0x6d46e987.
//
// Solidity: function isSequencer(address ) view returns(bool)
func (_ISequencerInbox *ISequencerInboxSession) IsSequencer(arg0 common.Address) (bool, error) {
	return _ISequencerInbox.Contract.IsSequencer(&_ISequencerInbox.CallOpts, arg0)
}

// IsSequencer is a free data retrieval call binding the contract method 0x6d46e987.
//
// Solidity: function isSequencer(address ) view returns(bool)
func (_ISequencerInbox *ISequencerInboxCallerSession) IsSequencer(arg0 common.Address) (bool, error) {
	return _ISequencerInbox.Contract.IsSequencer(&_ISequencerInbox.CallOpts, arg0)
}

// IsValidKeysetHash is a free data retrieval call binding the contract method 0x1637be48.
//
// Solidity: function isValidKeysetHash(bytes32 ksHash) view returns(bool)
func (_ISequencerInbox *ISequencerInboxCaller) IsValidKeysetHash(opts *bind.CallOpts, ksHash [32]byte) (bool, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "isValidKeysetHash", ksHash)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsValidKeysetHash is a free data retrieval call binding the contract method 0x1637be48.
//
// Solidity: function isValidKeysetHash(bytes32 ksHash) view returns(bool)
func (_ISequencerInbox *ISequencerInboxSession) IsValidKeysetHash(ksHash [32]byte) (bool, error) {
	return _ISequencerInbox.Contract.IsValidKeysetHash(&_ISequencerInbox.CallOpts, ksHash)
}

// IsValidKeysetHash is a free data retrieval call binding the contract method 0x1637be48.
//
// Solidity: function isValidKeysetHash(bytes32 ksHash) view returns(bool)
func (_ISequencerInbox *ISequencerInboxCallerSession) IsValidKeysetHash(ksHash [32]byte) (bool, error) {
	return _ISequencerInbox.Contract.IsValidKeysetHash(&_ISequencerInbox.CallOpts, ksHash)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_ISequencerInbox *ISequencerInboxCaller) MaxDataSize(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "maxDataSize")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_ISequencerInbox *ISequencerInboxSession) MaxDataSize() (*big.Int, error) {
	return _ISequencerInbox.Contract.MaxDataSize(&_ISequencerInbox.CallOpts)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_ISequencerInbox *ISequencerInboxCallerSession) MaxDataSize() (*big.Int, error) {
	return _ISequencerInbox.Contract.MaxDataSize(&_ISequencerInbox.CallOpts)
}

// MaxTimeVariation is a free data retrieval call binding the contract method 0xebea461d.
//
// Solidity: function maxTimeVariation() view returns(uint256 delayBlocks, uint256 futureBlocks, uint256 delaySeconds, uint256 futureSeconds)
func (_ISequencerInbox *ISequencerInboxCaller) MaxTimeVariation(opts *bind.CallOpts) (struct {
	DelayBlocks   *big.Int
	FutureBlocks  *big.Int
	DelaySeconds  *big.Int
	FutureSeconds *big.Int
}, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "maxTimeVariation")

	outstruct := new(struct {
		DelayBlocks   *big.Int
		FutureBlocks  *big.Int
		DelaySeconds  *big.Int
		FutureSeconds *big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.DelayBlocks = *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	outstruct.FutureBlocks = *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	outstruct.DelaySeconds = *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	outstruct.FutureSeconds = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return *outstruct, err

}

// MaxTimeVariation is a free data retrieval call binding the contract method 0xebea461d.
//
// Solidity: function maxTimeVariation() view returns(uint256 delayBlocks, uint256 futureBlocks, uint256 delaySeconds, uint256 futureSeconds)
func (_ISequencerInbox *ISequencerInboxSession) MaxTimeVariation() (struct {
	DelayBlocks   *big.Int
	FutureBlocks  *big.Int
	DelaySeconds  *big.Int
	FutureSeconds *big.Int
}, error) {
	return _ISequencerInbox.Contract.MaxTimeVariation(&_ISequencerInbox.CallOpts)
}

// MaxTimeVariation is a free data retrieval call binding the contract method 0xebea461d.
//
// Solidity: function maxTimeVariation() view returns(uint256 delayBlocks, uint256 futureBlocks, uint256 delaySeconds, uint256 futureSeconds)
func (_ISequencerInbox *ISequencerInboxCallerSession) MaxTimeVariation() (struct {
	DelayBlocks   *big.Int
	FutureBlocks  *big.Int
	DelaySeconds  *big.Int
	FutureSeconds *big.Int
}, error) {
	return _ISequencerInbox.Contract.MaxTimeVariation(&_ISequencerInbox.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_ISequencerInbox *ISequencerInboxCaller) Rollup(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "rollup")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_ISequencerInbox *ISequencerInboxSession) Rollup() (common.Address, error) {
	return _ISequencerInbox.Contract.Rollup(&_ISequencerInbox.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_ISequencerInbox *ISequencerInboxCallerSession) Rollup() (common.Address, error) {
	return _ISequencerInbox.Contract.Rollup(&_ISequencerInbox.CallOpts)
}

// TotalDelayedMessagesRead is a free data retrieval call binding the contract method 0x7fa3a40e.
//
// Solidity: function totalDelayedMessagesRead() view returns(uint256)
func (_ISequencerInbox *ISequencerInboxCaller) TotalDelayedMessagesRead(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _ISequencerInbox.contract.Call(opts, &out, "totalDelayedMessagesRead")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalDelayedMessagesRead is a free data retrieval call binding the contract method 0x7fa3a40e.
//
// Solidity: function totalDelayedMessagesRead() view returns(uint256)
func (_ISequencerInbox *ISequencerInboxSession) TotalDelayedMessagesRead() (*big.Int, error) {
	return _ISequencerInbox.Contract.TotalDelayedMessagesRead(&_ISequencerInbox.CallOpts)
}

// TotalDelayedMessagesRead is a free data retrieval call binding the contract method 0x7fa3a40e.
//
// Solidity: function totalDelayedMessagesRead() view returns(uint256)
func (_ISequencerInbox *ISequencerInboxCallerSession) TotalDelayedMessagesRead() (*big.Int, error) {
	return _ISequencerInbox.Contract.TotalDelayedMessagesRead(&_ISequencerInbox.CallOpts)
}

// AddSequencerL2Batch is a paid mutator transaction binding the contract method 0xe0bc9729.
//
// Solidity: function addSequencerL2Batch(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) AddSequencerL2Batch(opts *bind.TransactOpts, sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "addSequencerL2Batch", sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2Batch is a paid mutator transaction binding the contract method 0xe0bc9729.
//
// Solidity: function addSequencerL2Batch(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_ISequencerInbox *ISequencerInboxSession) AddSequencerL2Batch(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2Batch(&_ISequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2Batch is a paid mutator transaction binding the contract method 0xe0bc9729.
//
// Solidity: function addSequencerL2Batch(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) AddSequencerL2Batch(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2Batch(&_ISequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchDelayProof is a paid mutator transaction binding the contract method 0x6e620055.
//
// Solidity: function addSequencerL2BatchDelayProof(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) AddSequencerL2BatchDelayProof(opts *bind.TransactOpts, sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "addSequencerL2BatchDelayProof", sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchDelayProof is a paid mutator transaction binding the contract method 0x6e620055.
//
// Solidity: function addSequencerL2BatchDelayProof(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_ISequencerInbox *ISequencerInboxSession) AddSequencerL2BatchDelayProof(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2BatchDelayProof(&_ISequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchDelayProof is a paid mutator transaction binding the contract method 0x6e620055.
//
// Solidity: function addSequencerL2BatchDelayProof(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) AddSequencerL2BatchDelayProof(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2BatchDelayProof(&_ISequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchFromBlobs is a paid mutator transaction binding the contract method 0x3e5aa082.
//
// Solidity: function addSequencerL2BatchFromBlobs(uint256 sequenceNumber, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) AddSequencerL2BatchFromBlobs(opts *bind.TransactOpts, sequenceNumber *big.Int, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "addSequencerL2BatchFromBlobs", sequenceNumber, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchFromBlobs is a paid mutator transaction binding the contract method 0x3e5aa082.
//
// Solidity: function addSequencerL2BatchFromBlobs(uint256 sequenceNumber, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_ISequencerInbox *ISequencerInboxSession) AddSequencerL2BatchFromBlobs(sequenceNumber *big.Int, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2BatchFromBlobs(&_ISequencerInbox.TransactOpts, sequenceNumber, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchFromBlobs is a paid mutator transaction binding the contract method 0x3e5aa082.
//
// Solidity: function addSequencerL2BatchFromBlobs(uint256 sequenceNumber, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) AddSequencerL2BatchFromBlobs(sequenceNumber *big.Int, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2BatchFromBlobs(&_ISequencerInbox.TransactOpts, sequenceNumber, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchFromBlobsDelayProof is a paid mutator transaction binding the contract method 0x917cf8ac.
//
// Solidity: function addSequencerL2BatchFromBlobsDelayProof(uint256 sequenceNumber, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) AddSequencerL2BatchFromBlobsDelayProof(opts *bind.TransactOpts, sequenceNumber *big.Int, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "addSequencerL2BatchFromBlobsDelayProof", sequenceNumber, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchFromBlobsDelayProof is a paid mutator transaction binding the contract method 0x917cf8ac.
//
// Solidity: function addSequencerL2BatchFromBlobsDelayProof(uint256 sequenceNumber, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_ISequencerInbox *ISequencerInboxSession) AddSequencerL2BatchFromBlobsDelayProof(sequenceNumber *big.Int, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2BatchFromBlobsDelayProof(&_ISequencerInbox.TransactOpts, sequenceNumber, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchFromBlobsDelayProof is a paid mutator transaction binding the contract method 0x917cf8ac.
//
// Solidity: function addSequencerL2BatchFromBlobsDelayProof(uint256 sequenceNumber, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) AddSequencerL2BatchFromBlobsDelayProof(sequenceNumber *big.Int, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2BatchFromBlobsDelayProof(&_ISequencerInbox.TransactOpts, sequenceNumber, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchFromOrigin6f12b0c9 is a paid mutator transaction binding the contract method 0x6f12b0c9.
//
// Solidity: function addSequencerL2BatchFromOrigin(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) AddSequencerL2BatchFromOrigin6f12b0c9(opts *bind.TransactOpts, sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "addSequencerL2BatchFromOrigin", sequenceNumber, data, afterDelayedMessagesRead, gasRefunder)
}

// AddSequencerL2BatchFromOrigin6f12b0c9 is a paid mutator transaction binding the contract method 0x6f12b0c9.
//
// Solidity: function addSequencerL2BatchFromOrigin(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder) returns()
func (_ISequencerInbox *ISequencerInboxSession) AddSequencerL2BatchFromOrigin6f12b0c9(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2BatchFromOrigin6f12b0c9(&_ISequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder)
}

// AddSequencerL2BatchFromOrigin6f12b0c9 is a paid mutator transaction binding the contract method 0x6f12b0c9.
//
// Solidity: function addSequencerL2BatchFromOrigin(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) AddSequencerL2BatchFromOrigin6f12b0c9(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2BatchFromOrigin6f12b0c9(&_ISequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder)
}

// AddSequencerL2BatchFromOrigin8f111f3c is a paid mutator transaction binding the contract method 0x8f111f3c.
//
// Solidity: function addSequencerL2BatchFromOrigin(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) AddSequencerL2BatchFromOrigin8f111f3c(opts *bind.TransactOpts, sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "addSequencerL2BatchFromOrigin0", sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchFromOrigin8f111f3c is a paid mutator transaction binding the contract method 0x8f111f3c.
//
// Solidity: function addSequencerL2BatchFromOrigin(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_ISequencerInbox *ISequencerInboxSession) AddSequencerL2BatchFromOrigin8f111f3c(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2BatchFromOrigin8f111f3c(&_ISequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchFromOrigin8f111f3c is a paid mutator transaction binding the contract method 0x8f111f3c.
//
// Solidity: function addSequencerL2BatchFromOrigin(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) AddSequencerL2BatchFromOrigin8f111f3c(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2BatchFromOrigin8f111f3c(&_ISequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchFromOriginDelayProof is a paid mutator transaction binding the contract method 0x69cacded.
//
// Solidity: function addSequencerL2BatchFromOriginDelayProof(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) AddSequencerL2BatchFromOriginDelayProof(opts *bind.TransactOpts, sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "addSequencerL2BatchFromOriginDelayProof", sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchFromOriginDelayProof is a paid mutator transaction binding the contract method 0x69cacded.
//
// Solidity: function addSequencerL2BatchFromOriginDelayProof(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_ISequencerInbox *ISequencerInboxSession) AddSequencerL2BatchFromOriginDelayProof(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2BatchFromOriginDelayProof(&_ISequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchFromOriginDelayProof is a paid mutator transaction binding the contract method 0x69cacded.
//
// Solidity: function addSequencerL2BatchFromOriginDelayProof(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) AddSequencerL2BatchFromOriginDelayProof(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.AddSequencerL2BatchFromOriginDelayProof(&_ISequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// ForceInclusion is a paid mutator transaction binding the contract method 0xf1981578.
//
// Solidity: function forceInclusion(uint256 _totalDelayedMessagesRead, uint8 kind, uint64[2] l1BlockAndTime, uint256 baseFeeL1, address sender, bytes32 messageDataHash) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) ForceInclusion(opts *bind.TransactOpts, _totalDelayedMessagesRead *big.Int, kind uint8, l1BlockAndTime [2]uint64, baseFeeL1 *big.Int, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "forceInclusion", _totalDelayedMessagesRead, kind, l1BlockAndTime, baseFeeL1, sender, messageDataHash)
}

// ForceInclusion is a paid mutator transaction binding the contract method 0xf1981578.
//
// Solidity: function forceInclusion(uint256 _totalDelayedMessagesRead, uint8 kind, uint64[2] l1BlockAndTime, uint256 baseFeeL1, address sender, bytes32 messageDataHash) returns()
func (_ISequencerInbox *ISequencerInboxSession) ForceInclusion(_totalDelayedMessagesRead *big.Int, kind uint8, l1BlockAndTime [2]uint64, baseFeeL1 *big.Int, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.ForceInclusion(&_ISequencerInbox.TransactOpts, _totalDelayedMessagesRead, kind, l1BlockAndTime, baseFeeL1, sender, messageDataHash)
}

// ForceInclusion is a paid mutator transaction binding the contract method 0xf1981578.
//
// Solidity: function forceInclusion(uint256 _totalDelayedMessagesRead, uint8 kind, uint64[2] l1BlockAndTime, uint256 baseFeeL1, address sender, bytes32 messageDataHash) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) ForceInclusion(_totalDelayedMessagesRead *big.Int, kind uint8, l1BlockAndTime [2]uint64, baseFeeL1 *big.Int, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.ForceInclusion(&_ISequencerInbox.TransactOpts, _totalDelayedMessagesRead, kind, l1BlockAndTime, baseFeeL1, sender, messageDataHash)
}

// Initialize is a paid mutator transaction binding the contract method 0xa84840b7.
//
// Solidity: function initialize(address bridge_, (uint256,uint256,uint256,uint256) maxTimeVariation_, (uint64,uint64,uint64) bufferConfig_, address feeTokenPricer_) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) Initialize(opts *bind.TransactOpts, bridge_ common.Address, maxTimeVariation_ ISequencerInboxMaxTimeVariation, bufferConfig_ BufferConfig, feeTokenPricer_ common.Address) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "initialize", bridge_, maxTimeVariation_, bufferConfig_, feeTokenPricer_)
}

// Initialize is a paid mutator transaction binding the contract method 0xa84840b7.
//
// Solidity: function initialize(address bridge_, (uint256,uint256,uint256,uint256) maxTimeVariation_, (uint64,uint64,uint64) bufferConfig_, address feeTokenPricer_) returns()
func (_ISequencerInbox *ISequencerInboxSession) Initialize(bridge_ common.Address, maxTimeVariation_ ISequencerInboxMaxTimeVariation, bufferConfig_ BufferConfig, feeTokenPricer_ common.Address) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.Initialize(&_ISequencerInbox.TransactOpts, bridge_, maxTimeVariation_, bufferConfig_, feeTokenPricer_)
}

// Initialize is a paid mutator transaction binding the contract method 0xa84840b7.
//
// Solidity: function initialize(address bridge_, (uint256,uint256,uint256,uint256) maxTimeVariation_, (uint64,uint64,uint64) bufferConfig_, address feeTokenPricer_) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) Initialize(bridge_ common.Address, maxTimeVariation_ ISequencerInboxMaxTimeVariation, bufferConfig_ BufferConfig, feeTokenPricer_ common.Address) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.Initialize(&_ISequencerInbox.TransactOpts, bridge_, maxTimeVariation_, bufferConfig_, feeTokenPricer_)
}

// InvalidateKeysetHash is a paid mutator transaction binding the contract method 0x84420860.
//
// Solidity: function invalidateKeysetHash(bytes32 ksHash) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) InvalidateKeysetHash(opts *bind.TransactOpts, ksHash [32]byte) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "invalidateKeysetHash", ksHash)
}

// InvalidateKeysetHash is a paid mutator transaction binding the contract method 0x84420860.
//
// Solidity: function invalidateKeysetHash(bytes32 ksHash) returns()
func (_ISequencerInbox *ISequencerInboxSession) InvalidateKeysetHash(ksHash [32]byte) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.InvalidateKeysetHash(&_ISequencerInbox.TransactOpts, ksHash)
}

// InvalidateKeysetHash is a paid mutator transaction binding the contract method 0x84420860.
//
// Solidity: function invalidateKeysetHash(bytes32 ksHash) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) InvalidateKeysetHash(ksHash [32]byte) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.InvalidateKeysetHash(&_ISequencerInbox.TransactOpts, ksHash)
}

// RemoveDelayAfterFork is a paid mutator transaction binding the contract method 0x96cc5c78.
//
// Solidity: function removeDelayAfterFork() returns()
func (_ISequencerInbox *ISequencerInboxTransactor) RemoveDelayAfterFork(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "removeDelayAfterFork")
}

// RemoveDelayAfterFork is a paid mutator transaction binding the contract method 0x96cc5c78.
//
// Solidity: function removeDelayAfterFork() returns()
func (_ISequencerInbox *ISequencerInboxSession) RemoveDelayAfterFork() (*types.Transaction, error) {
	return _ISequencerInbox.Contract.RemoveDelayAfterFork(&_ISequencerInbox.TransactOpts)
}

// RemoveDelayAfterFork is a paid mutator transaction binding the contract method 0x96cc5c78.
//
// Solidity: function removeDelayAfterFork() returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) RemoveDelayAfterFork() (*types.Transaction, error) {
	return _ISequencerInbox.Contract.RemoveDelayAfterFork(&_ISequencerInbox.TransactOpts)
}

// SetBatchPosterManager is a paid mutator transaction binding the contract method 0x1ff64790.
//
// Solidity: function setBatchPosterManager(address newBatchPosterManager) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) SetBatchPosterManager(opts *bind.TransactOpts, newBatchPosterManager common.Address) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "setBatchPosterManager", newBatchPosterManager)
}

// SetBatchPosterManager is a paid mutator transaction binding the contract method 0x1ff64790.
//
// Solidity: function setBatchPosterManager(address newBatchPosterManager) returns()
func (_ISequencerInbox *ISequencerInboxSession) SetBatchPosterManager(newBatchPosterManager common.Address) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.SetBatchPosterManager(&_ISequencerInbox.TransactOpts, newBatchPosterManager)
}

// SetBatchPosterManager is a paid mutator transaction binding the contract method 0x1ff64790.
//
// Solidity: function setBatchPosterManager(address newBatchPosterManager) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) SetBatchPosterManager(newBatchPosterManager common.Address) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.SetBatchPosterManager(&_ISequencerInbox.TransactOpts, newBatchPosterManager)
}

// SetFeeTokenPricer is a paid mutator transaction binding the contract method 0x036f7ed3.
//
// Solidity: function setFeeTokenPricer(address newFeeTokenPricer) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) SetFeeTokenPricer(opts *bind.TransactOpts, newFeeTokenPricer common.Address) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "setFeeTokenPricer", newFeeTokenPricer)
}

// SetFeeTokenPricer is a paid mutator transaction binding the contract method 0x036f7ed3.
//
// Solidity: function setFeeTokenPricer(address newFeeTokenPricer) returns()
func (_ISequencerInbox *ISequencerInboxSession) SetFeeTokenPricer(newFeeTokenPricer common.Address) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.SetFeeTokenPricer(&_ISequencerInbox.TransactOpts, newFeeTokenPricer)
}

// SetFeeTokenPricer is a paid mutator transaction binding the contract method 0x036f7ed3.
//
// Solidity: function setFeeTokenPricer(address newFeeTokenPricer) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) SetFeeTokenPricer(newFeeTokenPricer common.Address) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.SetFeeTokenPricer(&_ISequencerInbox.TransactOpts, newFeeTokenPricer)
}

// SetIsBatchPoster is a paid mutator transaction binding the contract method 0x6e7df3e7.
//
// Solidity: function setIsBatchPoster(address addr, bool isBatchPoster_) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) SetIsBatchPoster(opts *bind.TransactOpts, addr common.Address, isBatchPoster_ bool) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "setIsBatchPoster", addr, isBatchPoster_)
}

// SetIsBatchPoster is a paid mutator transaction binding the contract method 0x6e7df3e7.
//
// Solidity: function setIsBatchPoster(address addr, bool isBatchPoster_) returns()
func (_ISequencerInbox *ISequencerInboxSession) SetIsBatchPoster(addr common.Address, isBatchPoster_ bool) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.SetIsBatchPoster(&_ISequencerInbox.TransactOpts, addr, isBatchPoster_)
}

// SetIsBatchPoster is a paid mutator transaction binding the contract method 0x6e7df3e7.
//
// Solidity: function setIsBatchPoster(address addr, bool isBatchPoster_) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) SetIsBatchPoster(addr common.Address, isBatchPoster_ bool) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.SetIsBatchPoster(&_ISequencerInbox.TransactOpts, addr, isBatchPoster_)
}

// SetIsSequencer is a paid mutator transaction binding the contract method 0x1f956632.
//
// Solidity: function setIsSequencer(address addr, bool isSequencer_) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) SetIsSequencer(opts *bind.TransactOpts, addr common.Address, isSequencer_ bool) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "setIsSequencer", addr, isSequencer_)
}

// SetIsSequencer is a paid mutator transaction binding the contract method 0x1f956632.
//
// Solidity: function setIsSequencer(address addr, bool isSequencer_) returns()
func (_ISequencerInbox *ISequencerInboxSession) SetIsSequencer(addr common.Address, isSequencer_ bool) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.SetIsSequencer(&_ISequencerInbox.TransactOpts, addr, isSequencer_)
}

// SetIsSequencer is a paid mutator transaction binding the contract method 0x1f956632.
//
// Solidity: function setIsSequencer(address addr, bool isSequencer_) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) SetIsSequencer(addr common.Address, isSequencer_ bool) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.SetIsSequencer(&_ISequencerInbox.TransactOpts, addr, isSequencer_)
}

// SetMaxTimeVariation is a paid mutator transaction binding the contract method 0xb31761f8.
//
// Solidity: function setMaxTimeVariation((uint256,uint256,uint256,uint256) maxTimeVariation_) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) SetMaxTimeVariation(opts *bind.TransactOpts, maxTimeVariation_ ISequencerInboxMaxTimeVariation) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "setMaxTimeVariation", maxTimeVariation_)
}

// SetMaxTimeVariation is a paid mutator transaction binding the contract method 0xb31761f8.
//
// Solidity: function setMaxTimeVariation((uint256,uint256,uint256,uint256) maxTimeVariation_) returns()
func (_ISequencerInbox *ISequencerInboxSession) SetMaxTimeVariation(maxTimeVariation_ ISequencerInboxMaxTimeVariation) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.SetMaxTimeVariation(&_ISequencerInbox.TransactOpts, maxTimeVariation_)
}

// SetMaxTimeVariation is a paid mutator transaction binding the contract method 0xb31761f8.
//
// Solidity: function setMaxTimeVariation((uint256,uint256,uint256,uint256) maxTimeVariation_) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) SetMaxTimeVariation(maxTimeVariation_ ISequencerInboxMaxTimeVariation) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.SetMaxTimeVariation(&_ISequencerInbox.TransactOpts, maxTimeVariation_)
}

// SetValidKeyset is a paid mutator transaction binding the contract method 0xd1ce8da8.
//
// Solidity: function setValidKeyset(bytes keysetBytes) returns()
func (_ISequencerInbox *ISequencerInboxTransactor) SetValidKeyset(opts *bind.TransactOpts, keysetBytes []byte) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "setValidKeyset", keysetBytes)
}

// SetValidKeyset is a paid mutator transaction binding the contract method 0xd1ce8da8.
//
// Solidity: function setValidKeyset(bytes keysetBytes) returns()
func (_ISequencerInbox *ISequencerInboxSession) SetValidKeyset(keysetBytes []byte) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.SetValidKeyset(&_ISequencerInbox.TransactOpts, keysetBytes)
}

// SetValidKeyset is a paid mutator transaction binding the contract method 0xd1ce8da8.
//
// Solidity: function setValidKeyset(bytes keysetBytes) returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) SetValidKeyset(keysetBytes []byte) (*types.Transaction, error) {
	return _ISequencerInbox.Contract.SetValidKeyset(&_ISequencerInbox.TransactOpts, keysetBytes)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_ISequencerInbox *ISequencerInboxTransactor) UpdateRollupAddress(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ISequencerInbox.contract.Transact(opts, "updateRollupAddress")
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_ISequencerInbox *ISequencerInboxSession) UpdateRollupAddress() (*types.Transaction, error) {
	return _ISequencerInbox.Contract.UpdateRollupAddress(&_ISequencerInbox.TransactOpts)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_ISequencerInbox *ISequencerInboxTransactorSession) UpdateRollupAddress() (*types.Transaction, error) {
	return _ISequencerInbox.Contract.UpdateRollupAddress(&_ISequencerInbox.TransactOpts)
}

// ISequencerInboxBatchPosterManagerSetIterator is returned from FilterBatchPosterManagerSet and is used to iterate over the raw logs and unpacked data for BatchPosterManagerSet events raised by the ISequencerInbox contract.
type ISequencerInboxBatchPosterManagerSetIterator struct {
	Event *ISequencerInboxBatchPosterManagerSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxBatchPosterManagerSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxBatchPosterManagerSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxBatchPosterManagerSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxBatchPosterManagerSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxBatchPosterManagerSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxBatchPosterManagerSet represents a BatchPosterManagerSet event raised by the ISequencerInbox contract.
type ISequencerInboxBatchPosterManagerSet struct {
	NewBatchPosterManager common.Address
	Raw                   types.Log // Blockchain specific contextual infos
}

// FilterBatchPosterManagerSet is a free log retrieval operation binding the contract event 0x3cd6c184800297a0f2b00926a683cbe76890bb7fd01480ac0a10ed6c8f7f6659.
//
// Solidity: event BatchPosterManagerSet(address newBatchPosterManager)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterBatchPosterManagerSet(opts *bind.FilterOpts) (*ISequencerInboxBatchPosterManagerSetIterator, error) {

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "BatchPosterManagerSet")
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxBatchPosterManagerSetIterator{contract: _ISequencerInbox.contract, event: "BatchPosterManagerSet", logs: logs, sub: sub}, nil
}

// WatchBatchPosterManagerSet is a free log subscription operation binding the contract event 0x3cd6c184800297a0f2b00926a683cbe76890bb7fd01480ac0a10ed6c8f7f6659.
//
// Solidity: event BatchPosterManagerSet(address newBatchPosterManager)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchBatchPosterManagerSet(opts *bind.WatchOpts, sink chan<- *ISequencerInboxBatchPosterManagerSet) (event.Subscription, error) {

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "BatchPosterManagerSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxBatchPosterManagerSet)
				if err := _ISequencerInbox.contract.UnpackLog(event, "BatchPosterManagerSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBatchPosterManagerSet is a log parse operation binding the contract event 0x3cd6c184800297a0f2b00926a683cbe76890bb7fd01480ac0a10ed6c8f7f6659.
//
// Solidity: event BatchPosterManagerSet(address newBatchPosterManager)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseBatchPosterManagerSet(log types.Log) (*ISequencerInboxBatchPosterManagerSet, error) {
	event := new(ISequencerInboxBatchPosterManagerSet)
	if err := _ISequencerInbox.contract.UnpackLog(event, "BatchPosterManagerSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ISequencerInboxBatchPosterSetIterator is returned from FilterBatchPosterSet and is used to iterate over the raw logs and unpacked data for BatchPosterSet events raised by the ISequencerInbox contract.
type ISequencerInboxBatchPosterSetIterator struct {
	Event *ISequencerInboxBatchPosterSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxBatchPosterSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxBatchPosterSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxBatchPosterSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxBatchPosterSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxBatchPosterSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxBatchPosterSet represents a BatchPosterSet event raised by the ISequencerInbox contract.
type ISequencerInboxBatchPosterSet struct {
	BatchPoster   common.Address
	IsBatchPoster bool
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterBatchPosterSet is a free log retrieval operation binding the contract event 0x28bcc5626d357efe966b4b0876aa1ee8ab99e26da4f131f6a2623f1800701c21.
//
// Solidity: event BatchPosterSet(address batchPoster, bool isBatchPoster)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterBatchPosterSet(opts *bind.FilterOpts) (*ISequencerInboxBatchPosterSetIterator, error) {

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "BatchPosterSet")
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxBatchPosterSetIterator{contract: _ISequencerInbox.contract, event: "BatchPosterSet", logs: logs, sub: sub}, nil
}

// WatchBatchPosterSet is a free log subscription operation binding the contract event 0x28bcc5626d357efe966b4b0876aa1ee8ab99e26da4f131f6a2623f1800701c21.
//
// Solidity: event BatchPosterSet(address batchPoster, bool isBatchPoster)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchBatchPosterSet(opts *bind.WatchOpts, sink chan<- *ISequencerInboxBatchPosterSet) (event.Subscription, error) {

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "BatchPosterSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxBatchPosterSet)
				if err := _ISequencerInbox.contract.UnpackLog(event, "BatchPosterSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBatchPosterSet is a log parse operation binding the contract event 0x28bcc5626d357efe966b4b0876aa1ee8ab99e26da4f131f6a2623f1800701c21.
//
// Solidity: event BatchPosterSet(address batchPoster, bool isBatchPoster)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseBatchPosterSet(log types.Log) (*ISequencerInboxBatchPosterSet, error) {
	event := new(ISequencerInboxBatchPosterSet)
	if err := _ISequencerInbox.contract.UnpackLog(event, "BatchPosterSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ISequencerInboxBufferConfigSetIterator is returned from FilterBufferConfigSet and is used to iterate over the raw logs and unpacked data for BufferConfigSet events raised by the ISequencerInbox contract.
type ISequencerInboxBufferConfigSetIterator struct {
	Event *ISequencerInboxBufferConfigSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxBufferConfigSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxBufferConfigSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxBufferConfigSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxBufferConfigSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxBufferConfigSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxBufferConfigSet represents a BufferConfigSet event raised by the ISequencerInbox contract.
type ISequencerInboxBufferConfigSet struct {
	BufferConfig BufferConfig
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterBufferConfigSet is a free log retrieval operation binding the contract event 0xaa7a2d8175dee3b637814ad6346005dfcc357165396fb8327f649effe8abcf85.
//
// Solidity: event BufferConfigSet((uint64,uint64,uint64) bufferConfig)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterBufferConfigSet(opts *bind.FilterOpts) (*ISequencerInboxBufferConfigSetIterator, error) {

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "BufferConfigSet")
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxBufferConfigSetIterator{contract: _ISequencerInbox.contract, event: "BufferConfigSet", logs: logs, sub: sub}, nil
}

// WatchBufferConfigSet is a free log subscription operation binding the contract event 0xaa7a2d8175dee3b637814ad6346005dfcc357165396fb8327f649effe8abcf85.
//
// Solidity: event BufferConfigSet((uint64,uint64,uint64) bufferConfig)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchBufferConfigSet(opts *bind.WatchOpts, sink chan<- *ISequencerInboxBufferConfigSet) (event.Subscription, error) {

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "BufferConfigSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxBufferConfigSet)
				if err := _ISequencerInbox.contract.UnpackLog(event, "BufferConfigSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBufferConfigSet is a log parse operation binding the contract event 0xaa7a2d8175dee3b637814ad6346005dfcc357165396fb8327f649effe8abcf85.
//
// Solidity: event BufferConfigSet((uint64,uint64,uint64) bufferConfig)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseBufferConfigSet(log types.Log) (*ISequencerInboxBufferConfigSet, error) {
	event := new(ISequencerInboxBufferConfigSet)
	if err := _ISequencerInbox.contract.UnpackLog(event, "BufferConfigSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ISequencerInboxFeeTokenPricerSetIterator is returned from FilterFeeTokenPricerSet and is used to iterate over the raw logs and unpacked data for FeeTokenPricerSet events raised by the ISequencerInbox contract.
type ISequencerInboxFeeTokenPricerSetIterator struct {
	Event *ISequencerInboxFeeTokenPricerSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxFeeTokenPricerSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxFeeTokenPricerSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxFeeTokenPricerSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxFeeTokenPricerSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxFeeTokenPricerSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxFeeTokenPricerSet represents a FeeTokenPricerSet event raised by the ISequencerInbox contract.
type ISequencerInboxFeeTokenPricerSet struct {
	FeeTokenPricer common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterFeeTokenPricerSet is a free log retrieval operation binding the contract event 0xe83d6153add50e41b8ee6c1115c4178687349bb12bc3902a50b1f6ad78a0c541.
//
// Solidity: event FeeTokenPricerSet(address feeTokenPricer)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterFeeTokenPricerSet(opts *bind.FilterOpts) (*ISequencerInboxFeeTokenPricerSetIterator, error) {

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "FeeTokenPricerSet")
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxFeeTokenPricerSetIterator{contract: _ISequencerInbox.contract, event: "FeeTokenPricerSet", logs: logs, sub: sub}, nil
}

// WatchFeeTokenPricerSet is a free log subscription operation binding the contract event 0xe83d6153add50e41b8ee6c1115c4178687349bb12bc3902a50b1f6ad78a0c541.
//
// Solidity: event FeeTokenPricerSet(address feeTokenPricer)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchFeeTokenPricerSet(opts *bind.WatchOpts, sink chan<- *ISequencerInboxFeeTokenPricerSet) (event.Subscription, error) {

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "FeeTokenPricerSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxFeeTokenPricerSet)
				if err := _ISequencerInbox.contract.UnpackLog(event, "FeeTokenPricerSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeTokenPricerSet is a log parse operation binding the contract event 0xe83d6153add50e41b8ee6c1115c4178687349bb12bc3902a50b1f6ad78a0c541.
//
// Solidity: event FeeTokenPricerSet(address feeTokenPricer)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseFeeTokenPricerSet(log types.Log) (*ISequencerInboxFeeTokenPricerSet, error) {
	event := new(ISequencerInboxFeeTokenPricerSet)
	if err := _ISequencerInbox.contract.UnpackLog(event, "FeeTokenPricerSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ISequencerInboxInboxMessageDeliveredIterator is returned from FilterInboxMessageDelivered and is used to iterate over the raw logs and unpacked data for InboxMessageDelivered events raised by the ISequencerInbox contract.
type ISequencerInboxInboxMessageDeliveredIterator struct {
	Event *ISequencerInboxInboxMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxInboxMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxInboxMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxInboxMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxInboxMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxInboxMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxInboxMessageDelivered represents a InboxMessageDelivered event raised by the ISequencerInbox contract.
type ISequencerInboxInboxMessageDelivered struct {
	MessageNum *big.Int
	Data       []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDelivered is a free log retrieval operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterInboxMessageDelivered(opts *bind.FilterOpts, messageNum []*big.Int) (*ISequencerInboxInboxMessageDeliveredIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxInboxMessageDeliveredIterator{contract: _ISequencerInbox.contract, event: "InboxMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDelivered is a free log subscription operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchInboxMessageDelivered(opts *bind.WatchOpts, sink chan<- *ISequencerInboxInboxMessageDelivered, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxInboxMessageDelivered)
				if err := _ISequencerInbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDelivered is a log parse operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseInboxMessageDelivered(log types.Log) (*ISequencerInboxInboxMessageDelivered, error) {
	event := new(ISequencerInboxInboxMessageDelivered)
	if err := _ISequencerInbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ISequencerInboxInboxMessageDeliveredFromOriginIterator is returned from FilterInboxMessageDeliveredFromOrigin and is used to iterate over the raw logs and unpacked data for InboxMessageDeliveredFromOrigin events raised by the ISequencerInbox contract.
type ISequencerInboxInboxMessageDeliveredFromOriginIterator struct {
	Event *ISequencerInboxInboxMessageDeliveredFromOrigin // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxInboxMessageDeliveredFromOriginIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxInboxMessageDeliveredFromOrigin)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxInboxMessageDeliveredFromOrigin)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxInboxMessageDeliveredFromOriginIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxInboxMessageDeliveredFromOriginIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxInboxMessageDeliveredFromOrigin represents a InboxMessageDeliveredFromOrigin event raised by the ISequencerInbox contract.
type ISequencerInboxInboxMessageDeliveredFromOrigin struct {
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDeliveredFromOrigin is a free log retrieval operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterInboxMessageDeliveredFromOrigin(opts *bind.FilterOpts, messageNum []*big.Int) (*ISequencerInboxInboxMessageDeliveredFromOriginIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxInboxMessageDeliveredFromOriginIterator{contract: _ISequencerInbox.contract, event: "InboxMessageDeliveredFromOrigin", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDeliveredFromOrigin is a free log subscription operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchInboxMessageDeliveredFromOrigin(opts *bind.WatchOpts, sink chan<- *ISequencerInboxInboxMessageDeliveredFromOrigin, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxInboxMessageDeliveredFromOrigin)
				if err := _ISequencerInbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDeliveredFromOrigin is a log parse operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseInboxMessageDeliveredFromOrigin(log types.Log) (*ISequencerInboxInboxMessageDeliveredFromOrigin, error) {
	event := new(ISequencerInboxInboxMessageDeliveredFromOrigin)
	if err := _ISequencerInbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ISequencerInboxInvalidateKeysetIterator is returned from FilterInvalidateKeyset and is used to iterate over the raw logs and unpacked data for InvalidateKeyset events raised by the ISequencerInbox contract.
type ISequencerInboxInvalidateKeysetIterator struct {
	Event *ISequencerInboxInvalidateKeyset // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxInvalidateKeysetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxInvalidateKeyset)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxInvalidateKeyset)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxInvalidateKeysetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxInvalidateKeysetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxInvalidateKeyset represents a InvalidateKeyset event raised by the ISequencerInbox contract.
type ISequencerInboxInvalidateKeyset struct {
	KeysetHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInvalidateKeyset is a free log retrieval operation binding the contract event 0x5cb4218b272fd214168ac43e90fb4d05d6c36f0b17ffb4c2dd07c234d744eb2a.
//
// Solidity: event InvalidateKeyset(bytes32 indexed keysetHash)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterInvalidateKeyset(opts *bind.FilterOpts, keysetHash [][32]byte) (*ISequencerInboxInvalidateKeysetIterator, error) {

	var keysetHashRule []interface{}
	for _, keysetHashItem := range keysetHash {
		keysetHashRule = append(keysetHashRule, keysetHashItem)
	}

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "InvalidateKeyset", keysetHashRule)
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxInvalidateKeysetIterator{contract: _ISequencerInbox.contract, event: "InvalidateKeyset", logs: logs, sub: sub}, nil
}

// WatchInvalidateKeyset is a free log subscription operation binding the contract event 0x5cb4218b272fd214168ac43e90fb4d05d6c36f0b17ffb4c2dd07c234d744eb2a.
//
// Solidity: event InvalidateKeyset(bytes32 indexed keysetHash)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchInvalidateKeyset(opts *bind.WatchOpts, sink chan<- *ISequencerInboxInvalidateKeyset, keysetHash [][32]byte) (event.Subscription, error) {

	var keysetHashRule []interface{}
	for _, keysetHashItem := range keysetHash {
		keysetHashRule = append(keysetHashRule, keysetHashItem)
	}

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "InvalidateKeyset", keysetHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxInvalidateKeyset)
				if err := _ISequencerInbox.contract.UnpackLog(event, "InvalidateKeyset", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInvalidateKeyset is a log parse operation binding the contract event 0x5cb4218b272fd214168ac43e90fb4d05d6c36f0b17ffb4c2dd07c234d744eb2a.
//
// Solidity: event InvalidateKeyset(bytes32 indexed keysetHash)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseInvalidateKeyset(log types.Log) (*ISequencerInboxInvalidateKeyset, error) {
	event := new(ISequencerInboxInvalidateKeyset)
	if err := _ISequencerInbox.contract.UnpackLog(event, "InvalidateKeyset", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ISequencerInboxMaxTimeVariationSetIterator is returned from FilterMaxTimeVariationSet and is used to iterate over the raw logs and unpacked data for MaxTimeVariationSet events raised by the ISequencerInbox contract.
type ISequencerInboxMaxTimeVariationSetIterator struct {
	Event *ISequencerInboxMaxTimeVariationSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxMaxTimeVariationSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxMaxTimeVariationSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxMaxTimeVariationSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxMaxTimeVariationSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxMaxTimeVariationSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxMaxTimeVariationSet represents a MaxTimeVariationSet event raised by the ISequencerInbox contract.
type ISequencerInboxMaxTimeVariationSet struct {
	MaxTimeVariation ISequencerInboxMaxTimeVariation
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterMaxTimeVariationSet is a free log retrieval operation binding the contract event 0xaa6a58dad31128ff7ecc2b80987ee6e003df80bc50cd8d0b0d1af0e07da6d19d.
//
// Solidity: event MaxTimeVariationSet((uint256,uint256,uint256,uint256) maxTimeVariation)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterMaxTimeVariationSet(opts *bind.FilterOpts) (*ISequencerInboxMaxTimeVariationSetIterator, error) {

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "MaxTimeVariationSet")
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxMaxTimeVariationSetIterator{contract: _ISequencerInbox.contract, event: "MaxTimeVariationSet", logs: logs, sub: sub}, nil
}

// WatchMaxTimeVariationSet is a free log subscription operation binding the contract event 0xaa6a58dad31128ff7ecc2b80987ee6e003df80bc50cd8d0b0d1af0e07da6d19d.
//
// Solidity: event MaxTimeVariationSet((uint256,uint256,uint256,uint256) maxTimeVariation)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchMaxTimeVariationSet(opts *bind.WatchOpts, sink chan<- *ISequencerInboxMaxTimeVariationSet) (event.Subscription, error) {

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "MaxTimeVariationSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxMaxTimeVariationSet)
				if err := _ISequencerInbox.contract.UnpackLog(event, "MaxTimeVariationSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMaxTimeVariationSet is a log parse operation binding the contract event 0xaa6a58dad31128ff7ecc2b80987ee6e003df80bc50cd8d0b0d1af0e07da6d19d.
//
// Solidity: event MaxTimeVariationSet((uint256,uint256,uint256,uint256) maxTimeVariation)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseMaxTimeVariationSet(log types.Log) (*ISequencerInboxMaxTimeVariationSet, error) {
	event := new(ISequencerInboxMaxTimeVariationSet)
	if err := _ISequencerInbox.contract.UnpackLog(event, "MaxTimeVariationSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ISequencerInboxOwnerFunctionCalledIterator is returned from FilterOwnerFunctionCalled and is used to iterate over the raw logs and unpacked data for OwnerFunctionCalled events raised by the ISequencerInbox contract.
type ISequencerInboxOwnerFunctionCalledIterator struct {
	Event *ISequencerInboxOwnerFunctionCalled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxOwnerFunctionCalledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxOwnerFunctionCalled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxOwnerFunctionCalled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxOwnerFunctionCalledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxOwnerFunctionCalledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxOwnerFunctionCalled represents a OwnerFunctionCalled event raised by the ISequencerInbox contract.
type ISequencerInboxOwnerFunctionCalled struct {
	Id  *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOwnerFunctionCalled is a free log retrieval operation binding the contract event 0xea8787f128d10b2cc0317b0c3960f9ad447f7f6c1ed189db1083ccffd20f456e.
//
// Solidity: event OwnerFunctionCalled(uint256 indexed id)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterOwnerFunctionCalled(opts *bind.FilterOpts, id []*big.Int) (*ISequencerInboxOwnerFunctionCalledIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "OwnerFunctionCalled", idRule)
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxOwnerFunctionCalledIterator{contract: _ISequencerInbox.contract, event: "OwnerFunctionCalled", logs: logs, sub: sub}, nil
}

// WatchOwnerFunctionCalled is a free log subscription operation binding the contract event 0xea8787f128d10b2cc0317b0c3960f9ad447f7f6c1ed189db1083ccffd20f456e.
//
// Solidity: event OwnerFunctionCalled(uint256 indexed id)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchOwnerFunctionCalled(opts *bind.WatchOpts, sink chan<- *ISequencerInboxOwnerFunctionCalled, id []*big.Int) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "OwnerFunctionCalled", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxOwnerFunctionCalled)
				if err := _ISequencerInbox.contract.UnpackLog(event, "OwnerFunctionCalled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnerFunctionCalled is a log parse operation binding the contract event 0xea8787f128d10b2cc0317b0c3960f9ad447f7f6c1ed189db1083ccffd20f456e.
//
// Solidity: event OwnerFunctionCalled(uint256 indexed id)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseOwnerFunctionCalled(log types.Log) (*ISequencerInboxOwnerFunctionCalled, error) {
	event := new(ISequencerInboxOwnerFunctionCalled)
	if err := _ISequencerInbox.contract.UnpackLog(event, "OwnerFunctionCalled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ISequencerInboxSequencerBatchDataIterator is returned from FilterSequencerBatchData and is used to iterate over the raw logs and unpacked data for SequencerBatchData events raised by the ISequencerInbox contract.
type ISequencerInboxSequencerBatchDataIterator struct {
	Event *ISequencerInboxSequencerBatchData // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxSequencerBatchDataIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxSequencerBatchData)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxSequencerBatchData)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxSequencerBatchDataIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxSequencerBatchDataIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxSequencerBatchData represents a SequencerBatchData event raised by the ISequencerInbox contract.
type ISequencerInboxSequencerBatchData struct {
	BatchSequenceNumber *big.Int
	Data                []byte
	Raw                 types.Log // Blockchain specific contextual infos
}

// FilterSequencerBatchData is a free log retrieval operation binding the contract event 0xfe325ca1efe4c5c1062c981c3ee74b781debe4ea9440306a96d2a55759c66c20.
//
// Solidity: event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterSequencerBatchData(opts *bind.FilterOpts, batchSequenceNumber []*big.Int) (*ISequencerInboxSequencerBatchDataIterator, error) {

	var batchSequenceNumberRule []interface{}
	for _, batchSequenceNumberItem := range batchSequenceNumber {
		batchSequenceNumberRule = append(batchSequenceNumberRule, batchSequenceNumberItem)
	}

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "SequencerBatchData", batchSequenceNumberRule)
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxSequencerBatchDataIterator{contract: _ISequencerInbox.contract, event: "SequencerBatchData", logs: logs, sub: sub}, nil
}

// WatchSequencerBatchData is a free log subscription operation binding the contract event 0xfe325ca1efe4c5c1062c981c3ee74b781debe4ea9440306a96d2a55759c66c20.
//
// Solidity: event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchSequencerBatchData(opts *bind.WatchOpts, sink chan<- *ISequencerInboxSequencerBatchData, batchSequenceNumber []*big.Int) (event.Subscription, error) {

	var batchSequenceNumberRule []interface{}
	for _, batchSequenceNumberItem := range batchSequenceNumber {
		batchSequenceNumberRule = append(batchSequenceNumberRule, batchSequenceNumberItem)
	}

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "SequencerBatchData", batchSequenceNumberRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxSequencerBatchData)
				if err := _ISequencerInbox.contract.UnpackLog(event, "SequencerBatchData", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSequencerBatchData is a log parse operation binding the contract event 0xfe325ca1efe4c5c1062c981c3ee74b781debe4ea9440306a96d2a55759c66c20.
//
// Solidity: event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseSequencerBatchData(log types.Log) (*ISequencerInboxSequencerBatchData, error) {
	event := new(ISequencerInboxSequencerBatchData)
	if err := _ISequencerInbox.contract.UnpackLog(event, "SequencerBatchData", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ISequencerInboxSequencerBatchDeliveredIterator is returned from FilterSequencerBatchDelivered and is used to iterate over the raw logs and unpacked data for SequencerBatchDelivered events raised by the ISequencerInbox contract.
type ISequencerInboxSequencerBatchDeliveredIterator struct {
	Event *ISequencerInboxSequencerBatchDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxSequencerBatchDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxSequencerBatchDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxSequencerBatchDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxSequencerBatchDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxSequencerBatchDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxSequencerBatchDelivered represents a SequencerBatchDelivered event raised by the ISequencerInbox contract.
type ISequencerInboxSequencerBatchDelivered struct {
	BatchSequenceNumber      *big.Int
	BeforeAcc                [32]byte
	AfterAcc                 [32]byte
	DelayedAcc               [32]byte
	AfterDelayedMessagesRead *big.Int
	TimeBounds               IBridgeTimeBounds
	DataLocation             uint8
	Raw                      types.Log // Blockchain specific contextual infos
}

// FilterSequencerBatchDelivered is a free log retrieval operation binding the contract event 0x7394f4a19a13c7b92b5bb71033245305946ef78452f7b4986ac1390b5df4ebd7.
//
// Solidity: event SequencerBatchDelivered(uint256 indexed batchSequenceNumber, bytes32 indexed beforeAcc, bytes32 indexed afterAcc, bytes32 delayedAcc, uint256 afterDelayedMessagesRead, (uint64,uint64,uint64,uint64) timeBounds, uint8 dataLocation)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterSequencerBatchDelivered(opts *bind.FilterOpts, batchSequenceNumber []*big.Int, beforeAcc [][32]byte, afterAcc [][32]byte) (*ISequencerInboxSequencerBatchDeliveredIterator, error) {

	var batchSequenceNumberRule []interface{}
	for _, batchSequenceNumberItem := range batchSequenceNumber {
		batchSequenceNumberRule = append(batchSequenceNumberRule, batchSequenceNumberItem)
	}
	var beforeAccRule []interface{}
	for _, beforeAccItem := range beforeAcc {
		beforeAccRule = append(beforeAccRule, beforeAccItem)
	}
	var afterAccRule []interface{}
	for _, afterAccItem := range afterAcc {
		afterAccRule = append(afterAccRule, afterAccItem)
	}

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "SequencerBatchDelivered", batchSequenceNumberRule, beforeAccRule, afterAccRule)
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxSequencerBatchDeliveredIterator{contract: _ISequencerInbox.contract, event: "SequencerBatchDelivered", logs: logs, sub: sub}, nil
}

// WatchSequencerBatchDelivered is a free log subscription operation binding the contract event 0x7394f4a19a13c7b92b5bb71033245305946ef78452f7b4986ac1390b5df4ebd7.
//
// Solidity: event SequencerBatchDelivered(uint256 indexed batchSequenceNumber, bytes32 indexed beforeAcc, bytes32 indexed afterAcc, bytes32 delayedAcc, uint256 afterDelayedMessagesRead, (uint64,uint64,uint64,uint64) timeBounds, uint8 dataLocation)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchSequencerBatchDelivered(opts *bind.WatchOpts, sink chan<- *ISequencerInboxSequencerBatchDelivered, batchSequenceNumber []*big.Int, beforeAcc [][32]byte, afterAcc [][32]byte) (event.Subscription, error) {

	var batchSequenceNumberRule []interface{}
	for _, batchSequenceNumberItem := range batchSequenceNumber {
		batchSequenceNumberRule = append(batchSequenceNumberRule, batchSequenceNumberItem)
	}
	var beforeAccRule []interface{}
	for _, beforeAccItem := range beforeAcc {
		beforeAccRule = append(beforeAccRule, beforeAccItem)
	}
	var afterAccRule []interface{}
	for _, afterAccItem := range afterAcc {
		afterAccRule = append(afterAccRule, afterAccItem)
	}

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "SequencerBatchDelivered", batchSequenceNumberRule, beforeAccRule, afterAccRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxSequencerBatchDelivered)
				if err := _ISequencerInbox.contract.UnpackLog(event, "SequencerBatchDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSequencerBatchDelivered is a log parse operation binding the contract event 0x7394f4a19a13c7b92b5bb71033245305946ef78452f7b4986ac1390b5df4ebd7.
//
// Solidity: event SequencerBatchDelivered(uint256 indexed batchSequenceNumber, bytes32 indexed beforeAcc, bytes32 indexed afterAcc, bytes32 delayedAcc, uint256 afterDelayedMessagesRead, (uint64,uint64,uint64,uint64) timeBounds, uint8 dataLocation)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseSequencerBatchDelivered(log types.Log) (*ISequencerInboxSequencerBatchDelivered, error) {
	event := new(ISequencerInboxSequencerBatchDelivered)
	if err := _ISequencerInbox.contract.UnpackLog(event, "SequencerBatchDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ISequencerInboxSequencerSetIterator is returned from FilterSequencerSet and is used to iterate over the raw logs and unpacked data for SequencerSet events raised by the ISequencerInbox contract.
type ISequencerInboxSequencerSetIterator struct {
	Event *ISequencerInboxSequencerSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxSequencerSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxSequencerSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxSequencerSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxSequencerSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxSequencerSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxSequencerSet represents a SequencerSet event raised by the ISequencerInbox contract.
type ISequencerInboxSequencerSet struct {
	Addr        common.Address
	IsSequencer bool
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSequencerSet is a free log retrieval operation binding the contract event 0xeb12a9a53eec138c91b27b4f912a257bd690c18fc8bde744be92a0365eb9b87e.
//
// Solidity: event SequencerSet(address addr, bool isSequencer)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterSequencerSet(opts *bind.FilterOpts) (*ISequencerInboxSequencerSetIterator, error) {

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "SequencerSet")
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxSequencerSetIterator{contract: _ISequencerInbox.contract, event: "SequencerSet", logs: logs, sub: sub}, nil
}

// WatchSequencerSet is a free log subscription operation binding the contract event 0xeb12a9a53eec138c91b27b4f912a257bd690c18fc8bde744be92a0365eb9b87e.
//
// Solidity: event SequencerSet(address addr, bool isSequencer)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchSequencerSet(opts *bind.WatchOpts, sink chan<- *ISequencerInboxSequencerSet) (event.Subscription, error) {

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "SequencerSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxSequencerSet)
				if err := _ISequencerInbox.contract.UnpackLog(event, "SequencerSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSequencerSet is a log parse operation binding the contract event 0xeb12a9a53eec138c91b27b4f912a257bd690c18fc8bde744be92a0365eb9b87e.
//
// Solidity: event SequencerSet(address addr, bool isSequencer)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseSequencerSet(log types.Log) (*ISequencerInboxSequencerSet, error) {
	event := new(ISequencerInboxSequencerSet)
	if err := _ISequencerInbox.contract.UnpackLog(event, "SequencerSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// ISequencerInboxSetValidKeysetIterator is returned from FilterSetValidKeyset and is used to iterate over the raw logs and unpacked data for SetValidKeyset events raised by the ISequencerInbox contract.
type ISequencerInboxSetValidKeysetIterator struct {
	Event *ISequencerInboxSetValidKeyset // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ISequencerInboxSetValidKeysetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ISequencerInboxSetValidKeyset)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ISequencerInboxSetValidKeyset)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ISequencerInboxSetValidKeysetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ISequencerInboxSetValidKeysetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ISequencerInboxSetValidKeyset represents a SetValidKeyset event raised by the ISequencerInbox contract.
type ISequencerInboxSetValidKeyset struct {
	KeysetHash  [32]byte
	KeysetBytes []byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSetValidKeyset is a free log retrieval operation binding the contract event 0xabca9b7986bc22ad0160eb0cb88ae75411eacfba4052af0b457a9335ef655722.
//
// Solidity: event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes)
func (_ISequencerInbox *ISequencerInboxFilterer) FilterSetValidKeyset(opts *bind.FilterOpts, keysetHash [][32]byte) (*ISequencerInboxSetValidKeysetIterator, error) {

	var keysetHashRule []interface{}
	for _, keysetHashItem := range keysetHash {
		keysetHashRule = append(keysetHashRule, keysetHashItem)
	}

	logs, sub, err := _ISequencerInbox.contract.FilterLogs(opts, "SetValidKeyset", keysetHashRule)
	if err != nil {
		return nil, err
	}
	return &ISequencerInboxSetValidKeysetIterator{contract: _ISequencerInbox.contract, event: "SetValidKeyset", logs: logs, sub: sub}, nil
}

// WatchSetValidKeyset is a free log subscription operation binding the contract event 0xabca9b7986bc22ad0160eb0cb88ae75411eacfba4052af0b457a9335ef655722.
//
// Solidity: event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes)
func (_ISequencerInbox *ISequencerInboxFilterer) WatchSetValidKeyset(opts *bind.WatchOpts, sink chan<- *ISequencerInboxSetValidKeyset, keysetHash [][32]byte) (event.Subscription, error) {

	var keysetHashRule []interface{}
	for _, keysetHashItem := range keysetHash {
		keysetHashRule = append(keysetHashRule, keysetHashItem)
	}

	logs, sub, err := _ISequencerInbox.contract.WatchLogs(opts, "SetValidKeyset", keysetHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ISequencerInboxSetValidKeyset)
				if err := _ISequencerInbox.contract.UnpackLog(event, "SetValidKeyset", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetValidKeyset is a log parse operation binding the contract event 0xabca9b7986bc22ad0160eb0cb88ae75411eacfba4052af0b457a9335ef655722.
//
// Solidity: event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes)
func (_ISequencerInbox *ISequencerInboxFilterer) ParseSetValidKeyset(log types.Log) (*ISequencerInboxSetValidKeyset, error) {
	event := new(ISequencerInboxSetValidKeyset)
	if err := _ISequencerInbox.contract.UnpackLog(event, "SetValidKeyset", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// InboxMetaData contains all meta data concerning the Inbox contract.
var InboxMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDataSize\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDataLength\",\"type\":\"uint256\"}],\"name\":\"DataTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GasLimitTooLarge\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InsufficientSubmissionCost\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InsufficientValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"L1Forked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"origin\",\"type\":\"address\"}],\"name\":\"NotAllowedOrigin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotCodelessOrigin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotForked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOrigin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotRollupOrOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"RetryableData\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"AllowListAddressSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"}],\"name\":\"AllowListEnabledUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allowListEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFee\",\"type\":\"uint256\"}],\"name\":\"calculateRetryableSubmissionFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createRetryableTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createRetryableTicketNoRefundAliasRewrite\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProxyAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"_bridge\",\"type\":\"address\"},{\"internalType\":\"contractISequencerInbox\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDataSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"postUpgradeInit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendContractTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendL1FundedContractTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendL1FundedUnsignedTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendL1FundedUnsignedTransactionToFork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2Message\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"messageData\",\"type\":\"bytes\"}],\"name\":\"sendL2MessageFromOrigin\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendUnsignedTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"sendUnsignedTransactionToFork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"withdrawTo\",\"type\":\"address\"}],\"name\":\"sendWithdrawEthToFork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"contractISequencerInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"val\",\"type\":\"bool[]\"}],\"name\":\"setAllowList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_allowListEnabled\",\"type\":\"bool\"}],\"name\":\"setAllowListEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2CallValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSubmissionCost\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"excessFeeRefundAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"callValueRefundAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFeePerGas\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"unsafeCreateRetryableTicket\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]",
	Bin: "0x60e0346100ba57601f61234b38819003918201601f19168301916001600160401b038311848410176100bf578084926020946040528339810103126100ba5751306080524660c05260a05260405161227590816100d682396080518181816107900152611073015260a051818181610337015281816113da01528181611a4a01528181611b7d01528181611d610152611fb8015260c0518181816103b70152818161088501528181610baa015281816113a601526116500152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe60406080815260048036101561001457600080fd5b600090813560e01c8062f72382146116155780630f4d14e9146115b05780631b871c8d146115385780631fe927cf1461135657806322bd5c1c1461132f5780633f4ba83a146111d0578063439370b1146111b8578063485cc955146110005780635075788b14610f545780635c975abb14610f305780635e91675814610e86578063679b6ded14610d6357806367ef3ab814610cda5780636e6e8a6a14610cbc57806370665f1414610b5d5780638456cb5914610a2c5780638a631aa6146109575780638b3240a014610921578063a66b327d146108fd578063b75436bb1461082f578063babcc539146107f1578063c474d2c514610766578063e3de72a51461049e578063e6bd12cf14610383578063e78cea921461035a578063e8eb1dc31461031f578063ee35f327146102f65763efeadb6d1461015357600080fd5b346102f257602090816003193601126102ee578035908115158092036102ea57606554855163cb23bcb560e01b81526001600160a01b0391859082908590829086165afa9081156102e05790829187916102c3575b50169081330361023e575b50506066549060ff8260a01c161515831461020d575060ff60a01b191660a082901b60ff60a01b1617606655925192835290917f16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb39190a180f35b855162461bcd60e51b8152908101849052600b60248201526a1053149150511657d4d15560aa1b6044820152606490fd5b8651638da5cb5b60e01b81529085828581865afa9182156102b957879261028a575b5081163303156101b3578651630739600760e01b815291829161028691338487016118e5565b0390fd5b6102ab919250863d88116102b2575b6102a3818361188c565b8101906118c6565b9038610260565b503d610299565b88513d89823e3d90fd5b6102da9150863d88116102b2576102a3818361188c565b386101a8565b87513d88823e3d90fd5b8380fd5b8280fd5b5080fd5b8284346102f257816003193601126102f25760665490516001600160a01b039091168152602090f35b8284346102f257816003193601126102f257602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b8284346102f257816003193601126102f25760655490516001600160a01b039091168152602090f35b50919061038f36611811565b93979092949561039d611932565b8760ff60665460a01c169182610487575b505061047057467f00000000000000000000000000000000000000000000000000000000000000001461046257323303610454576001600160401b03861161044657509261041c61043f959361042a9360209996895196879560018060a01b03998a349416928e89016119bc565b03601f19810183528261188c565b34913361111061111160901b01190116611b77565b9051908152f35b865163107c527b60e01b8152fd5b865163feb3d07160e01b8152fd5b8651635180dd8360e11b8152fd5b602490875190630f51ed7160e41b82523290820152fd5b60ff925032815260676020522054161587386103ae565b509190346107635781600319360112610763578235926001600160401b038085116102ee57366023860112156102ee5784820135946104dc866118af565b946104e98151968761188c565b8686526020918287016024809960051b8301019136831161073c578901905b8282106107445750505086359283116107405736602384011215610740578284013592610534846118af565b936105418351958661188c565b808552888486019160051b8301019136831161073c578901905b828210610720575050606554825163cb23bcb560e01b81526001600160a01b03925090849082908890829086165afa9081156107165790829188916106f9575b5016803303610685575b50865184510361065357855b875181101561064f576105c48186611908565b511515826105d2838b611908565b51168852606785528388209060ff80198354169116179055816105f5828a611908565b51167fd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a856106238489611908565b5115158651908152a2600019811461063d576001016105b1565b634e487b7160e01b8752601186528887fd5b8680f35b815162461bcd60e51b8152808601849052600d818a01526c1253959053125117d253941555609a1b6044820152606490fd5b8251638da5cb5b60e01b815284818881855afa9081156106ef5788916106d2575b5082811633036106b657506105a5565b8351630739600760e01b81529182916102869133848b016118e5565b6106e99150853d87116102b2576102a3818361188c565b386106a6565b84513d8a823e3d90fd5b6107109150853d87116102b2576102a3818361188c565b3861059b565b83513d89823e3d90fd5b8135801515810361073857815290840190840161055b565b8880fd5b8780fd5b8480fd5b81356001600160a01b0381168103610738578152908401908401610508565b80fd5b5082346102ee5760203660031901126102ee57610781611710565b506001600160a01b036107b8307f000000000000000000000000000000000000000000000000000000000000000083161415611c3d565b6000805160206122008339815191525416908133036107d5578380f35b604493505191631194af8760e11b835233908301526024820152fd5b8284346102f25760203660031901126102f25760209160ff9082906001600160a01b0361081c611710565b1681526067855220541690519015158152f35b508290346102ee5760203660031901126102ee5780356001600160401b0381116102ea576108609036908301611726565b91909361086b611932565b8360ff60665460a01c1691826108e6575b50506108cf57467f0000000000000000000000000000000000000000000000000000000000000000036108c157506108bb60209361043f923691611976565b33611a46565b825163c6ea680360e01b8152fd5b602490835190630f51ed7160e41b82523290820152fd5b60ff9250328152606760205220541615838661087c565b509190346107635781600319360112610763575061043f60209260243590356121ad565b8284346102f257816003193601126102f2576000805160206122008339815191525490516001600160a01b039091168152602090f35b508290346102ee5760a03660031901126102ee578035906109766116f5565b936001600160401b03916084358381116102ee576109979036908301611726565b9390926109a2611932565b8660ff60665460a01c169182610a15575b50506109ff5784116109f15750835160209561043f9491936108bb93859361041c93606435916001600160a01b039091169060243590878d016119f1565b845163107c527b60e01b8152fd5b8551630f51ed7160e41b81523281840152602490fd5b60ff925032815260676020522054161586896109b3565b5082346102ee57826003193601126102ee57606554815163cb23bcb560e01b81526020936001600160a01b0392909190859082908490829087165afa908115610b53579083918791610b36575b501691823303610ac5575b857f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a2588686610ab0611932565b600160ff19603354161760335551338152a180f35b8351638da5cb5b60e01b81529085828481875afa918215610b2c578792610b0d575b508116330315610a8457610286908451938493630739600760e01b8552339085016118e5565b610b25919250863d88116102b2576102a3818361188c565b9087610ae7565b85513d89823e3d90fd5b610b4d9150863d88116102b2576102a3818361188c565b87610a79565b84513d88823e3d90fd5b508290346102ee5760a03660031901126102ee578035926001600160a01b039160843583811691908290036102ee57610b94611932565b60ff60665460a01c1680610ca6575b610c8f57467f000000000000000000000000000000000000000000000000000000000000000014610c8157323303610c73576001600160401b0386116109f1575091610c6060c16020969361043f95610c5088518a8101926325e1606360e01b8452602482015260248152610c178161185b565b89519788948c8601526021850152602435604185015260443560618501526064608185015260643560a185015251809285850190611a23565b81010360a181018552018361188c565b3361111061111160901b01190116611a46565b845163feb3d07160e01b8152fd5b8451635180dd8360e11b8152fd5b602490855190630f51ed7160e41b82523290820152fd5b50328352606760205260ff858420541615610ba3565b60208461043f610ccb366117a6565b97969096959195949294612163565b509190610ce636611811565b94919297909395610cf5611932565b8760ff60665460a01c169182610d4c575b5050610470576001600160401b038211610446575060209693610d449361043f969361041c938951978896349360018060a01b0316928d89016119bc565b349033611b77565b60ff92503281526067602052205416158738610d06565b509190610d6f366117a6565b9a94939098610d82979297969396611932565b8a60ff60665460a01c169182610e6f575b5050610e5957838195610db9610da98587611ecd565b610db38b8b611ef0565b90611ecd565b3410610e2557509161043f99979593918360209d9a9896943b610e06575b50803b610de7575b503496611f03565b6001600160a01b0390811661111161111160901b010116935038610ddf565b6001600160a01b0390811661111161111160901b010116935038610dd7565b6044908c610e418a610db38d610e3b8a8c611ecd565b92611ef0565b9051631c102d6360e21b815291820152346024820152fd5b8951630f51ed7160e41b81523281870152602490fd5b60ff92503281526067602052205416158a38610d93565b50829060803660031901126102ee57803590610ea06116f5565b936001600160401b03916064358381116102ee57610ec19036908301611726565b939092610ecc611932565b8660ff60665460a01c169182610f19575b50506109ff5784116109f15750835160209561043f949193610d4493859361041c9334916001600160a01b039091169060243590878d016119f1565b60ff92503281526067602052205416158689610edd565b8284346102f257816003193601126102f25760209060ff6033541690519015158152f35b508290346102ee57610f6536611753565b959296909498610f76949294611932565b8860ff60665460a01c169182610fe9575b5050610fd2576001600160401b038311610fc45750936108bb9361043f969361041c9360209a978a5198899760018060a01b0316928d89016119bc565b875163107c527b60e01b8152fd5b602490885190630f51ed7160e41b82523290820152fd5b60ff9250328152606760205220541615888b610f87565b508290346102ee57816003193601126102ee5761101b611710565b6001600160a01b03919060243583811691908290036111b45785549160ff8360081c1615938480956111a7575b8015611190575b156111365750906110de9160ff1993856001868316178a55611125575b5061109b867f000000000000000000000000000000000000000000000000000000000000000016301415611c3d565b87549560ff8760081c16926110af84611c9e565b1660018060a01b0319606554161760655560018060a81b031960665416176066556110d981611c9e565b611c9e565b603354166033556110ed578280f35b61ff001916825551600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb384740249890602090a181808280f35b61ffff19166101011788558861106c565b608490602088519162461bcd60e51b8352820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152fd5b50303b15801561104f5750600160ff85161461104f565b50600160ff851610611048565b8580fd5b8284816003193601126102f25760209061043f611cfe565b5091346102f257816003193601126102f257606554815163cb23bcb560e01b8152602092916001600160a01b039190849082908890829086165afa908115611325579082918691611308575b5016908133036112a1575b50506033549360ff85161561126957507f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa929360ff191660335551338152a180f35b82606492519162461bcd60e51b8352820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b6044820152fd5b8251638da5cb5b60e01b81529084828881865afa918215610b535786926112e9575b508116330315611227578251630739600760e01b81529182916102869133848a016118e5565b611301919250853d87116102b2576102a3818361188c565b90386112c3565b61131f9150853d87116102b2576102a3818361188c565b3861121c565b83513d87823e3d90fd5b8284346102f257816003193601126102f25760209060ff60665460a01c1690519015158152f35b5091346102f257602092836003193601126102ee5780356001600160401b0381116102ea576113889036908301611726565b611390611932565b60ff60665460a01c1680611523575b61150d57467f0000000000000000000000000000000000000000000000000000000000000000036114fd57323314806114f4575b156114e4577f00000000000000000000000000000000000000000000000000000000000000008082116114c95750606461141287936003933691611976565b8051908401206065548651638db5993b60e01b8152958601939093526001600160a01b0361111161111160901b013301811660248701526044860191909152849283918891165af19081156114bd578391611482575b506000805160206122208339815191528192519380a28152f35b90508381813d83116114b6575b611499818361188c565b810103126102ee5751600080516020612220833981519152611468565b503d61148f565b505051903d90823e3d90fd5b91506044935192634634691b60e01b84528301526024820152fd5b835163c8958ead60e01b81528390fd5b50333b156113d3565b835163c6ea680360e01b81528390fd5b8351630f51ed7160e41b81523281850152602490fd5b503285526067865260ff84862054161561139f565b5090611543366117a6565b999098611557989298979397969496611932565b8b60ff60665460a01c169182611599575b50506115825760208b61043f8c8c8c8c8c8c8c8c8c612163565b6024908b5190630f51ed7160e41b82523290820152fd5b60ff92503281526067602052205416158b38611568565b50906020366003190112610763576115c6611932565b8260ff60665460a01c1691826115fe575b50506115e85760208261043f611cfe565b6024915190630f51ed7160e41b82523290820152fd5b60ff925032815260676020522054161582386115d7565b508290346102ee5761162636611753565b9495919296909398611636611932565b8860ff60665460a01c1691826116de575b5050610fd257467f0000000000000000000000000000000000000000000000000000000000000000146116d0573233036116c2576001600160401b038211610fc4575061043f9593610c609360209996936116b4938a5198899660018060a01b03809a16928e89016119bc565b03601f19810184528361188c565b875163feb3d07160e01b8152fd5b8751635180dd8360e11b8152fd5b60ff9250328152606760205220541615888b611647565b604435906001600160a01b038216820361170b57565b600080fd5b600435906001600160a01b038216820361170b57565b9181601f8401121561170b578235916001600160401b03831161170b576020838186019501011161170b57565b9060c060031983011261170b576004359160243591604435916064356001600160a01b038116810361170b57916084359160a435906001600160401b03821161170b576117a291600401611726565b9091565b61010060031982011261170b576001600160a01b0391600435838116810361170b57926024359260443592606435838116810361170b5792608435908116810361170b579160a4359160c4359160e435906001600160401b03821161170b576117a291600401611726565b60a060031982011261170b576004359160243591604435916064356001600160a01b038116810361170b5791608435906001600160401b03821161170b576117a291600401611726565b606081019081106001600160401b0382111761187657604052565b634e487b7160e01b600052604160045260246000fd5b601f909101601f19168101906001600160401b0382119082101761187657604052565b6001600160401b0381116118765760051b60200190565b9081602091031261170b57516001600160a01b038116810361170b5790565b6001600160a01b0391821681529181166020830152909116604082015260600190565b805182101561191c5760209160051b010190565b634e487b7160e01b600052603260045260246000fd5b60ff6033541661193e57565b60405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b6044820152606490fd5b9192916001600160401b038211611876576040519161199f601f8201601f19166020018461188c565b82948184528183011161170b578281602093846000960137010152565b94919287969360a198959260008852600188015260218701526041860152606185015260818401528483013701016000815290565b93909286959260819794600160f81b875260018701526021860152604185015260618401528483013701016000815290565b60005b838110611a365750506000910152565b8181015183820152602001611a26565b81517f0000000000000000000000000000000000000000000000000000000000000000808211611b5957505081516020808401918220606554604051638db5993b60e01b8152600360048201526001600160a01b0395861661111161111160901b01018616602482015260448101929092529093919291839185916064918391600091165af1928315611b4d57600093611b1d575b5090604083946000805160206121e083398151915293611b0d8351948593818552519283809286015285850190611a23565b601f01601f19168101030190a290565b90928282813d8311611b46575b611b34818361188c565b81010312610763575051916040611adb565b503d611b2a565b6040513d6000823e3d90fd5b6044925060405191634634691b60e01b835260048301526024820152fd5b909182517f0000000000000000000000000000000000000000000000000000000000000000808211611b5957505082516020808501918220606554604051638db5993b60e01b8152600760048201526001600160a01b0396871661111161111160901b0101871660248201526044810192909252909491938492869260649284929091165af1928315611b4d57600093611b1d575090604083946000805160206121e083398151915293611b0d8351948593818552519283809286015285850190611a23565b15611c4457565b60405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201526b19195b1959d85d1958d85b1b60a21b6064820152608490fd5b15611ca557565b60405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201526a6e697469616c697a696e6760a81b6064820152608490fd5b611d06611932565b60ff60665460a01c1680611eb4575b611e9c5733803b15801590611e92575b611e79575b6040805160609290921b6001600160601b03191660208084019182523460348086019190915284529091611d5d8461185b565b83517f0000000000000000000000000000000000000000000000000000000000000000808211611e5e575050835183206065548251638db5993b60e01b8152600c60048201526001600160a01b0361111161111160901b01330181166024830152604482019390935294918491869160649183913491165af1938415611e5357600094611e16575b509083946000805160206121e08339815191529392611b0d8351948593818552519283809286015285850190611a23565b90938382813d8311611e4c575b611e2d818361188c565b81010312610763575051926000805160206121e0833981519152611de5565b503d611e23565b82513d6000823e3d90fd5b6044925191634634691b60e01b835260048301526024820152fd5b61111161111160901b01016001600160a01b0316611d2a565b5080321415611d25565b604051630f51ed7160e41b8152326004820152602490fd5b5032600052606760205260ff6040600020541615611d15565b91908201809211611eda57565b634e487b7160e01b600052601160045260246000fd5b81810292918115918404141715611eda57565b95929998939097949199600183148015612159575b6120d6576001600160401b0383116120c457611f3448866121ad565b808c106120a65750611fb4969798999a6040519a60208c019960018060a01b03168a5260408c01528960608c015260808b015260018060a01b031660a08a015260018060a01b031660c089015260e0880152610100870152856101209180838301528061014094858401378101600084820152039081018652018461188c565b82517f0000000000000000000000000000000000000000000000000000000000000000808211611b5957505082518120606554604051638db5993b60e01b8152600960048201526001600160a01b0361111161111160901b01330181166024830152604482019390935293602092859260649284929091165af1918215611b4d57600092612070575b50611b0d604083946000805160206121e08339815191529382519384926020845251809281602086015285850190611a23565b90916020823d60201161209e575b8161208b6020938361188c565b8101031261076357505190611b0d61203d565b3d915061207e565b6044908c60405191637d6f91c560e11b835260048301526024820152fd5b60405163107c527b60e01b8152600490fd5b908a9795968992604051998a986307c266e360e01b8a523360048b015260018060a01b03958680951660248c015260448b015260648a015260848901521660a48701521660c485015260e4840152610104830152610140610124830152806101448301528061016493848401376000828201840152601f01601f19168101030190fd5b5060018414611f18565b9492909796959391612173611932565b60ff60665460a01c1680612194575b611e9c57612191983496611f03565b90565b5032600052606760205260ff6040600020541615612182565b80600602906006820403611eda57610578908101809111611eda5761219191806121d957504890611ef0565b90611ef056feff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60bb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103ab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9ca264697066735822122022daaf1eac03ceeaaa7ff4c530301e9cc6dfd5845cf4da35c227ef4984cfb2d164736f6c63430008130033",
}

// InboxABI is the input ABI used to generate the binding from.
// Deprecated: Use InboxMetaData.ABI instead.
var InboxABI = InboxMetaData.ABI

// InboxBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use InboxMetaData.Bin instead.
var InboxBin = InboxMetaData.Bin

// DeployInbox deploys a new Ethereum contract, binding an instance of Inbox to it.
func DeployInbox(auth *bind.TransactOpts, backend bind.ContractBackend, _maxDataSize *big.Int) (common.Address, *types.Transaction, *Inbox, error) {
	parsed, err := InboxMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(InboxBin), backend, _maxDataSize)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Inbox{InboxCaller: InboxCaller{contract: contract}, InboxTransactor: InboxTransactor{contract: contract}, InboxFilterer: InboxFilterer{contract: contract}}, nil
}

// Inbox is an auto generated Go binding around an Ethereum contract.
type Inbox struct {
	InboxCaller     // Read-only binding to the contract
	InboxTransactor // Write-only binding to the contract
	InboxFilterer   // Log filterer for contract events
}

// InboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type InboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// InboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type InboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// InboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type InboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// InboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type InboxSession struct {
	Contract     *Inbox            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// InboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type InboxCallerSession struct {
	Contract *InboxCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// InboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type InboxTransactorSession struct {
	Contract     *InboxTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// InboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type InboxRaw struct {
	Contract *Inbox // Generic contract binding to access the raw methods on
}

// InboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type InboxCallerRaw struct {
	Contract *InboxCaller // Generic read-only contract binding to access the raw methods on
}

// InboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type InboxTransactorRaw struct {
	Contract *InboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewInbox creates a new instance of Inbox, bound to a specific deployed contract.
func NewInbox(address common.Address, backend bind.ContractBackend) (*Inbox, error) {
	contract, err := bindInbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Inbox{InboxCaller: InboxCaller{contract: contract}, InboxTransactor: InboxTransactor{contract: contract}, InboxFilterer: InboxFilterer{contract: contract}}, nil
}

// NewInboxCaller creates a new read-only instance of Inbox, bound to a specific deployed contract.
func NewInboxCaller(address common.Address, caller bind.ContractCaller) (*InboxCaller, error) {
	contract, err := bindInbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &InboxCaller{contract: contract}, nil
}

// NewInboxTransactor creates a new write-only instance of Inbox, bound to a specific deployed contract.
func NewInboxTransactor(address common.Address, transactor bind.ContractTransactor) (*InboxTransactor, error) {
	contract, err := bindInbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &InboxTransactor{contract: contract}, nil
}

// NewInboxFilterer creates a new log filterer instance of Inbox, bound to a specific deployed contract.
func NewInboxFilterer(address common.Address, filterer bind.ContractFilterer) (*InboxFilterer, error) {
	contract, err := bindInbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &InboxFilterer{contract: contract}, nil
}

// bindInbox binds a generic wrapper to an already deployed contract.
func bindInbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := InboxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Inbox *InboxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Inbox.Contract.InboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Inbox *InboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Inbox.Contract.InboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Inbox *InboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Inbox.Contract.InboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Inbox *InboxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Inbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Inbox *InboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Inbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Inbox *InboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Inbox.Contract.contract.Transact(opts, method, params...)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_Inbox *InboxCaller) AllowListEnabled(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _Inbox.contract.Call(opts, &out, "allowListEnabled")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_Inbox *InboxSession) AllowListEnabled() (bool, error) {
	return _Inbox.Contract.AllowListEnabled(&_Inbox.CallOpts)
}

// AllowListEnabled is a free data retrieval call binding the contract method 0x22bd5c1c.
//
// Solidity: function allowListEnabled() view returns(bool)
func (_Inbox *InboxCallerSession) AllowListEnabled() (bool, error) {
	return _Inbox.Contract.AllowListEnabled(&_Inbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_Inbox *InboxCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Inbox.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_Inbox *InboxSession) Bridge() (common.Address, error) {
	return _Inbox.Contract.Bridge(&_Inbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_Inbox *InboxCallerSession) Bridge() (common.Address, error) {
	return _Inbox.Contract.Bridge(&_Inbox.CallOpts)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_Inbox *InboxCaller) CalculateRetryableSubmissionFee(opts *bind.CallOpts, dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _Inbox.contract.Call(opts, &out, "calculateRetryableSubmissionFee", dataLength, baseFee)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_Inbox *InboxSession) CalculateRetryableSubmissionFee(dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	return _Inbox.Contract.CalculateRetryableSubmissionFee(&_Inbox.CallOpts, dataLength, baseFee)
}

// CalculateRetryableSubmissionFee is a free data retrieval call binding the contract method 0xa66b327d.
//
// Solidity: function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee) view returns(uint256)
func (_Inbox *InboxCallerSession) CalculateRetryableSubmissionFee(dataLength *big.Int, baseFee *big.Int) (*big.Int, error) {
	return _Inbox.Contract.CalculateRetryableSubmissionFee(&_Inbox.CallOpts, dataLength, baseFee)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_Inbox *InboxCaller) GetProxyAdmin(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Inbox.contract.Call(opts, &out, "getProxyAdmin")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_Inbox *InboxSession) GetProxyAdmin() (common.Address, error) {
	return _Inbox.Contract.GetProxyAdmin(&_Inbox.CallOpts)
}

// GetProxyAdmin is a free data retrieval call binding the contract method 0x8b3240a0.
//
// Solidity: function getProxyAdmin() view returns(address)
func (_Inbox *InboxCallerSession) GetProxyAdmin() (common.Address, error) {
	return _Inbox.Contract.GetProxyAdmin(&_Inbox.CallOpts)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address ) view returns(bool)
func (_Inbox *InboxCaller) IsAllowed(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _Inbox.contract.Call(opts, &out, "isAllowed", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address ) view returns(bool)
func (_Inbox *InboxSession) IsAllowed(arg0 common.Address) (bool, error) {
	return _Inbox.Contract.IsAllowed(&_Inbox.CallOpts, arg0)
}

// IsAllowed is a free data retrieval call binding the contract method 0xbabcc539.
//
// Solidity: function isAllowed(address ) view returns(bool)
func (_Inbox *InboxCallerSession) IsAllowed(arg0 common.Address) (bool, error) {
	return _Inbox.Contract.IsAllowed(&_Inbox.CallOpts, arg0)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_Inbox *InboxCaller) MaxDataSize(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Inbox.contract.Call(opts, &out, "maxDataSize")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_Inbox *InboxSession) MaxDataSize() (*big.Int, error) {
	return _Inbox.Contract.MaxDataSize(&_Inbox.CallOpts)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_Inbox *InboxCallerSession) MaxDataSize() (*big.Int, error) {
	return _Inbox.Contract.MaxDataSize(&_Inbox.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Inbox *InboxCaller) Paused(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _Inbox.contract.Call(opts, &out, "paused")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Inbox *InboxSession) Paused() (bool, error) {
	return _Inbox.Contract.Paused(&_Inbox.CallOpts)
}

// Paused is a free data retrieval call binding the contract method 0x5c975abb.
//
// Solidity: function paused() view returns(bool)
func (_Inbox *InboxCallerSession) Paused() (bool, error) {
	return _Inbox.Contract.Paused(&_Inbox.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_Inbox *InboxCaller) SequencerInbox(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Inbox.contract.Call(opts, &out, "sequencerInbox")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_Inbox *InboxSession) SequencerInbox() (common.Address, error) {
	return _Inbox.Contract.SequencerInbox(&_Inbox.CallOpts)
}

// SequencerInbox is a free data retrieval call binding the contract method 0xee35f327.
//
// Solidity: function sequencerInbox() view returns(address)
func (_Inbox *InboxCallerSession) SequencerInbox() (common.Address, error) {
	return _Inbox.Contract.SequencerInbox(&_Inbox.CallOpts)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x679b6ded.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_Inbox *InboxTransactor) CreateRetryableTicket(opts *bind.TransactOpts, to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "createRetryableTicket", to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x679b6ded.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_Inbox *InboxSession) CreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.CreateRetryableTicket(&_Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// CreateRetryableTicket is a paid mutator transaction binding the contract method 0x679b6ded.
//
// Solidity: function createRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_Inbox *InboxTransactorSession) CreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.CreateRetryableTicket(&_Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// CreateRetryableTicketNoRefundAliasRewrite is a paid mutator transaction binding the contract method 0x1b871c8d.
//
// Solidity: function createRetryableTicketNoRefundAliasRewrite(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_Inbox *InboxTransactor) CreateRetryableTicketNoRefundAliasRewrite(opts *bind.TransactOpts, to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "createRetryableTicketNoRefundAliasRewrite", to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// CreateRetryableTicketNoRefundAliasRewrite is a paid mutator transaction binding the contract method 0x1b871c8d.
//
// Solidity: function createRetryableTicketNoRefundAliasRewrite(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_Inbox *InboxSession) CreateRetryableTicketNoRefundAliasRewrite(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.CreateRetryableTicketNoRefundAliasRewrite(&_Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// CreateRetryableTicketNoRefundAliasRewrite is a paid mutator transaction binding the contract method 0x1b871c8d.
//
// Solidity: function createRetryableTicketNoRefundAliasRewrite(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_Inbox *InboxTransactorSession) CreateRetryableTicketNoRefundAliasRewrite(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.CreateRetryableTicketNoRefundAliasRewrite(&_Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// DepositEth0f4d14e9 is a paid mutator transaction binding the contract method 0x0f4d14e9.
//
// Solidity: function depositEth(uint256 ) payable returns(uint256)
func (_Inbox *InboxTransactor) DepositEth0f4d14e9(opts *bind.TransactOpts, arg0 *big.Int) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "depositEth", arg0)
}

// DepositEth0f4d14e9 is a paid mutator transaction binding the contract method 0x0f4d14e9.
//
// Solidity: function depositEth(uint256 ) payable returns(uint256)
func (_Inbox *InboxSession) DepositEth0f4d14e9(arg0 *big.Int) (*types.Transaction, error) {
	return _Inbox.Contract.DepositEth0f4d14e9(&_Inbox.TransactOpts, arg0)
}

// DepositEth0f4d14e9 is a paid mutator transaction binding the contract method 0x0f4d14e9.
//
// Solidity: function depositEth(uint256 ) payable returns(uint256)
func (_Inbox *InboxTransactorSession) DepositEth0f4d14e9(arg0 *big.Int) (*types.Transaction, error) {
	return _Inbox.Contract.DepositEth0f4d14e9(&_Inbox.TransactOpts, arg0)
}

// DepositEth439370b1 is a paid mutator transaction binding the contract method 0x439370b1.
//
// Solidity: function depositEth() payable returns(uint256)
func (_Inbox *InboxTransactor) DepositEth439370b1(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "depositEth0")
}

// DepositEth439370b1 is a paid mutator transaction binding the contract method 0x439370b1.
//
// Solidity: function depositEth() payable returns(uint256)
func (_Inbox *InboxSession) DepositEth439370b1() (*types.Transaction, error) {
	return _Inbox.Contract.DepositEth439370b1(&_Inbox.TransactOpts)
}

// DepositEth439370b1 is a paid mutator transaction binding the contract method 0x439370b1.
//
// Solidity: function depositEth() payable returns(uint256)
func (_Inbox *InboxTransactorSession) DepositEth439370b1() (*types.Transaction, error) {
	return _Inbox.Contract.DepositEth439370b1(&_Inbox.TransactOpts)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_Inbox *InboxTransactor) Initialize(opts *bind.TransactOpts, _bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "initialize", _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_Inbox *InboxSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _Inbox.Contract.Initialize(&_Inbox.TransactOpts, _bridge, _sequencerInbox)
}

// Initialize is a paid mutator transaction binding the contract method 0x485cc955.
//
// Solidity: function initialize(address _bridge, address _sequencerInbox) returns()
func (_Inbox *InboxTransactorSession) Initialize(_bridge common.Address, _sequencerInbox common.Address) (*types.Transaction, error) {
	return _Inbox.Contract.Initialize(&_Inbox.TransactOpts, _bridge, _sequencerInbox)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_Inbox *InboxTransactor) Pause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "pause")
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_Inbox *InboxSession) Pause() (*types.Transaction, error) {
	return _Inbox.Contract.Pause(&_Inbox.TransactOpts)
}

// Pause is a paid mutator transaction binding the contract method 0x8456cb59.
//
// Solidity: function pause() returns()
func (_Inbox *InboxTransactorSession) Pause() (*types.Transaction, error) {
	return _Inbox.Contract.Pause(&_Inbox.TransactOpts)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0xc474d2c5.
//
// Solidity: function postUpgradeInit(address ) returns()
func (_Inbox *InboxTransactor) PostUpgradeInit(opts *bind.TransactOpts, arg0 common.Address) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "postUpgradeInit", arg0)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0xc474d2c5.
//
// Solidity: function postUpgradeInit(address ) returns()
func (_Inbox *InboxSession) PostUpgradeInit(arg0 common.Address) (*types.Transaction, error) {
	return _Inbox.Contract.PostUpgradeInit(&_Inbox.TransactOpts, arg0)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0xc474d2c5.
//
// Solidity: function postUpgradeInit(address ) returns()
func (_Inbox *InboxTransactorSession) PostUpgradeInit(arg0 common.Address) (*types.Transaction, error) {
	return _Inbox.Contract.PostUpgradeInit(&_Inbox.TransactOpts, arg0)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_Inbox *InboxTransactor) SendContractTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "sendContractTransaction", gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_Inbox *InboxSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendContractTransaction(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendContractTransaction is a paid mutator transaction binding the contract method 0x8a631aa6.
//
// Solidity: function sendContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, uint256 value, bytes data) returns(uint256)
func (_Inbox *InboxTransactorSession) SendContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendContractTransaction(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, to, value, data)
}

// SendL1FundedContractTransaction is a paid mutator transaction binding the contract method 0x5e916758.
//
// Solidity: function sendL1FundedContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, bytes data) payable returns(uint256)
func (_Inbox *InboxTransactor) SendL1FundedContractTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "sendL1FundedContractTransaction", gasLimit, maxFeePerGas, to, data)
}

// SendL1FundedContractTransaction is a paid mutator transaction binding the contract method 0x5e916758.
//
// Solidity: function sendL1FundedContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, bytes data) payable returns(uint256)
func (_Inbox *InboxSession) SendL1FundedContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendL1FundedContractTransaction(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, to, data)
}

// SendL1FundedContractTransaction is a paid mutator transaction binding the contract method 0x5e916758.
//
// Solidity: function sendL1FundedContractTransaction(uint256 gasLimit, uint256 maxFeePerGas, address to, bytes data) payable returns(uint256)
func (_Inbox *InboxTransactorSession) SendL1FundedContractTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendL1FundedContractTransaction(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, to, data)
}

// SendL1FundedUnsignedTransaction is a paid mutator transaction binding the contract method 0x67ef3ab8.
//
// Solidity: function sendL1FundedUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes data) payable returns(uint256)
func (_Inbox *InboxTransactor) SendL1FundedUnsignedTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "sendL1FundedUnsignedTransaction", gasLimit, maxFeePerGas, nonce, to, data)
}

// SendL1FundedUnsignedTransaction is a paid mutator transaction binding the contract method 0x67ef3ab8.
//
// Solidity: function sendL1FundedUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes data) payable returns(uint256)
func (_Inbox *InboxSession) SendL1FundedUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendL1FundedUnsignedTransaction(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, data)
}

// SendL1FundedUnsignedTransaction is a paid mutator transaction binding the contract method 0x67ef3ab8.
//
// Solidity: function sendL1FundedUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes data) payable returns(uint256)
func (_Inbox *InboxTransactorSession) SendL1FundedUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendL1FundedUnsignedTransaction(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, data)
}

// SendL1FundedUnsignedTransactionToFork is a paid mutator transaction binding the contract method 0xe6bd12cf.
//
// Solidity: function sendL1FundedUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes data) payable returns(uint256)
func (_Inbox *InboxTransactor) SendL1FundedUnsignedTransactionToFork(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "sendL1FundedUnsignedTransactionToFork", gasLimit, maxFeePerGas, nonce, to, data)
}

// SendL1FundedUnsignedTransactionToFork is a paid mutator transaction binding the contract method 0xe6bd12cf.
//
// Solidity: function sendL1FundedUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes data) payable returns(uint256)
func (_Inbox *InboxSession) SendL1FundedUnsignedTransactionToFork(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendL1FundedUnsignedTransactionToFork(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, data)
}

// SendL1FundedUnsignedTransactionToFork is a paid mutator transaction binding the contract method 0xe6bd12cf.
//
// Solidity: function sendL1FundedUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, bytes data) payable returns(uint256)
func (_Inbox *InboxTransactorSession) SendL1FundedUnsignedTransactionToFork(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendL1FundedUnsignedTransactionToFork(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, data)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_Inbox *InboxTransactor) SendL2Message(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "sendL2Message", messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_Inbox *InboxSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendL2Message(&_Inbox.TransactOpts, messageData)
}

// SendL2Message is a paid mutator transaction binding the contract method 0xb75436bb.
//
// Solidity: function sendL2Message(bytes messageData) returns(uint256)
func (_Inbox *InboxTransactorSession) SendL2Message(messageData []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendL2Message(&_Inbox.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_Inbox *InboxTransactor) SendL2MessageFromOrigin(opts *bind.TransactOpts, messageData []byte) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "sendL2MessageFromOrigin", messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_Inbox *InboxSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendL2MessageFromOrigin(&_Inbox.TransactOpts, messageData)
}

// SendL2MessageFromOrigin is a paid mutator transaction binding the contract method 0x1fe927cf.
//
// Solidity: function sendL2MessageFromOrigin(bytes messageData) returns(uint256)
func (_Inbox *InboxTransactorSession) SendL2MessageFromOrigin(messageData []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendL2MessageFromOrigin(&_Inbox.TransactOpts, messageData)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_Inbox *InboxTransactor) SendUnsignedTransaction(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "sendUnsignedTransaction", gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_Inbox *InboxSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendUnsignedTransaction(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransaction is a paid mutator transaction binding the contract method 0x5075788b.
//
// Solidity: function sendUnsignedTransaction(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_Inbox *InboxTransactorSession) SendUnsignedTransaction(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendUnsignedTransaction(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransactionToFork is a paid mutator transaction binding the contract method 0x00f72382.
//
// Solidity: function sendUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_Inbox *InboxTransactor) SendUnsignedTransactionToFork(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "sendUnsignedTransactionToFork", gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransactionToFork is a paid mutator transaction binding the contract method 0x00f72382.
//
// Solidity: function sendUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_Inbox *InboxSession) SendUnsignedTransactionToFork(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendUnsignedTransactionToFork(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendUnsignedTransactionToFork is a paid mutator transaction binding the contract method 0x00f72382.
//
// Solidity: function sendUnsignedTransactionToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, address to, uint256 value, bytes data) returns(uint256)
func (_Inbox *InboxTransactorSession) SendUnsignedTransactionToFork(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, to common.Address, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.SendUnsignedTransactionToFork(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, to, value, data)
}

// SendWithdrawEthToFork is a paid mutator transaction binding the contract method 0x70665f14.
//
// Solidity: function sendWithdrawEthToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, uint256 value, address withdrawTo) returns(uint256)
func (_Inbox *InboxTransactor) SendWithdrawEthToFork(opts *bind.TransactOpts, gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, value *big.Int, withdrawTo common.Address) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "sendWithdrawEthToFork", gasLimit, maxFeePerGas, nonce, value, withdrawTo)
}

// SendWithdrawEthToFork is a paid mutator transaction binding the contract method 0x70665f14.
//
// Solidity: function sendWithdrawEthToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, uint256 value, address withdrawTo) returns(uint256)
func (_Inbox *InboxSession) SendWithdrawEthToFork(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, value *big.Int, withdrawTo common.Address) (*types.Transaction, error) {
	return _Inbox.Contract.SendWithdrawEthToFork(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, value, withdrawTo)
}

// SendWithdrawEthToFork is a paid mutator transaction binding the contract method 0x70665f14.
//
// Solidity: function sendWithdrawEthToFork(uint256 gasLimit, uint256 maxFeePerGas, uint256 nonce, uint256 value, address withdrawTo) returns(uint256)
func (_Inbox *InboxTransactorSession) SendWithdrawEthToFork(gasLimit *big.Int, maxFeePerGas *big.Int, nonce *big.Int, value *big.Int, withdrawTo common.Address) (*types.Transaction, error) {
	return _Inbox.Contract.SendWithdrawEthToFork(&_Inbox.TransactOpts, gasLimit, maxFeePerGas, nonce, value, withdrawTo)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_Inbox *InboxTransactor) SetAllowList(opts *bind.TransactOpts, user []common.Address, val []bool) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "setAllowList", user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_Inbox *InboxSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _Inbox.Contract.SetAllowList(&_Inbox.TransactOpts, user, val)
}

// SetAllowList is a paid mutator transaction binding the contract method 0xe3de72a5.
//
// Solidity: function setAllowList(address[] user, bool[] val) returns()
func (_Inbox *InboxTransactorSession) SetAllowList(user []common.Address, val []bool) (*types.Transaction, error) {
	return _Inbox.Contract.SetAllowList(&_Inbox.TransactOpts, user, val)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_Inbox *InboxTransactor) SetAllowListEnabled(opts *bind.TransactOpts, _allowListEnabled bool) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "setAllowListEnabled", _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_Inbox *InboxSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _Inbox.Contract.SetAllowListEnabled(&_Inbox.TransactOpts, _allowListEnabled)
}

// SetAllowListEnabled is a paid mutator transaction binding the contract method 0xefeadb6d.
//
// Solidity: function setAllowListEnabled(bool _allowListEnabled) returns()
func (_Inbox *InboxTransactorSession) SetAllowListEnabled(_allowListEnabled bool) (*types.Transaction, error) {
	return _Inbox.Contract.SetAllowListEnabled(&_Inbox.TransactOpts, _allowListEnabled)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_Inbox *InboxTransactor) Unpause(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "unpause")
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_Inbox *InboxSession) Unpause() (*types.Transaction, error) {
	return _Inbox.Contract.Unpause(&_Inbox.TransactOpts)
}

// Unpause is a paid mutator transaction binding the contract method 0x3f4ba83a.
//
// Solidity: function unpause() returns()
func (_Inbox *InboxTransactorSession) Unpause() (*types.Transaction, error) {
	return _Inbox.Contract.Unpause(&_Inbox.TransactOpts)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0x6e6e8a6a.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_Inbox *InboxTransactor) UnsafeCreateRetryableTicket(opts *bind.TransactOpts, to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.contract.Transact(opts, "unsafeCreateRetryableTicket", to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0x6e6e8a6a.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_Inbox *InboxSession) UnsafeCreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.UnsafeCreateRetryableTicket(&_Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// UnsafeCreateRetryableTicket is a paid mutator transaction binding the contract method 0x6e6e8a6a.
//
// Solidity: function unsafeCreateRetryableTicket(address to, uint256 l2CallValue, uint256 maxSubmissionCost, address excessFeeRefundAddress, address callValueRefundAddress, uint256 gasLimit, uint256 maxFeePerGas, bytes data) payable returns(uint256)
func (_Inbox *InboxTransactorSession) UnsafeCreateRetryableTicket(to common.Address, l2CallValue *big.Int, maxSubmissionCost *big.Int, excessFeeRefundAddress common.Address, callValueRefundAddress common.Address, gasLimit *big.Int, maxFeePerGas *big.Int, data []byte) (*types.Transaction, error) {
	return _Inbox.Contract.UnsafeCreateRetryableTicket(&_Inbox.TransactOpts, to, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, gasLimit, maxFeePerGas, data)
}

// InboxAllowListAddressSetIterator is returned from FilterAllowListAddressSet and is used to iterate over the raw logs and unpacked data for AllowListAddressSet events raised by the Inbox contract.
type InboxAllowListAddressSetIterator struct {
	Event *InboxAllowListAddressSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *InboxAllowListAddressSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(InboxAllowListAddressSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(InboxAllowListAddressSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *InboxAllowListAddressSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *InboxAllowListAddressSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// InboxAllowListAddressSet represents a AllowListAddressSet event raised by the Inbox contract.
type InboxAllowListAddressSet struct {
	User common.Address
	Val  bool
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterAllowListAddressSet is a free log retrieval operation binding the contract event 0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a.
//
// Solidity: event AllowListAddressSet(address indexed user, bool val)
func (_Inbox *InboxFilterer) FilterAllowListAddressSet(opts *bind.FilterOpts, user []common.Address) (*InboxAllowListAddressSetIterator, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	logs, sub, err := _Inbox.contract.FilterLogs(opts, "AllowListAddressSet", userRule)
	if err != nil {
		return nil, err
	}
	return &InboxAllowListAddressSetIterator{contract: _Inbox.contract, event: "AllowListAddressSet", logs: logs, sub: sub}, nil
}

// WatchAllowListAddressSet is a free log subscription operation binding the contract event 0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a.
//
// Solidity: event AllowListAddressSet(address indexed user, bool val)
func (_Inbox *InboxFilterer) WatchAllowListAddressSet(opts *bind.WatchOpts, sink chan<- *InboxAllowListAddressSet, user []common.Address) (event.Subscription, error) {

	var userRule []interface{}
	for _, userItem := range user {
		userRule = append(userRule, userItem)
	}

	logs, sub, err := _Inbox.contract.WatchLogs(opts, "AllowListAddressSet", userRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(InboxAllowListAddressSet)
				if err := _Inbox.contract.UnpackLog(event, "AllowListAddressSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAllowListAddressSet is a log parse operation binding the contract event 0xd9739f45a01ce092c5cdb3d68f63d63d21676b1c6c0b4f9cbc6be4cf5449595a.
//
// Solidity: event AllowListAddressSet(address indexed user, bool val)
func (_Inbox *InboxFilterer) ParseAllowListAddressSet(log types.Log) (*InboxAllowListAddressSet, error) {
	event := new(InboxAllowListAddressSet)
	if err := _Inbox.contract.UnpackLog(event, "AllowListAddressSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// InboxAllowListEnabledUpdatedIterator is returned from FilterAllowListEnabledUpdated and is used to iterate over the raw logs and unpacked data for AllowListEnabledUpdated events raised by the Inbox contract.
type InboxAllowListEnabledUpdatedIterator struct {
	Event *InboxAllowListEnabledUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *InboxAllowListEnabledUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(InboxAllowListEnabledUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(InboxAllowListEnabledUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *InboxAllowListEnabledUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *InboxAllowListEnabledUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// InboxAllowListEnabledUpdated represents a AllowListEnabledUpdated event raised by the Inbox contract.
type InboxAllowListEnabledUpdated struct {
	IsEnabled bool
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterAllowListEnabledUpdated is a free log retrieval operation binding the contract event 0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3.
//
// Solidity: event AllowListEnabledUpdated(bool isEnabled)
func (_Inbox *InboxFilterer) FilterAllowListEnabledUpdated(opts *bind.FilterOpts) (*InboxAllowListEnabledUpdatedIterator, error) {

	logs, sub, err := _Inbox.contract.FilterLogs(opts, "AllowListEnabledUpdated")
	if err != nil {
		return nil, err
	}
	return &InboxAllowListEnabledUpdatedIterator{contract: _Inbox.contract, event: "AllowListEnabledUpdated", logs: logs, sub: sub}, nil
}

// WatchAllowListEnabledUpdated is a free log subscription operation binding the contract event 0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3.
//
// Solidity: event AllowListEnabledUpdated(bool isEnabled)
func (_Inbox *InboxFilterer) WatchAllowListEnabledUpdated(opts *bind.WatchOpts, sink chan<- *InboxAllowListEnabledUpdated) (event.Subscription, error) {

	logs, sub, err := _Inbox.contract.WatchLogs(opts, "AllowListEnabledUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(InboxAllowListEnabledUpdated)
				if err := _Inbox.contract.UnpackLog(event, "AllowListEnabledUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAllowListEnabledUpdated is a log parse operation binding the contract event 0x16435b45f7482047f839a6a19d291442627200f52cad2803c595150d0d440eb3.
//
// Solidity: event AllowListEnabledUpdated(bool isEnabled)
func (_Inbox *InboxFilterer) ParseAllowListEnabledUpdated(log types.Log) (*InboxAllowListEnabledUpdated, error) {
	event := new(InboxAllowListEnabledUpdated)
	if err := _Inbox.contract.UnpackLog(event, "AllowListEnabledUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// InboxInboxMessageDeliveredIterator is returned from FilterInboxMessageDelivered and is used to iterate over the raw logs and unpacked data for InboxMessageDelivered events raised by the Inbox contract.
type InboxInboxMessageDeliveredIterator struct {
	Event *InboxInboxMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *InboxInboxMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(InboxInboxMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(InboxInboxMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *InboxInboxMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *InboxInboxMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// InboxInboxMessageDelivered represents a InboxMessageDelivered event raised by the Inbox contract.
type InboxInboxMessageDelivered struct {
	MessageNum *big.Int
	Data       []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDelivered is a free log retrieval operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_Inbox *InboxFilterer) FilterInboxMessageDelivered(opts *bind.FilterOpts, messageNum []*big.Int) (*InboxInboxMessageDeliveredIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _Inbox.contract.FilterLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &InboxInboxMessageDeliveredIterator{contract: _Inbox.contract, event: "InboxMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDelivered is a free log subscription operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_Inbox *InboxFilterer) WatchInboxMessageDelivered(opts *bind.WatchOpts, sink chan<- *InboxInboxMessageDelivered, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _Inbox.contract.WatchLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(InboxInboxMessageDelivered)
				if err := _Inbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDelivered is a log parse operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_Inbox *InboxFilterer) ParseInboxMessageDelivered(log types.Log) (*InboxInboxMessageDelivered, error) {
	event := new(InboxInboxMessageDelivered)
	if err := _Inbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// InboxInboxMessageDeliveredFromOriginIterator is returned from FilterInboxMessageDeliveredFromOrigin and is used to iterate over the raw logs and unpacked data for InboxMessageDeliveredFromOrigin events raised by the Inbox contract.
type InboxInboxMessageDeliveredFromOriginIterator struct {
	Event *InboxInboxMessageDeliveredFromOrigin // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *InboxInboxMessageDeliveredFromOriginIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(InboxInboxMessageDeliveredFromOrigin)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(InboxInboxMessageDeliveredFromOrigin)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *InboxInboxMessageDeliveredFromOriginIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *InboxInboxMessageDeliveredFromOriginIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// InboxInboxMessageDeliveredFromOrigin represents a InboxMessageDeliveredFromOrigin event raised by the Inbox contract.
type InboxInboxMessageDeliveredFromOrigin struct {
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDeliveredFromOrigin is a free log retrieval operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_Inbox *InboxFilterer) FilterInboxMessageDeliveredFromOrigin(opts *bind.FilterOpts, messageNum []*big.Int) (*InboxInboxMessageDeliveredFromOriginIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _Inbox.contract.FilterLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &InboxInboxMessageDeliveredFromOriginIterator{contract: _Inbox.contract, event: "InboxMessageDeliveredFromOrigin", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDeliveredFromOrigin is a free log subscription operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_Inbox *InboxFilterer) WatchInboxMessageDeliveredFromOrigin(opts *bind.WatchOpts, sink chan<- *InboxInboxMessageDeliveredFromOrigin, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _Inbox.contract.WatchLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(InboxInboxMessageDeliveredFromOrigin)
				if err := _Inbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDeliveredFromOrigin is a log parse operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_Inbox *InboxFilterer) ParseInboxMessageDeliveredFromOrigin(log types.Log) (*InboxInboxMessageDeliveredFromOrigin, error) {
	event := new(InboxInboxMessageDeliveredFromOrigin)
	if err := _Inbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// InboxInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the Inbox contract.
type InboxInitializedIterator struct {
	Event *InboxInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *InboxInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(InboxInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(InboxInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *InboxInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *InboxInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// InboxInitialized represents a Initialized event raised by the Inbox contract.
type InboxInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Inbox *InboxFilterer) FilterInitialized(opts *bind.FilterOpts) (*InboxInitializedIterator, error) {

	logs, sub, err := _Inbox.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &InboxInitializedIterator{contract: _Inbox.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Inbox *InboxFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *InboxInitialized) (event.Subscription, error) {

	logs, sub, err := _Inbox.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(InboxInitialized)
				if err := _Inbox.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Inbox *InboxFilterer) ParseInitialized(log types.Log) (*InboxInitialized, error) {
	event := new(InboxInitialized)
	if err := _Inbox.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// InboxPausedIterator is returned from FilterPaused and is used to iterate over the raw logs and unpacked data for Paused events raised by the Inbox contract.
type InboxPausedIterator struct {
	Event *InboxPaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *InboxPausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(InboxPaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(InboxPaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *InboxPausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *InboxPausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// InboxPaused represents a Paused event raised by the Inbox contract.
type InboxPaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterPaused is a free log retrieval operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Inbox *InboxFilterer) FilterPaused(opts *bind.FilterOpts) (*InboxPausedIterator, error) {

	logs, sub, err := _Inbox.contract.FilterLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return &InboxPausedIterator{contract: _Inbox.contract, event: "Paused", logs: logs, sub: sub}, nil
}

// WatchPaused is a free log subscription operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Inbox *InboxFilterer) WatchPaused(opts *bind.WatchOpts, sink chan<- *InboxPaused) (event.Subscription, error) {

	logs, sub, err := _Inbox.contract.WatchLogs(opts, "Paused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(InboxPaused)
				if err := _Inbox.contract.UnpackLog(event, "Paused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParsePaused is a log parse operation binding the contract event 0x62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a258.
//
// Solidity: event Paused(address account)
func (_Inbox *InboxFilterer) ParsePaused(log types.Log) (*InboxPaused, error) {
	event := new(InboxPaused)
	if err := _Inbox.contract.UnpackLog(event, "Paused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// InboxUnpausedIterator is returned from FilterUnpaused and is used to iterate over the raw logs and unpacked data for Unpaused events raised by the Inbox contract.
type InboxUnpausedIterator struct {
	Event *InboxUnpaused // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *InboxUnpausedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(InboxUnpaused)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(InboxUnpaused)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *InboxUnpausedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *InboxUnpausedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// InboxUnpaused represents a Unpaused event raised by the Inbox contract.
type InboxUnpaused struct {
	Account common.Address
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterUnpaused is a free log retrieval operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Inbox *InboxFilterer) FilterUnpaused(opts *bind.FilterOpts) (*InboxUnpausedIterator, error) {

	logs, sub, err := _Inbox.contract.FilterLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return &InboxUnpausedIterator{contract: _Inbox.contract, event: "Unpaused", logs: logs, sub: sub}, nil
}

// WatchUnpaused is a free log subscription operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Inbox *InboxFilterer) WatchUnpaused(opts *bind.WatchOpts, sink chan<- *InboxUnpaused) (event.Subscription, error) {

	logs, sub, err := _Inbox.contract.WatchLogs(opts, "Unpaused")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(InboxUnpaused)
				if err := _Inbox.contract.UnpackLog(event, "Unpaused", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnpaused is a log parse operation binding the contract event 0x5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa.
//
// Solidity: event Unpaused(address account)
func (_Inbox *InboxFilterer) ParseUnpaused(log types.Log) (*InboxUnpaused, error) {
	event := new(InboxUnpaused)
	if err := _Inbox.contract.UnpackLog(event, "Unpaused", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MessagesMetaData contains all meta data concerning the Messages contract.
var MessagesMetaData = &bind.MetaData{
	ABI: "[]",
	Bin: "0x60808060405234601757603a9081601d823930815050f35b600080fdfe600080fdfea2646970667358221220d11fb3c40ddfb23f9fc6f26b2424649561d80e5d1fd2a24b6cdb5f10876f8c9464736f6c63430008130033",
}

// MessagesABI is the input ABI used to generate the binding from.
// Deprecated: Use MessagesMetaData.ABI instead.
var MessagesABI = MessagesMetaData.ABI

// MessagesBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MessagesMetaData.Bin instead.
var MessagesBin = MessagesMetaData.Bin

// DeployMessages deploys a new Ethereum contract, binding an instance of Messages to it.
func DeployMessages(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Messages, error) {
	parsed, err := MessagesMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MessagesBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Messages{MessagesCaller: MessagesCaller{contract: contract}, MessagesTransactor: MessagesTransactor{contract: contract}, MessagesFilterer: MessagesFilterer{contract: contract}}, nil
}

// Messages is an auto generated Go binding around an Ethereum contract.
type Messages struct {
	MessagesCaller     // Read-only binding to the contract
	MessagesTransactor // Write-only binding to the contract
	MessagesFilterer   // Log filterer for contract events
}

// MessagesCaller is an auto generated read-only Go binding around an Ethereum contract.
type MessagesCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessagesTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MessagesTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessagesFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MessagesFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MessagesSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MessagesSession struct {
	Contract     *Messages         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MessagesCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MessagesCallerSession struct {
	Contract *MessagesCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// MessagesTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MessagesTransactorSession struct {
	Contract     *MessagesTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// MessagesRaw is an auto generated low-level Go binding around an Ethereum contract.
type MessagesRaw struct {
	Contract *Messages // Generic contract binding to access the raw methods on
}

// MessagesCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MessagesCallerRaw struct {
	Contract *MessagesCaller // Generic read-only contract binding to access the raw methods on
}

// MessagesTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MessagesTransactorRaw struct {
	Contract *MessagesTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMessages creates a new instance of Messages, bound to a specific deployed contract.
func NewMessages(address common.Address, backend bind.ContractBackend) (*Messages, error) {
	contract, err := bindMessages(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Messages{MessagesCaller: MessagesCaller{contract: contract}, MessagesTransactor: MessagesTransactor{contract: contract}, MessagesFilterer: MessagesFilterer{contract: contract}}, nil
}

// NewMessagesCaller creates a new read-only instance of Messages, bound to a specific deployed contract.
func NewMessagesCaller(address common.Address, caller bind.ContractCaller) (*MessagesCaller, error) {
	contract, err := bindMessages(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MessagesCaller{contract: contract}, nil
}

// NewMessagesTransactor creates a new write-only instance of Messages, bound to a specific deployed contract.
func NewMessagesTransactor(address common.Address, transactor bind.ContractTransactor) (*MessagesTransactor, error) {
	contract, err := bindMessages(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MessagesTransactor{contract: contract}, nil
}

// NewMessagesFilterer creates a new log filterer instance of Messages, bound to a specific deployed contract.
func NewMessagesFilterer(address common.Address, filterer bind.ContractFilterer) (*MessagesFilterer, error) {
	contract, err := bindMessages(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MessagesFilterer{contract: contract}, nil
}

// bindMessages binds a generic wrapper to an already deployed contract.
func bindMessages(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MessagesMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Messages *MessagesRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Messages.Contract.MessagesCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Messages *MessagesRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Messages.Contract.MessagesTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Messages *MessagesRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Messages.Contract.MessagesTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Messages *MessagesCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Messages.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Messages *MessagesTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Messages.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Messages *MessagesTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Messages.Contract.contract.Transact(opts, method, params...)
}

// OutboxMetaData contains all meta data concerning the Outbox contract.
var OutboxMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[],\"name\":\"AlreadyInit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"AlreadySpent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadPostUpgradeInit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BridgeCallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HadZeroInit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxProofLength\",\"type\":\"uint256\"}],\"name\":\"MerkleProofTooLong\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rollup\",\"type\":\"address\"}],\"name\":\"NotRollup\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxIndex\",\"type\":\"uint256\"}],\"name\":\"PathNotMinimal\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"proofLength\",\"type\":\"uint256\"}],\"name\":\"ProofTooLong\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RollupNotChanged\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SimulationOnlyEntrypoint\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"UnknownRoot\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"zero\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"transactionIndex\",\"type\":\"uint256\"}],\"name\":\"OutBoxTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"outputRoot\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"l2BlockHash\",\"type\":\"bytes32\"}],\"name\":\"SendRootUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OUTBOX_VERSION\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"calculateItemHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"path\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"item\",\"type\":\"bytes32\"}],\"name\":\"calculateMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"l2Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l1Block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"l2Timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeTransactionSimulation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"_bridge\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isSpent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1BatchNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Block\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1EthBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1OutputId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Sender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2ToL1Timestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"postUpgradeInit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"roots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spent\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"l2BlockHash\",\"type\":\"bytes32\"}],\"name\":\"updateSendRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x60a0806040523461002a57306080526111829081610030823960805181818161065901526108a50152f35b600080fdfe6080604052600436101561001257600080fd5b60003560e01c80627436d31461015657806308635a9514610151578063119852711461014c578063288e5b101461014757806346547790146101425780635a129efe1461013d5780636ae71f121461013857806372f2a8c71461013357806380648b021461012e5780638515bc6a1461012957806395fcea78146101245780639f0c04bf1461011f578063a04cee601461011a578063ae6dead714610115578063b0f3053714610110578063c4d66de81461010b578063c75184df14610106578063cb23bcb514610101578063d5b5cc23146100fc5763e78cea92146100f757600080fd5b610a4c565b610a20565b6109f7565b6109db565b61087a565b61085f565b610833565b6107b1565b61074a565b610639565b61061e565b6105f1565b6105d6565b610466565b610437565b61041c565b61039f565b610383565b6102ec565b610239565b634e487b7160e01b600052604160045260246000fd5b60c081019081106001600160401b0382111761018c57604052565b61015b565b604081019081106001600160401b0382111761018c57604052565b601f909101601f19168101906001600160401b0382119082101761018c57604052565b604051906101dc82610171565b565b9092916001600160401b03841161018c578360051b6040519260208094610207828501826101ac565b809781520191810192831161023457905b8282106102255750505050565b81358152908301908301610218565b600080fd5b34610234576060366003190112610234576004356001600160401b03811161023457366023820112156102345761028c61027f60209236906024816004013591016101de565b604435906024359061107c565b604051908152f35b6001600160a01b0381160361023457565b604435906101dc82610294565b606435906101dc82610294565b9181601f84011215610234578235916001600160401b038311610234576020838186019501011161023457565b3461023457610120366003190112610234576001600160401b036004358181116102345736602382011215610234578060040135828111610234573660248260051b840101116102345761033e6102a5565b6103466102b2565b9061010435948511610234576103636103819536906004016102bf565b94909360e4359360c4359360a4359360843593602480359201610c04565b005b3461023457600036600319011261023457602060405160008152f35b3461023457610100366003190112610234576024356103bd81610294565b6044356103c981610294565b60e4356001600160401b038111610234576103e89036906004016102bf565b913361040a576103819360c4359160a435916084359160643591600435610d73565b604051630e13b69d60e01b8152600490fd5b3461023457600036600319011261023457602061028c610baf565b346102345760203660031901126102345760206001610457600435610e7f565b604051911c9092161515825250f35b34610234576000806003193601126105d3578054604051638da5cb5b60e01b8082526001600160a01b039283169291602091908281600481885afa801561055257849187916105b6575b50163303610557575060015460049082906104db906001600160a01b03165b6001600160a01b031690565b60405163cb23bcb560e01b815292839182905afa918215610552578592610525575b5050168091146105135761051090610ad6565b80f35b60405163d054909f60e01b8152600490fd5b6105449250803d1061054b575b61053c81836101ac565b810190610b53565b38806104fd565b503d610532565b610b6b565b8193925060046040518094819382525afa918215610552576105959392610599575b5050604051631194af8760e11b81529182913360048401610b77565b0390fd5b6105af9250803d1061054b5761053c81836101ac565b3880610579565b6105cd9150843d861161054b5761053c81836101ac565b386104b0565b80fd5b3461023457600036600319011261023457602061028c610bf5565b3461023457600036600319011261023457602061060c610b91565b6040516001600160a01b039091168152f35b3461023457600036600319011261023457602061028c610bc7565b34610234576000806003193601126105d3576001600160a01b03610681307f000000000000000000000000000000000000000000000000000000000000000083161415610a75565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d610354908116330361072c57506004546001600160801b03166002600160801b03190161071a576105106040516106d681610171565b6001600160801b0381526001600160801b03602082015260001960408201526001600160a01b0360608201526001600160601b0360808201528260a0820152610af8565b60405163d0afb66160e01b8152600490fd5b604051631194af8760e11b8152908190610595903360048401610b77565b346102345760e03660031901126102345760043561076781610294565b60243561077381610294565b60c435906001600160401b0382116102345760209261079961028c9336906004016102bf565b92909160a43591608435916064359160443591611014565b34610234576040366003190112610234576000805460243590600435906001600160a01b031633819003610815575080835260036020528160408420557fb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f67488380a380f35b604051630e4cf1bf60e21b8152908190610595903360048401610b77565b346102345760203660031901126102345760043560005260036020526020604060002054604051908152f35b3461023457600036600319011261023457602061028c610bde565b346102345760203660031901126102345760043561089781610294565b6001600160a01b036108cd307f000000000000000000000000000000000000000000000000000000000000000083161415610a75565b8082169182156109c9576001546108ee906104cf906001600160a01b031681565b6109b75760049261096c60209261094a6109066101cf565b6001600160801b0381526001600160801b038187015260001960408201526001600160a01b0360608201526001600160601b036080820152600060a0820152610af8565b600180546001600160a01b0319166001600160a01b0392909216919091179055565b60405163cb23bcb560e01b815293849182905afa80156105525761038192600091610999575b5016610ad6565b6109b1915060203d811161054b5761053c81836101ac565b38610992565b604051633bcd329760e21b8152600490fd5b604051631ad0f74360e01b8152600490fd5b3461023457600036600319011261023457602060405160028152f35b34610234576000366003190112610234576000546040516001600160a01b039091168152602090f35b346102345760203660031901126102345760043560005260026020526020604060002054604051908152f35b34610234576000366003190112610234576001546040516001600160a01b039091168152602090f35b15610a7c57565b60405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201526b19195b1959d85d1958d85b1b60a21b6064820152608490fd5b600080546001600160a01b0319166001600160a01b0392909216919091179055565b805160208201516001600160801b039091166001600160801b0319608092831b161760045560408201516005556060820151908201516001600160a01b039091166001600160a01b031960a092831b16176006550151600755565b908160209103126102345751610b6881610294565b90565b6040513d6000823e3d90fd5b6001600160a01b0391821681529116602082015260400190565b6006546001600160a01b03908116908114610ba95790565b50600090565b6004546001600160801b03908116908114610ba95790565b60065460a01c6001600160601b038114610ba95790565b60045460801c6001600160801b038114610ba95790565b6005546000198114610ba95790565b610c2b909b9a99989796959493929b610c238b8b8b8b8b8b8b8b611014565b9236916101de565b8051610100811015610d07575080610c448d9251610e9d565b821015610cde5790610c56929161107c565b610c6a816000526003602052604060002090565b5415610cc45750610c7a8a610e7f565b9b919060018d821c16610cab576101dc9b9c6001610ca5921b17916000526002602052604060002090565b55610d73565b604051639715b8d360e01b815260048101849052602490fd5b6040516310e61af960e31b81526004810191909152602490fd5b610ce89051610e9d565b604051630b8a724b60e01b815260048101929092526024820152604490fd5b60405163ab6a068360e01b81526004810191909152602490fd5b6001600160401b03811161018c57601f01601f191660200190565b929192610d4882610d21565b91610d5660405193846101ac565b829481845281830111610234578281602093846000960137010152565b979391969497604051818152600160a01b6001900390818416828b167f20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab189646020600094a460405199610dc38b610171565b6004546001600160801b038082168d5260809190911c60208d015260055460408d01526006549283166001600160a01b031660608d01529160a01c60808c015260075460a08c015281610e146101cf565b96166001600160801b03168652166001600160801b0316602085015260408401526001600160a01b031660608301526001600160601b03166080820152600060a0820152610e6190610af8565b3690610e6c92610d3c565b90610e7692610f54565b6101dc90610af8565b9060ff82049081600052600260205260ff6040600020549293069190565b60ff8111610eac576001901b90565b634e487b7160e01b600052601160045260246000fd5b60005b838110610ed55750506000910152565b8181015183820152602001610ec5565b9190604083820312610234578251801515810361023457602084015190936001600160401b038211610234570181601f82011215610234578051610f2881610d21565b92610f3660405194856101ac565b8184526020828401011161023457610b689160208085019101610ec2565b9060009160018060a01b0383608482600154169360405197889687958693639e5d4c4960e01b8552166004840152602483015260606044830152610fa78151809281606486015260208686019101610ec2565b601f01601f191681010301925af1908115610552576000908192610ff0575b5015610fcf5750565b805115610fde57805190602001fd5b604051631bb7daad60e11b8152600490fd5b9061100d92503d8091833e61100581836101ac565b810190610ee5565b9038610fc6565b92956110769560c895899498999399604051998a97602089019c8d60018060601b0319809360601b16905260601b16603489015260488801526068870152608886015260a88501528484013781016000838201520360a88101845201826101ac565b51902090565b91604080519160209283810191825283815261109781610191565b51902091845192610100808511611105575094939291906000945b8386106110c25750505050505090565b9091929394956110d28783611122565b5160019182891b88166110f557600052835283600020965b0194939291906110b2565b90600052835283600020966110ea565b84604491855191637ed6198f60e11b835260048301526024820152fd5b80518210156111365760209160051b010190565b634e487b7160e01b600052603260045260246000fdfea264697066735822122039c2fed4499dc2e991c1eb31cab15f847b8e80e5264a3331cabd06fe8a13f56564736f6c63430008130033",
}

// OutboxABI is the input ABI used to generate the binding from.
// Deprecated: Use OutboxMetaData.ABI instead.
var OutboxABI = OutboxMetaData.ABI

// OutboxBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use OutboxMetaData.Bin instead.
var OutboxBin = OutboxMetaData.Bin

// DeployOutbox deploys a new Ethereum contract, binding an instance of Outbox to it.
func DeployOutbox(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Outbox, error) {
	parsed, err := OutboxMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(OutboxBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Outbox{OutboxCaller: OutboxCaller{contract: contract}, OutboxTransactor: OutboxTransactor{contract: contract}, OutboxFilterer: OutboxFilterer{contract: contract}}, nil
}

// Outbox is an auto generated Go binding around an Ethereum contract.
type Outbox struct {
	OutboxCaller     // Read-only binding to the contract
	OutboxTransactor // Write-only binding to the contract
	OutboxFilterer   // Log filterer for contract events
}

// OutboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type OutboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OutboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OutboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OutboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OutboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OutboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OutboxSession struct {
	Contract     *Outbox           // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OutboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OutboxCallerSession struct {
	Contract *OutboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// OutboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OutboxTransactorSession struct {
	Contract     *OutboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OutboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type OutboxRaw struct {
	Contract *Outbox // Generic contract binding to access the raw methods on
}

// OutboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OutboxCallerRaw struct {
	Contract *OutboxCaller // Generic read-only contract binding to access the raw methods on
}

// OutboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OutboxTransactorRaw struct {
	Contract *OutboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOutbox creates a new instance of Outbox, bound to a specific deployed contract.
func NewOutbox(address common.Address, backend bind.ContractBackend) (*Outbox, error) {
	contract, err := bindOutbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Outbox{OutboxCaller: OutboxCaller{contract: contract}, OutboxTransactor: OutboxTransactor{contract: contract}, OutboxFilterer: OutboxFilterer{contract: contract}}, nil
}

// NewOutboxCaller creates a new read-only instance of Outbox, bound to a specific deployed contract.
func NewOutboxCaller(address common.Address, caller bind.ContractCaller) (*OutboxCaller, error) {
	contract, err := bindOutbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OutboxCaller{contract: contract}, nil
}

// NewOutboxTransactor creates a new write-only instance of Outbox, bound to a specific deployed contract.
func NewOutboxTransactor(address common.Address, transactor bind.ContractTransactor) (*OutboxTransactor, error) {
	contract, err := bindOutbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OutboxTransactor{contract: contract}, nil
}

// NewOutboxFilterer creates a new log filterer instance of Outbox, bound to a specific deployed contract.
func NewOutboxFilterer(address common.Address, filterer bind.ContractFilterer) (*OutboxFilterer, error) {
	contract, err := bindOutbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OutboxFilterer{contract: contract}, nil
}

// bindOutbox binds a generic wrapper to an already deployed contract.
func bindOutbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := OutboxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Outbox *OutboxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Outbox.Contract.OutboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Outbox *OutboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Outbox.Contract.OutboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Outbox *OutboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Outbox.Contract.OutboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Outbox *OutboxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Outbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Outbox *OutboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Outbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Outbox *OutboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Outbox.Contract.contract.Transact(opts, method, params...)
}

// OUTBOXVERSION is a free data retrieval call binding the contract method 0xc75184df.
//
// Solidity: function OUTBOX_VERSION() view returns(uint128)
func (_Outbox *OutboxCaller) OUTBOXVERSION(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "OUTBOX_VERSION")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// OUTBOXVERSION is a free data retrieval call binding the contract method 0xc75184df.
//
// Solidity: function OUTBOX_VERSION() view returns(uint128)
func (_Outbox *OutboxSession) OUTBOXVERSION() (*big.Int, error) {
	return _Outbox.Contract.OUTBOXVERSION(&_Outbox.CallOpts)
}

// OUTBOXVERSION is a free data retrieval call binding the contract method 0xc75184df.
//
// Solidity: function OUTBOX_VERSION() view returns(uint128)
func (_Outbox *OutboxCallerSession) OUTBOXVERSION() (*big.Int, error) {
	return _Outbox.Contract.OUTBOXVERSION(&_Outbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_Outbox *OutboxCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_Outbox *OutboxSession) Bridge() (common.Address, error) {
	return _Outbox.Contract.Bridge(&_Outbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_Outbox *OutboxCallerSession) Bridge() (common.Address, error) {
	return _Outbox.Contract.Bridge(&_Outbox.CallOpts)
}

// CalculateItemHash is a free data retrieval call binding the contract method 0x9f0c04bf.
//
// Solidity: function calculateItemHash(address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) pure returns(bytes32)
func (_Outbox *OutboxCaller) CalculateItemHash(opts *bind.CallOpts, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) ([32]byte, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "calculateItemHash", l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CalculateItemHash is a free data retrieval call binding the contract method 0x9f0c04bf.
//
// Solidity: function calculateItemHash(address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) pure returns(bytes32)
func (_Outbox *OutboxSession) CalculateItemHash(l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) ([32]byte, error) {
	return _Outbox.Contract.CalculateItemHash(&_Outbox.CallOpts, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// CalculateItemHash is a free data retrieval call binding the contract method 0x9f0c04bf.
//
// Solidity: function calculateItemHash(address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) pure returns(bytes32)
func (_Outbox *OutboxCallerSession) CalculateItemHash(l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) ([32]byte, error) {
	return _Outbox.Contract.CalculateItemHash(&_Outbox.CallOpts, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// CalculateMerkleRoot is a free data retrieval call binding the contract method 0x007436d3.
//
// Solidity: function calculateMerkleRoot(bytes32[] proof, uint256 path, bytes32 item) pure returns(bytes32)
func (_Outbox *OutboxCaller) CalculateMerkleRoot(opts *bind.CallOpts, proof [][32]byte, path *big.Int, item [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "calculateMerkleRoot", proof, path, item)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// CalculateMerkleRoot is a free data retrieval call binding the contract method 0x007436d3.
//
// Solidity: function calculateMerkleRoot(bytes32[] proof, uint256 path, bytes32 item) pure returns(bytes32)
func (_Outbox *OutboxSession) CalculateMerkleRoot(proof [][32]byte, path *big.Int, item [32]byte) ([32]byte, error) {
	return _Outbox.Contract.CalculateMerkleRoot(&_Outbox.CallOpts, proof, path, item)
}

// CalculateMerkleRoot is a free data retrieval call binding the contract method 0x007436d3.
//
// Solidity: function calculateMerkleRoot(bytes32[] proof, uint256 path, bytes32 item) pure returns(bytes32)
func (_Outbox *OutboxCallerSession) CalculateMerkleRoot(proof [][32]byte, path *big.Int, item [32]byte) ([32]byte, error) {
	return _Outbox.Contract.CalculateMerkleRoot(&_Outbox.CallOpts, proof, path, item)
}

// IsSpent is a free data retrieval call binding the contract method 0x5a129efe.
//
// Solidity: function isSpent(uint256 index) view returns(bool)
func (_Outbox *OutboxCaller) IsSpent(opts *bind.CallOpts, index *big.Int) (bool, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "isSpent", index)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSpent is a free data retrieval call binding the contract method 0x5a129efe.
//
// Solidity: function isSpent(uint256 index) view returns(bool)
func (_Outbox *OutboxSession) IsSpent(index *big.Int) (bool, error) {
	return _Outbox.Contract.IsSpent(&_Outbox.CallOpts, index)
}

// IsSpent is a free data retrieval call binding the contract method 0x5a129efe.
//
// Solidity: function isSpent(uint256 index) view returns(bool)
func (_Outbox *OutboxCallerSession) IsSpent(index *big.Int) (bool, error) {
	return _Outbox.Contract.IsSpent(&_Outbox.CallOpts, index)
}

// L2ToL1BatchNum is a free data retrieval call binding the contract method 0x11985271.
//
// Solidity: function l2ToL1BatchNum() pure returns(uint256)
func (_Outbox *OutboxCaller) L2ToL1BatchNum(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "l2ToL1BatchNum")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1BatchNum is a free data retrieval call binding the contract method 0x11985271.
//
// Solidity: function l2ToL1BatchNum() pure returns(uint256)
func (_Outbox *OutboxSession) L2ToL1BatchNum() (*big.Int, error) {
	return _Outbox.Contract.L2ToL1BatchNum(&_Outbox.CallOpts)
}

// L2ToL1BatchNum is a free data retrieval call binding the contract method 0x11985271.
//
// Solidity: function l2ToL1BatchNum() pure returns(uint256)
func (_Outbox *OutboxCallerSession) L2ToL1BatchNum() (*big.Int, error) {
	return _Outbox.Contract.L2ToL1BatchNum(&_Outbox.CallOpts)
}

// L2ToL1Block is a free data retrieval call binding the contract method 0x46547790.
//
// Solidity: function l2ToL1Block() view returns(uint256)
func (_Outbox *OutboxCaller) L2ToL1Block(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "l2ToL1Block")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1Block is a free data retrieval call binding the contract method 0x46547790.
//
// Solidity: function l2ToL1Block() view returns(uint256)
func (_Outbox *OutboxSession) L2ToL1Block() (*big.Int, error) {
	return _Outbox.Contract.L2ToL1Block(&_Outbox.CallOpts)
}

// L2ToL1Block is a free data retrieval call binding the contract method 0x46547790.
//
// Solidity: function l2ToL1Block() view returns(uint256)
func (_Outbox *OutboxCallerSession) L2ToL1Block() (*big.Int, error) {
	return _Outbox.Contract.L2ToL1Block(&_Outbox.CallOpts)
}

// L2ToL1EthBlock is a free data retrieval call binding the contract method 0x8515bc6a.
//
// Solidity: function l2ToL1EthBlock() view returns(uint256)
func (_Outbox *OutboxCaller) L2ToL1EthBlock(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "l2ToL1EthBlock")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1EthBlock is a free data retrieval call binding the contract method 0x8515bc6a.
//
// Solidity: function l2ToL1EthBlock() view returns(uint256)
func (_Outbox *OutboxSession) L2ToL1EthBlock() (*big.Int, error) {
	return _Outbox.Contract.L2ToL1EthBlock(&_Outbox.CallOpts)
}

// L2ToL1EthBlock is a free data retrieval call binding the contract method 0x8515bc6a.
//
// Solidity: function l2ToL1EthBlock() view returns(uint256)
func (_Outbox *OutboxCallerSession) L2ToL1EthBlock() (*big.Int, error) {
	return _Outbox.Contract.L2ToL1EthBlock(&_Outbox.CallOpts)
}

// L2ToL1OutputId is a free data retrieval call binding the contract method 0x72f2a8c7.
//
// Solidity: function l2ToL1OutputId() view returns(bytes32)
func (_Outbox *OutboxCaller) L2ToL1OutputId(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "l2ToL1OutputId")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// L2ToL1OutputId is a free data retrieval call binding the contract method 0x72f2a8c7.
//
// Solidity: function l2ToL1OutputId() view returns(bytes32)
func (_Outbox *OutboxSession) L2ToL1OutputId() ([32]byte, error) {
	return _Outbox.Contract.L2ToL1OutputId(&_Outbox.CallOpts)
}

// L2ToL1OutputId is a free data retrieval call binding the contract method 0x72f2a8c7.
//
// Solidity: function l2ToL1OutputId() view returns(bytes32)
func (_Outbox *OutboxCallerSession) L2ToL1OutputId() ([32]byte, error) {
	return _Outbox.Contract.L2ToL1OutputId(&_Outbox.CallOpts)
}

// L2ToL1Sender is a free data retrieval call binding the contract method 0x80648b02.
//
// Solidity: function l2ToL1Sender() view returns(address)
func (_Outbox *OutboxCaller) L2ToL1Sender(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "l2ToL1Sender")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// L2ToL1Sender is a free data retrieval call binding the contract method 0x80648b02.
//
// Solidity: function l2ToL1Sender() view returns(address)
func (_Outbox *OutboxSession) L2ToL1Sender() (common.Address, error) {
	return _Outbox.Contract.L2ToL1Sender(&_Outbox.CallOpts)
}

// L2ToL1Sender is a free data retrieval call binding the contract method 0x80648b02.
//
// Solidity: function l2ToL1Sender() view returns(address)
func (_Outbox *OutboxCallerSession) L2ToL1Sender() (common.Address, error) {
	return _Outbox.Contract.L2ToL1Sender(&_Outbox.CallOpts)
}

// L2ToL1Timestamp is a free data retrieval call binding the contract method 0xb0f30537.
//
// Solidity: function l2ToL1Timestamp() view returns(uint256)
func (_Outbox *OutboxCaller) L2ToL1Timestamp(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "l2ToL1Timestamp")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// L2ToL1Timestamp is a free data retrieval call binding the contract method 0xb0f30537.
//
// Solidity: function l2ToL1Timestamp() view returns(uint256)
func (_Outbox *OutboxSession) L2ToL1Timestamp() (*big.Int, error) {
	return _Outbox.Contract.L2ToL1Timestamp(&_Outbox.CallOpts)
}

// L2ToL1Timestamp is a free data retrieval call binding the contract method 0xb0f30537.
//
// Solidity: function l2ToL1Timestamp() view returns(uint256)
func (_Outbox *OutboxCallerSession) L2ToL1Timestamp() (*big.Int, error) {
	return _Outbox.Contract.L2ToL1Timestamp(&_Outbox.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_Outbox *OutboxCaller) Rollup(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "rollup")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_Outbox *OutboxSession) Rollup() (common.Address, error) {
	return _Outbox.Contract.Rollup(&_Outbox.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_Outbox *OutboxCallerSession) Rollup() (common.Address, error) {
	return _Outbox.Contract.Rollup(&_Outbox.CallOpts)
}

// Roots is a free data retrieval call binding the contract method 0xae6dead7.
//
// Solidity: function roots(bytes32 ) view returns(bytes32)
func (_Outbox *OutboxCaller) Roots(opts *bind.CallOpts, arg0 [32]byte) ([32]byte, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "roots", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Roots is a free data retrieval call binding the contract method 0xae6dead7.
//
// Solidity: function roots(bytes32 ) view returns(bytes32)
func (_Outbox *OutboxSession) Roots(arg0 [32]byte) ([32]byte, error) {
	return _Outbox.Contract.Roots(&_Outbox.CallOpts, arg0)
}

// Roots is a free data retrieval call binding the contract method 0xae6dead7.
//
// Solidity: function roots(bytes32 ) view returns(bytes32)
func (_Outbox *OutboxCallerSession) Roots(arg0 [32]byte) ([32]byte, error) {
	return _Outbox.Contract.Roots(&_Outbox.CallOpts, arg0)
}

// Spent is a free data retrieval call binding the contract method 0xd5b5cc23.
//
// Solidity: function spent(uint256 ) view returns(bytes32)
func (_Outbox *OutboxCaller) Spent(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _Outbox.contract.Call(opts, &out, "spent", arg0)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// Spent is a free data retrieval call binding the contract method 0xd5b5cc23.
//
// Solidity: function spent(uint256 ) view returns(bytes32)
func (_Outbox *OutboxSession) Spent(arg0 *big.Int) ([32]byte, error) {
	return _Outbox.Contract.Spent(&_Outbox.CallOpts, arg0)
}

// Spent is a free data retrieval call binding the contract method 0xd5b5cc23.
//
// Solidity: function spent(uint256 ) view returns(bytes32)
func (_Outbox *OutboxCallerSession) Spent(arg0 *big.Int) ([32]byte, error) {
	return _Outbox.Contract.Spent(&_Outbox.CallOpts, arg0)
}

// ExecuteTransaction is a paid mutator transaction binding the contract method 0x08635a95.
//
// Solidity: function executeTransaction(bytes32[] proof, uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_Outbox *OutboxTransactor) ExecuteTransaction(opts *bind.TransactOpts, proof [][32]byte, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Outbox.contract.Transact(opts, "executeTransaction", proof, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransaction is a paid mutator transaction binding the contract method 0x08635a95.
//
// Solidity: function executeTransaction(bytes32[] proof, uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_Outbox *OutboxSession) ExecuteTransaction(proof [][32]byte, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Outbox.Contract.ExecuteTransaction(&_Outbox.TransactOpts, proof, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransaction is a paid mutator transaction binding the contract method 0x08635a95.
//
// Solidity: function executeTransaction(bytes32[] proof, uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_Outbox *OutboxTransactorSession) ExecuteTransaction(proof [][32]byte, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Outbox.Contract.ExecuteTransaction(&_Outbox.TransactOpts, proof, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransactionSimulation is a paid mutator transaction binding the contract method 0x288e5b10.
//
// Solidity: function executeTransactionSimulation(uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_Outbox *OutboxTransactor) ExecuteTransactionSimulation(opts *bind.TransactOpts, index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Outbox.contract.Transact(opts, "executeTransactionSimulation", index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransactionSimulation is a paid mutator transaction binding the contract method 0x288e5b10.
//
// Solidity: function executeTransactionSimulation(uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_Outbox *OutboxSession) ExecuteTransactionSimulation(index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Outbox.Contract.ExecuteTransactionSimulation(&_Outbox.TransactOpts, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// ExecuteTransactionSimulation is a paid mutator transaction binding the contract method 0x288e5b10.
//
// Solidity: function executeTransactionSimulation(uint256 index, address l2Sender, address to, uint256 l2Block, uint256 l1Block, uint256 l2Timestamp, uint256 value, bytes data) returns()
func (_Outbox *OutboxTransactorSession) ExecuteTransactionSimulation(index *big.Int, l2Sender common.Address, to common.Address, l2Block *big.Int, l1Block *big.Int, l2Timestamp *big.Int, value *big.Int, data []byte) (*types.Transaction, error) {
	return _Outbox.Contract.ExecuteTransactionSimulation(&_Outbox.TransactOpts, index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _bridge) returns()
func (_Outbox *OutboxTransactor) Initialize(opts *bind.TransactOpts, _bridge common.Address) (*types.Transaction, error) {
	return _Outbox.contract.Transact(opts, "initialize", _bridge)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _bridge) returns()
func (_Outbox *OutboxSession) Initialize(_bridge common.Address) (*types.Transaction, error) {
	return _Outbox.Contract.Initialize(&_Outbox.TransactOpts, _bridge)
}

// Initialize is a paid mutator transaction binding the contract method 0xc4d66de8.
//
// Solidity: function initialize(address _bridge) returns()
func (_Outbox *OutboxTransactorSession) Initialize(_bridge common.Address) (*types.Transaction, error) {
	return _Outbox.Contract.Initialize(&_Outbox.TransactOpts, _bridge)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0x95fcea78.
//
// Solidity: function postUpgradeInit() returns()
func (_Outbox *OutboxTransactor) PostUpgradeInit(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Outbox.contract.Transact(opts, "postUpgradeInit")
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0x95fcea78.
//
// Solidity: function postUpgradeInit() returns()
func (_Outbox *OutboxSession) PostUpgradeInit() (*types.Transaction, error) {
	return _Outbox.Contract.PostUpgradeInit(&_Outbox.TransactOpts)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0x95fcea78.
//
// Solidity: function postUpgradeInit() returns()
func (_Outbox *OutboxTransactorSession) PostUpgradeInit() (*types.Transaction, error) {
	return _Outbox.Contract.PostUpgradeInit(&_Outbox.TransactOpts)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_Outbox *OutboxTransactor) UpdateRollupAddress(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Outbox.contract.Transact(opts, "updateRollupAddress")
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_Outbox *OutboxSession) UpdateRollupAddress() (*types.Transaction, error) {
	return _Outbox.Contract.UpdateRollupAddress(&_Outbox.TransactOpts)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_Outbox *OutboxTransactorSession) UpdateRollupAddress() (*types.Transaction, error) {
	return _Outbox.Contract.UpdateRollupAddress(&_Outbox.TransactOpts)
}

// UpdateSendRoot is a paid mutator transaction binding the contract method 0xa04cee60.
//
// Solidity: function updateSendRoot(bytes32 root, bytes32 l2BlockHash) returns()
func (_Outbox *OutboxTransactor) UpdateSendRoot(opts *bind.TransactOpts, root [32]byte, l2BlockHash [32]byte) (*types.Transaction, error) {
	return _Outbox.contract.Transact(opts, "updateSendRoot", root, l2BlockHash)
}

// UpdateSendRoot is a paid mutator transaction binding the contract method 0xa04cee60.
//
// Solidity: function updateSendRoot(bytes32 root, bytes32 l2BlockHash) returns()
func (_Outbox *OutboxSession) UpdateSendRoot(root [32]byte, l2BlockHash [32]byte) (*types.Transaction, error) {
	return _Outbox.Contract.UpdateSendRoot(&_Outbox.TransactOpts, root, l2BlockHash)
}

// UpdateSendRoot is a paid mutator transaction binding the contract method 0xa04cee60.
//
// Solidity: function updateSendRoot(bytes32 root, bytes32 l2BlockHash) returns()
func (_Outbox *OutboxTransactorSession) UpdateSendRoot(root [32]byte, l2BlockHash [32]byte) (*types.Transaction, error) {
	return _Outbox.Contract.UpdateSendRoot(&_Outbox.TransactOpts, root, l2BlockHash)
}

// OutboxOutBoxTransactionExecutedIterator is returned from FilterOutBoxTransactionExecuted and is used to iterate over the raw logs and unpacked data for OutBoxTransactionExecuted events raised by the Outbox contract.
type OutboxOutBoxTransactionExecutedIterator struct {
	Event *OutboxOutBoxTransactionExecuted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OutboxOutBoxTransactionExecutedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OutboxOutBoxTransactionExecuted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OutboxOutBoxTransactionExecuted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OutboxOutBoxTransactionExecutedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OutboxOutBoxTransactionExecutedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OutboxOutBoxTransactionExecuted represents a OutBoxTransactionExecuted event raised by the Outbox contract.
type OutboxOutBoxTransactionExecuted struct {
	To               common.Address
	L2Sender         common.Address
	Zero             *big.Int
	TransactionIndex *big.Int
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterOutBoxTransactionExecuted is a free log retrieval operation binding the contract event 0x20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab18964.
//
// Solidity: event OutBoxTransactionExecuted(address indexed to, address indexed l2Sender, uint256 indexed zero, uint256 transactionIndex)
func (_Outbox *OutboxFilterer) FilterOutBoxTransactionExecuted(opts *bind.FilterOpts, to []common.Address, l2Sender []common.Address, zero []*big.Int) (*OutboxOutBoxTransactionExecutedIterator, error) {

	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var l2SenderRule []interface{}
	for _, l2SenderItem := range l2Sender {
		l2SenderRule = append(l2SenderRule, l2SenderItem)
	}
	var zeroRule []interface{}
	for _, zeroItem := range zero {
		zeroRule = append(zeroRule, zeroItem)
	}

	logs, sub, err := _Outbox.contract.FilterLogs(opts, "OutBoxTransactionExecuted", toRule, l2SenderRule, zeroRule)
	if err != nil {
		return nil, err
	}
	return &OutboxOutBoxTransactionExecutedIterator{contract: _Outbox.contract, event: "OutBoxTransactionExecuted", logs: logs, sub: sub}, nil
}

// WatchOutBoxTransactionExecuted is a free log subscription operation binding the contract event 0x20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab18964.
//
// Solidity: event OutBoxTransactionExecuted(address indexed to, address indexed l2Sender, uint256 indexed zero, uint256 transactionIndex)
func (_Outbox *OutboxFilterer) WatchOutBoxTransactionExecuted(opts *bind.WatchOpts, sink chan<- *OutboxOutBoxTransactionExecuted, to []common.Address, l2Sender []common.Address, zero []*big.Int) (event.Subscription, error) {

	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var l2SenderRule []interface{}
	for _, l2SenderItem := range l2Sender {
		l2SenderRule = append(l2SenderRule, l2SenderItem)
	}
	var zeroRule []interface{}
	for _, zeroItem := range zero {
		zeroRule = append(zeroRule, zeroItem)
	}

	logs, sub, err := _Outbox.contract.WatchLogs(opts, "OutBoxTransactionExecuted", toRule, l2SenderRule, zeroRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OutboxOutBoxTransactionExecuted)
				if err := _Outbox.contract.UnpackLog(event, "OutBoxTransactionExecuted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOutBoxTransactionExecuted is a log parse operation binding the contract event 0x20af7f3bbfe38132b8900ae295cd9c8d1914be7052d061a511f3f728dab18964.
//
// Solidity: event OutBoxTransactionExecuted(address indexed to, address indexed l2Sender, uint256 indexed zero, uint256 transactionIndex)
func (_Outbox *OutboxFilterer) ParseOutBoxTransactionExecuted(log types.Log) (*OutboxOutBoxTransactionExecuted, error) {
	event := new(OutboxOutBoxTransactionExecuted)
	if err := _Outbox.contract.UnpackLog(event, "OutBoxTransactionExecuted", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// OutboxSendRootUpdatedIterator is returned from FilterSendRootUpdated and is used to iterate over the raw logs and unpacked data for SendRootUpdated events raised by the Outbox contract.
type OutboxSendRootUpdatedIterator struct {
	Event *OutboxSendRootUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *OutboxSendRootUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(OutboxSendRootUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(OutboxSendRootUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *OutboxSendRootUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *OutboxSendRootUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// OutboxSendRootUpdated represents a SendRootUpdated event raised by the Outbox contract.
type OutboxSendRootUpdated struct {
	OutputRoot  [32]byte
	L2BlockHash [32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSendRootUpdated is a free log retrieval operation binding the contract event 0xb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f6748.
//
// Solidity: event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash)
func (_Outbox *OutboxFilterer) FilterSendRootUpdated(opts *bind.FilterOpts, outputRoot [][32]byte, l2BlockHash [][32]byte) (*OutboxSendRootUpdatedIterator, error) {

	var outputRootRule []interface{}
	for _, outputRootItem := range outputRoot {
		outputRootRule = append(outputRootRule, outputRootItem)
	}
	var l2BlockHashRule []interface{}
	for _, l2BlockHashItem := range l2BlockHash {
		l2BlockHashRule = append(l2BlockHashRule, l2BlockHashItem)
	}

	logs, sub, err := _Outbox.contract.FilterLogs(opts, "SendRootUpdated", outputRootRule, l2BlockHashRule)
	if err != nil {
		return nil, err
	}
	return &OutboxSendRootUpdatedIterator{contract: _Outbox.contract, event: "SendRootUpdated", logs: logs, sub: sub}, nil
}

// WatchSendRootUpdated is a free log subscription operation binding the contract event 0xb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f6748.
//
// Solidity: event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash)
func (_Outbox *OutboxFilterer) WatchSendRootUpdated(opts *bind.WatchOpts, sink chan<- *OutboxSendRootUpdated, outputRoot [][32]byte, l2BlockHash [][32]byte) (event.Subscription, error) {

	var outputRootRule []interface{}
	for _, outputRootItem := range outputRoot {
		outputRootRule = append(outputRootRule, outputRootItem)
	}
	var l2BlockHashRule []interface{}
	for _, l2BlockHashItem := range l2BlockHash {
		l2BlockHashRule = append(l2BlockHashRule, l2BlockHashItem)
	}

	logs, sub, err := _Outbox.contract.WatchLogs(opts, "SendRootUpdated", outputRootRule, l2BlockHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(OutboxSendRootUpdated)
				if err := _Outbox.contract.UnpackLog(event, "SendRootUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSendRootUpdated is a log parse operation binding the contract event 0xb4df3847300f076a369cd76d2314b470a1194d9e8a6bb97f1860aee88a5f6748.
//
// Solidity: event SendRootUpdated(bytes32 indexed outputRoot, bytes32 indexed l2BlockHash)
func (_Outbox *OutboxFilterer) ParseSendRootUpdated(log types.Log) (*OutboxSendRootUpdated, error) {
	event := new(OutboxSendRootUpdated)
	if err := _Outbox.contract.UnpackLog(event, "SendRootUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxMetaData contains all meta data concerning the SequencerInbox contract.
var SequencerInboxMetaData = &bind.MetaData{
	ABI: "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDataSize\",\"type\":\"uint256\"},{\"internalType\":\"contractIReader4844\",\"name\":\"reader4844_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isUsingFeeToken\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isDelayBufferable\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"AlreadyValidDASKeyset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadBufferConfig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BadMaxTimeVariation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stored\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"BadSequencerNumber\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CannotSetFeeTokenPricer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DataBlobsNotSupported\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDataLength\",\"type\":\"uint256\"}],\"name\":\"DataTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DelayProofRequired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DelayedBackwards\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DelayedTooFar\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Deprecated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ExtraGasNotUint64\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ForceIncludeBlockTooSoon\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HadZeroInit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectMessagePreimage\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"InitParamZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCelestiaBatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDelayedAccPreimage\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"name\":\"InvalidHeaderFlag\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"KeysetTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MissingDataHashes\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NativeTokenMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"NoSuchKeyset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotBatchPoster\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"NotBatchPosterManager\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotCodelessOrigin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotDelayBufferable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotForked\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RollupNotChanged\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBatchPosterManager\",\"type\":\"address\"}],\"name\":\"BatchPosterManagerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"batchPoster\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBatchPoster\",\"type\":\"bool\"}],\"name\":\"BatchPosterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"threshold\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"replenishRateInBasis\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"structBufferConfig\",\"name\":\"bufferConfig\",\"type\":\"tuple\"}],\"name\":\"BufferConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeTokenPricer\",\"type\":\"address\"}],\"name\":\"FeeTokenPricerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"keysetHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidateKeyset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"structISequencerInbox.MaxTimeVariation\",\"name\":\"maxTimeVariation\",\"type\":\"tuple\"}],\"name\":\"MaxTimeVariationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OwnerFunctionCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchSequenceNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SequencerBatchData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchSequenceNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beforeAcc\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"afterAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"delayedAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"minTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minBlockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxBlockNumber\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"structIBridge.TimeBounds\",\"name\":\"timeBounds\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"enumIBridge.BatchDataLocation\",\"name\":\"dataLocation\",\"type\":\"uint8\"}],\"name\":\"SequencerBatchDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSequencer\",\"type\":\"bool\"}],\"name\":\"SequencerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"keysetHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"keysetBytes\",\"type\":\"bytes\"}],\"name\":\"SetValidKeyset\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BROTLI_MESSAGE_HEADER_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CELESTIA_MESSAGE_HEADER_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAS_MESSAGE_HEADER_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DATA_AUTHENTICATED_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DATA_BLOB_HEADER_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HEADER_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TREE_DAS_MESSAGE_HEADER_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZERO_HEAVY_MESSAGE_HEADER_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"}],\"name\":\"addSequencerL2Batch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"beforeDelayedAcc\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"inboxSeqNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"internalType\":\"structMessages.Message\",\"name\":\"delayedMessage\",\"type\":\"tuple\"}],\"internalType\":\"structDelayProof\",\"name\":\"delayProof\",\"type\":\"tuple\"}],\"name\":\"addSequencerL2BatchDelayProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"}],\"name\":\"addSequencerL2BatchFromBlobs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"beforeDelayedAcc\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"inboxSeqNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"internalType\":\"structMessages.Message\",\"name\":\"delayedMessage\",\"type\":\"tuple\"}],\"internalType\":\"structDelayProof\",\"name\":\"delayProof\",\"type\":\"tuple\"}],\"name\":\"addSequencerL2BatchFromBlobsDelayProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addSequencerL2BatchFromOrigin\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"}],\"name\":\"addSequencerL2BatchFromOrigin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contractIGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"prevMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMessageCount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"beforeDelayedAcc\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"inboxSeqNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"internalType\":\"structMessages.Message\",\"name\":\"delayedMessage\",\"type\":\"tuple\"}],\"internalType\":\"structDelayProof\",\"name\":\"delayProof\",\"type\":\"tuple\"}],\"name\":\"addSequencerL2BatchFromOriginDelayProof\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchPosterManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buffer\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"bufferBlocks\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"threshold\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"prevBlockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"replenishRateInBasis\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"prevSequencedBlockNumber\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"dasKeySetInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValidKeyset\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"creationBlock\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTokenPricer\",\"outputs\":[{\"internalType\":\"contractIFeeTokenPricer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"uint64[2]\",\"name\":\"l1BlockAndTime\",\"type\":\"uint64[2]\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"name\":\"forceInclusion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"blockNumber\",\"type\":\"uint64\"}],\"name\":\"forceInclusionDeadline\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ksHash\",\"type\":\"bytes32\"}],\"name\":\"getKeysetCreationBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"inboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIBridge\",\"name\":\"bridge_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structISequencerInbox.MaxTimeVariation\",\"name\":\"maxTimeVariation_\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"threshold\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"replenishRateInBasis\",\"type\":\"uint64\"}],\"internalType\":\"structBufferConfig\",\"name\":\"bufferConfig_\",\"type\":\"tuple\"},{\"internalType\":\"contractIFeeTokenPricer\",\"name\":\"feeTokenPricer_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ksHash\",\"type\":\"bytes32\"}],\"name\":\"invalidateKeysetHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBatchPoster\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDelayBufferable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSequencer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isUsingFeeToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ksHash\",\"type\":\"bytes32\"}],\"name\":\"isValidKeysetHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDataSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTimeVariation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"threshold\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"replenishRateInBasis\",\"type\":\"uint64\"}],\"internalType\":\"structBufferConfig\",\"name\":\"bufferConfig_\",\"type\":\"tuple\"}],\"name\":\"postUpgradeInit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reader4844\",\"outputs\":[{\"internalType\":\"contractIReader4844\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeDelayAfterFork\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"contractIOwnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBatchPosterManager\",\"type\":\"address\"}],\"name\":\"setBatchPosterManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"threshold\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"max\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"replenishRateInBasis\",\"type\":\"uint64\"}],\"internalType\":\"structBufferConfig\",\"name\":\"bufferConfig_\",\"type\":\"tuple\"}],\"name\":\"setBufferConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contractIFeeTokenPricer\",\"name\":\"feeTokenPricer_\",\"type\":\"address\"}],\"name\":\"setFeeTokenPricer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBatchPoster_\",\"type\":\"bool\"}],\"name\":\"setIsBatchPoster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isSequencer_\",\"type\":\"bool\"}],\"name\":\"setIsSequencer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"internalType\":\"structISequencerInbox.MaxTimeVariation\",\"name\":\"maxTimeVariation_\",\"type\":\"tuple\"}],\"name\":\"setMaxTimeVariation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"keysetBytes\",\"type\":\"bytes\"}],\"name\":\"setValidKeyset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDelayedMessagesRead\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateRollupAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]",
	Bin: "0x6101806040818152346200029d57608082620045848038038091620000258285620002a2565b8339810103126200029d578151602080840151909391926001600160a01b03821692918381036200029d576200006b606062000063848601620002c6565b9401620002c6565b306080526202000060a0524661010090815283516302881c7960e11b818a01908152600482529198929692916001600160401b03918087018381118282101762000287578752600080928192519060645afa913d156200027c573d90811162000268578651849291620000e8601f8201601f1916850183620002a2565b81528091833d92013e5b826200025c575b505061012081815260e098909852156200021d57506200020c575b60c05261014091825261016092835251926142af9485620002d58639608051858181610f13015261112c015260a0518561151a015260c0518581816114690152818161175b0152612cb9015260e05185818161069101528181612fb6015261338701525184818161120f0152612836015251838181610ac901528181612e5f01528181613a6c0152613d21015251828181610f7401528181611273015281816123d601528181613a400152613cf50152518181816102e0015281816108f00152818161101401528181611182015281816112e001528181611af701528181611d4101528181611df00152818161384a0152613f680152f35b81516386657a5360e01b8152600490fd5b90156200022b575062000114565b6064908351906380fc2c0360e01b82526004820152600a60248201526914995859195c8d0e0d0d60b21b6044820152fd5b511490508138620000f9565b634e487b7160e01b82526041600452602482fd5b5050816060620000f2565b634e487b7160e01b600052604160045260246000fd5b600080fd5b601f909101601f19168101906001600160401b038211908210176200028757604052565b519081151582036200029d5756fe608060408181526004918236101561001657600080fd5b600092833560e01c91826302c99275146124c057508163036f7ed31461237857816306f13056146122ea5781631637be48146122bd57816316af91a7146122a25781631f956632146121a85781631ff64790146120a057816322291e8d14612077578163258f049514611fff57816327957a4914611fe35781632cbf74e514611fc45781632f3985a714611e915781633e5aa08214611e155781634b678a6614611dd85781635fd9e56d14611db957816369cacded14611d005781636ae71f1214611bcd5781636c89045014611bae5781636d46e98714611b705781636e62005514611ac05781636e7df3e7146119a25781636f12b0c91461194f578163715ea34b1461191157816371c3e6fe146118d35781637fa3a40e146118b6578163844208601461178a5781638d910dde146117465781638f111f3c14611602578163917cf8ac1461129857816392d9f7821461125b57816396cc5c78146111f9578163a655d93714611101578163a84840b714610e72578163b31761f814610d35578163cb23bcb514610d0c578163cc2a1a0c14610ce3578163d1ce8da8146109cd578163d9dd67ab14610939578163dd44e6e0146108ba578163e0bc9729146106fc578163e5a358c8146106dd578163e78cea92146106b4578163e8eb1dc314610679578163ebea461d14610632578163edaafe20146105d8578163f19815781461024b575063f60a50911461022a57600080fd5b3461024757816003193601126102475751600160ff1b8152602090f35b5080fd5b919050346105d45760e03660031901126105d45760243590823560ff831683036105d057366084116105d0576001600160a01b039060a4359082821682036105cc5786548111156105bc5761029e61288c565b6001600160401b0395909290606435878116810361048c576000198401948486116105a9576102d8939291869160c4359460843594612a0c565b9285600a54167f0000000000000000000000000000000000000000000000000000000000000000610546575b610317908761031161288c565b166128c5565b431115610536578790600183116104a1575b6001541692855190636ab8cee160e11b8252888201526020948582602481885afa918215610497578a92610462575b506103639192612a77565b0361045257908291610373613892565b5061037d816138b7565b939081815191012092865198898092632fe5250b60e11b82525afa9182156104485786978993610409575b5060e0936103cb8460008051602061421a83398151915297958a95606095613e19565b9b9299919a90968d548351988952818901528185511683890152840151168487015282015116608085015201511660a0820152600260c0820152a480f35b858094508195969298503d8311610441575b61042581836125c5565b8101031261043d5791518695919392909160e06103a8565b8780fd5b503d61041b565b85513d8a823e3d90fd5b83516313947fd760e01b81528690fd5b91508582813d8311610490575b61047981836125c5565b8101031261048c57610363915191610358565b8980fd5b503d61046f565b87513d8c823e3d90fd5b809150600154166001198301838111610523576020906024885180948193636ab8cee160e11b83528d8301525afa9081156105195789916104e4575b5090610329565b90506020813d8211610511575b816104fe602093836125c5565b8101031261050d5751386104dd565b8880fd5b3d91506104f1565b86513d8b823e3d90fd5b634e487b7160e01b8a526011895260248afd5b845163ad3515d960e01b81528790fd5b5061058561055261288c565b61058061055e826128d2565b600c80546001600160401b0319166001600160401b0392909216919091179055565b61280f565b6105908643166127e4565b610317866105a181600c5416613f4a565b169050610304565b634e487b7160e01b8b5260118a5260248bfd5b8351633eb9f37d60e11b81528690fd5b8680fd5b8480fd5b8280fd5b505034610247578160031936011261024757600c54600d5482516001600160401b03808416825283851c81166020830152608084811c82168387015260c094851c6060840152818416908301529190931c1660a083015290f35b50503461024757816003193601126102475760809061064f612834565b84516001600160401b03948516815292841660208401529083169382019390935291166060820152f35b505034610247578160031936011261024757602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b50503461024757816003193601126102475760015490516001600160a01b039091168152602090f35b50503461024757816003193601126102475751600160fe1b8152602090f35b8284346108b75761070c366126f7565b929091939795975a95338952600360205260ff888a20541615806108a2575b6108925761073883613848565b61088257610749959697989961336a565b6001600160a01b03168061075b578380f35b3691601f830180841161086f5760051c60068102908082046006148115171561085c5760209493926107a16107f89899936107986107a794612a95565b60091c906128c5565b906128c5565b928732331480610853575b6108485790506107c581945b5a906128a2565b865163e3db8a4960e01b815233938101938452602084019190915260408301949094529295869384929091839160600190565b03925af190811561083f5750610811575b808083928380f35b6108319060203d8111610838575b61082981836125c5565b810190612bd2565b5081610809565b503d61081f565b513d84823e3d90fd5b90936107c5906107be565b50333b156107b2565b634e487b7160e01b875260118852602487fd5b634e487b7160e01b865260118752602486fd5b8751630e5da8fb60e01b81528b90fd5b8751632dd9fc9760e01b81528b90fd5b506002546001600160a01b031633141561072b565b80fd5b9050346105d45760203660031901126105d45735916001600160401b039081841684036108b7575061091860209382600a5416907f0000000000000000000000000000000000000000000000000000000000000000610920576139ed565b915191168152f35b905061093361092e826128d2565b613f4a565b906139ed565b83833461024757602092836003193601126105d45760015482516316bf557960e01b81528235928101929092528490829060249082906001600160a01b03165afa9283156109c2578093610990575b505051908152f35b909192508382813d83116109bb575b6109a981836125c5565b810103126108b7575051908380610988565b503d61099f565b8251903d90823e3d90fd5b919050346105d45760209081600319360112610cdf576001600160401b038335818111610cdb57610a019036908601612665565b6002548451638da5cb5b60e01b80825292959394926001600160a01b0392831692909188818b81875afa908115610cd1578b91610cb4575b50163303610c33575050808411610c20578151610a5f601f8601601f19168701826125c5565b84815285810190368686011161050d57858583378887878301015251902082519086820190607f60f91b8252602183015260218252610a9d82612559565b90519020600160ff1b189562010000851015610c12578688526008865260ff8389205416610bfb5743907f0000000000000000000000000000000000000000000000000000000000000000610b76575b50908291600860008051602061425a83398151915297610b5c955193610b1285612528565b6001855281850193168352898b5252610b31838a209251151583614208565b518154610100600160481b03191660089190911b610100600160481b03161790555192839283612f73565b0390a2600260008051602061423a8339815191528280a280f35b835163a3b1b31d60e01b81529150869082908160645afa908115610bf1578891610bb0575b5060008051602061425a833981519152610aed565b929190508583813d8311610bea575b610bc981836125c5565b8101031261043d57915190919060008051602061425a833981519152610b9b565b503d610bbf565b83513d8a823e3d90fd5b8251637d17eeed60e11b8152908101879052602490fd5b82516359e8fa0960e11b8152fd5b634e487b7160e01b875260418652602487fd5b83899288808b948585518095819382525afa948515610ca95794610c74575b505051631194af8760e11b8152918291610c709190339084016127ab565b0390fd5b610c709294509081610c9a92903d10610ca2575b610c9281836125c5565b8101906127c5565b929084610c52565b503d610c88565b8351903d90823e3d90fd5b610ccb9150893d8b11610ca257610c9281836125c5565b38610a39565b86513d8d823e3d90fd5b8580fd5b8380fd5b505034610247578160031936011261024757600b5490516001600160a01b039091168152602090f35b50503461024757816003193601126102475760025490516001600160a01b039091168152602090f35b9050346105d45760803660031901126105d457815191610d5483612574565b8135835260208084019060243582528285019160443583526060860194606435865260018060a01b03806002541690865190638da5cb5b60e01b9182815286818681875afa908115610e68578c91610e4b575b50163303610e0f57897faa6a58dad31128ff7ecc2b80987ee6e003df80bc50cd8d0b0d1af0e07da6d19d60808b8b8b8b8b8b610de286614155565b83519551865251908501525190830152516060820152a18060008051602061423a8339815191528180a280f35b8291858089938d9685518095819382525afa948515610ca95794610c7457505051631194af8760e11b8152918291610c709190339084016127ab565b610e629150873d8911610ca257610c9281836125c5565b38610da7565b89513d8e823e3d90fd5b919050346105d4576101203660031901126105d4576001600160a01b038235818116939192908490036105d05760803660231901126105d05760603660a31901126105d057805193610ec385612559565b6001600160401b039460a435868116810361043d57815260c43595808716870361043d576020968783015260e435908116810361043d5783820152610104359585871680970361043d57610f3b867f00000000000000000000000000000000000000000000000000000000000000001630141561274a565b600154958087166110f15783156110e1578893818651631c2eb17b60e31b815284818a81865afa8c91816110c2575b506110ac575b50507f00000000000000000000000000000000000000000000000000000000000000001594151585150361109c576001600160a01b03199788168117600155855163cb23bcb560e01b81529083908290899082905afa90811561109257906110129392918b91611075575b5016876002541617600255845190610ff282612574565b602435825260443590820152606435858201526084356060820152614155565b7f0000000000000000000000000000000000000000000000000000000000000000611066575b508061105d575b611050575050600e541617600e5580f35b5163384c48ed60e21b8152fd5b5083151561103f565b61106f90613f66565b38611038565b61108c9150833d8511610ca257610c9281836125c5565b38610fdb565b86513d8c823e3d90fd5b855163c3e31f8d60e01b81528790fd5b166110b9575b8138610f70565b600194506110b2565b6110da919250863d8811610ca257610c9281836125c5565b9038610f6a565b8451631ad0f74360e01b81528690fd5b8451633bcd329760e21b81528690fd5b9050346105d45760603660031901126105d45761111d366125fc565b916001600160a01b03611154307f00000000000000000000000000000000000000000000000000000000000000008316141561274a565b7fb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d61035490811633036111dd57507f0000000000000000000000000000000000000000000000000000000000000000156111d057600c546001600160401b03166111c357836111c084613f66565b80f35b51633bcd329760e21b8152fd5b51631192b39960e31b8152fd5b8151631194af8760e11b8152908190610c7090338387016127ab565b919050346105d457826003193601126105d457467f00000000000000000000000000000000000000000000000000000000000000001461124e576001600160401b01600160801b01600160c01b01600a558280f35b51635180dd8360e11b8152fd5b505034610247578160031936011261024757602090517f000000000000000000000000000000000000000000000000000000000000000015158152f35b919050346105d4576101a03660031901126105d457602435906112b961264f565b916101003660a31901126105d0575a3386526020936003855260ff8488205416156115f2577f0000000000000000000000000000000000000000000000000000000000000000156115e25783519061131082612528565b60a435825260e03660c319011261043d57845161132c8161258f565b60c43560ff8116810361048c5781526001600160a01b039460e43586811681036115da57828901526001600160401b036101043581811681036115de57888401526101243590811681036115da578694836113ae9260606113bd9601526101443560808201526101643560a08201526101843560c08201528a820152826136de565b60843590606435908a35612c94565b1690816113c8578680f35b3690601f82018083116115c75760051c60068102908082046006148115171561052357916107a16113fd926107988c95612a95565b93323314806115be575b611463575085969061142396949392506107c581945a906128a2565b03925af190811561145a575061143c575b808080808680f35b8161145292903d106108385761082981836125c5565b503880611434565b513d85823e3d90fd5b939091937f000000000000000000000000000000000000000000000000000000000000000016806114a3575b50958596916107c5611423979594936107be565b855163741d16c160e11b81529083828a81845afa84928161159a575b506114cb575b5061148f565b8151156114c557908787969594928a9498519a8b8092631f6d6ef760e01b82525afa908115611590578899839997989992611559575b50611423986107a16115446107c59461153f61154b95517f00000000000000000000000000000000000000000000000000000000000000009061290f565b61290f565b4890612922565b9298508193949597506114c5565b87819a989293503d8311611589575b61157281836125c5565b810103126102475796519496889590611423611501565b503d611568565b86513d84823e3d90fd5b6115b79193503d8087833e6115af81836125c5565b810190612b57565b91386114bf565b50333b15611407565b634e487b7160e01b895260118852602489fd5b8a80fd5b8b80fd5b8351631192b39960e31b81528690fd5b8351632dd9fc9760e01b81528690fd5b83833461024757611612366126f7565b929091935a953233149788809961173d575b1561172d57338b52600360205260ff8a8c2054161561171d5761164684613848565b61170d57906116589594939291612f9b565b6001600160a01b0316908161166b578480f35b3690601f820180831161085c5760051c6006810290808204600614811517156116fa57966116aa8199936107a16020989796946107986116c29c612a95565b9480610853576108485790506107c581945a906128a2565b03925af190811561083f57506116dc575b80808084938480f35b6116f39060203d81116108385761082981836125c5565b50816116d3565b634e487b7160e01b885260118952602488fd5b8951630e5da8fb60e01b81528c90fd5b8951632dd9fc9760e01b81528c90fd5b895163c8958ead60e01b81528c90fd5b50333b15611624565b505034610247578160031936011261024757517f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03168152602090f35b919050346105d457602080600319360112610cdf576002548251638da5cb5b60e01b808252853595926001600160a01b039081169285818681875afa9081156118ac57899161188f575b501633036118545750508385526008825260ff83862054161561183e5750828452600890528220805460ff191690557f5cb4218b272fd214168ac43e90fb4d05d6c36f0b17ffb4c2dd07c234d744eb2a8280a2600360008051602061423a8339815191528280a280f35b825162f20c5d60e01b8152908101849052602490fd5b9280839486948997518095819382525afa948515610ca95794610c7457505051631194af8760e11b8152918291610c709190339084016127ab565b6118a69150863d8811610ca257610c9281836125c5565b386117d4565b87513d8b823e3d90fd5b505034610247578160031936011261024757602091549051908152f35b5050346102475760203660031901126102475760209160ff9082906001600160a01b036118fe6124de565b1681526003855220541690519015158152f35b9050346105d45760203660031901126105d4579181923581526008602052205481519060ff81161515825260018060401b039060081c166020820152f35b8284346108b75760803660031901126108b7576024356001600160401b038111610247576119809036908501612665565b50506064356001600160a01b038116036108b75750516331cee75f60e21b8152fd5b83915034610247576119b3366124f9565b6002548551638da5cb5b60e01b815291936001600160a01b0392909160209082908490829087165afa908115611ab6579083918791611a98575b501633141580611a8a575b611a7357507f28bcc5626d357efe966b4b0876aa1ee8ab99e26da4f131f6a2623f1800701c219394611a5991831686526003602052611a3984828820614208565b51928392836001600160a01b039091168152901515602082015260400190565b0390a1600160008051602061423a8339815191528280a280f35b6024908651906333059da160e11b82523390820152fd5b5081600b54163314156119f8565b611ab0915060203d8111610ca257610c9281836125c5565b886119ed565b87513d88823e3d90fd5b8284346108b757611ad036612692565b9896959490939192945a96338a52600360205260ff898b2054161580611b5b575b611b4b577f000000000000000000000000000000000000000000000000000000000000000015611b3b57611b36611b3061074998999a9b9c3690612bea565b856136de565b61336a565b8851631192b39960e31b81528c90fd5b8851632dd9fc9760e01b81528c90fd5b506002546001600160a01b0316331415611af1565b5050346102475760203660031901126102475760209160ff9082906001600160a01b03611b9b6124de565b1681526009855220541690519015158152f35b50503461024757816003193601126102475751600160fb1b8152602090f35b9050346105d457826003193601126105d4576002548251638da5cb5b60e01b8082526001600160a01b0380841695939493929091602091828187818b5afa908115611cf6579084918a91611cd9575b50163303611c9d57508381836001541685519283809263cb23bcb560e01b82525afa918215611c93578892611c76575b505016809414611c695750506001600160a01b0319161760025580f35b5163d054909f60e01b8152fd5b611c8c9250803d10610ca257610c9281836125c5565b3880611c4c565b84513d8a823e3d90fd5b8387838a9488948585518095819382525afa948515610ca95794610c7457505051631194af8760e11b8152918291610c709190339084016127ab565b611cf09150843d8611610ca257610c9281836125c5565b38611c1c565b85513d8b823e3d90fd5b8284346108b757611d1036612692565b98969594939092935a9532331497888099611db0575b15611da057338b52600360205260ff8a8c20541615611d90577f000000000000000000000000000000000000000000000000000000000000000015611d8057611d7b611b3061165898999a9b9c9d3690612bea565b612f9b565b8951631192b39960e31b81528d90fd5b8951632dd9fc9760e01b81528d90fd5b895163c8958ead60e01b81528d90fd5b50333b15611d26565b50503461024757816003193601126102475751606360f81b8152602090f35b505034610247578160031936011261024757602090517f000000000000000000000000000000000000000000000000000000000000000015158152f35b919050346105d45760a03660031901126105d45760243590611e3561264f565b5a3386526020936003855260ff8488205416156115f257611e5581613848565b611e8157611e6c9060843590606435908835612c94565b6001600160a01b0391821690816113c8578680f35b8351630e5da8fb60e01b81528690fd5b919050346105d45760603660031901126105d457611eae366125fc565b6002548251638da5cb5b60e01b8082529293926020926001600160a01b039081169284818981875afa908115610519578991611fa7575b50163303611f4857867faa7a2d8175dee3b637814ad6346005dfcc357165396fb8327f649effe8abcf856060878787611f1d83613f66565b815183516001600160401b03908116825282850151811692820192909252928201511690820152a180f35b83945085839294518095819382525afa948515610ca95794611f8257505051631194af8760e11b8152918291610c709190339084016127ab565b610c709294509081611f9f92903d10610ca257610c9281836125c5565b929038610c52565b611fbe9150853d8711610ca257610c9281836125c5565b38611ee5565b50503461024757816003193601126102475751600560fc1b8152602090f35b5050346102475781600319360112610247576020905160288152f35b8284346108b75760203660031901126108b757818335918281526008602052209282519361202c85612528565b5460ff81161515855260081c6001600160401b039081166020909501858152949092901561206257505060209251169051908152f35b835162f20c5d60e01b81529182015260249150fd5b505034610247578160031936011261024757600e5490516001600160a01b039091168152602090f35b919050346105d45760209081600319360112610cdf576120be6124de565b6002548251638da5cb5b60e01b8082526001600160a01b03939284169186818981865afa908115610519579085918a9161218b575b5016330361214f5750507f3cd6c184800297a0f2b00926a683cbe76890bb7fd01480ac0a10ed6c8f7f6659945016908160018060a01b0319600b541617600b5551908152a1600560008051602061423a8339815191528280a280f35b84889287808a948585518095819382525afa948515610ca95794610c7457505051631194af8760e11b8152918291610c709190339084016127ab565b6121a29150883d8a11610ca257610c9281836125c5565b386120f3565b919050346105d4576121b9366124f9565b6002548351638da5cb5b60e01b81529193916001600160a01b039160209082908890829086165afa90811561229857908291889161227a575b50163314158061226c575b61225657829161223e917feb12a9a53eec138c91b27b4f912a257bd690c18fc8bde744be92a0365eb9b87e95941687526009602052611a3984828920614208565b0390a160008051602061423a8339815191528280a280f35b81516333059da160e11b81523381870152602490fd5b5080600b54163314156121fd565b612292915060203d8111610ca257610c9281836125c5565b386121f2565b83513d89823e3d90fd5b50503461024757816003193601126102475751908152602090f35b9050346105d45760203660031901126105d4578160209360ff923581526008855220541690519015158152f35b919050346105d457826003193601126105d45760015481516221048360e21b81529260209184919082906001600160a01b03165afa91821561236e578392612337575b6020838351908152f35b9091506020813d8211612366575b81612352602093836125c5565b810103126105d4576020925051903861232d565b3d9150612345565b81513d85823e3d90fd5b83833461024757602090816003193601126105d4576123956124de565b6002548251638da5cb5b60e01b8082526001600160a01b03939284169186818a81865afa9081156124b6579085918991612499575b5016330361245d5750507f00000000000000000000000000000000000000000000000000000000000000001561244d577fe83d6153add50e41b8ee6c1115c4178687349bb12bc3902a50b1f6ad78a0c54194955016908160018060a01b0319600e541617600e5551908152a1600660008051602061423a8339815191528280a280f35b825163384c48ed60e21b81528690fd5b84879287808b948585518095819382525afa948515610ca95794610c7457505051631194af8760e11b8152918291610c709190339084016127ab565b6124b09150883d8a11610ca257610c9281836125c5565b8a6123ca565b86513d8a823e3d90fd5b849034610247578160031936011261024757600160fd1b8152602090f35b600435906001600160a01b03821682036124f457565b600080fd5b60409060031901126124f4576004356001600160a01b03811681036124f4579060243580151581036124f45790565b604081019081106001600160401b0382111761254357604052565b634e487b7160e01b600052604160045260246000fd5b606081019081106001600160401b0382111761254357604052565b608081019081106001600160401b0382111761254357604052565b60e081019081106001600160401b0382111761254357604052565b60c081019081106001600160401b0382111761254357604052565b601f909101601f19168101906001600160401b0382119082101761254357604052565b35906001600160401b03821682036124f457565b60609060031901126124f4576040519061261582612559565b6001600160401b038260043582811681036124f457815260243582811681036124f457602082015260443591821682036124f45760400152565b604435906001600160a01b03821682036124f457565b9181601f840112156124f4578235916001600160401b0383116124f457602083818601950101116124f457565b906101c06003198301126124f457600435916024356001600160401b0381116124f457816126c291600401612665565b90929091604435916064356001600160a01b03811681036124f457916084359161010060a4359260c31901126124f45760c490565b9060c06003198301126124f45760043591602435906001600160401b0382116124f45761272691600401612665565b9091604435906064356001600160a01b03811681036124f457906084359060a43590565b1561275157565b60405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201526b19195b1959d85d1958d85b1b60a21b6064820152608490fd5b6001600160a01b0391821681529116602082015260400190565b908160209103126124f457516001600160a01b03811681036124f45790565b600d8054600160401b600160801b03191660409290921b600160401b600160801b0316919091179055565b600c80546001600160c01b031660c09290921b6001600160c01b031916919091179055565b7f0000000000000000000000000000000000000000000000000000000000000000461461286657600190819082908390565b600a546001600160401b0380821692604083901c821692608081901c9092169160c01c90565b6044356001600160401b03811681036124f45790565b919082039182116128af57565b634e487b7160e01b600052601160045260246000fd5b919082018092116128af57565b61290b600c54600d549260018060401b039384811692858160401c169286808360801c169360401c16918780821692169060c01c612942565b1690565b818102929181159184041417156128af57565b811561292c570490565b634e487b7160e01b600052601260045260246000fd5b9261298961271091612990949398969886600091818111600014612a045761296a92506128a2565b955b600091818111156129fc5761298192506128a2565b955b8561290f565b04906128c5565b91846000918181116000146129f4576129a992506128a2565b905b8082116129ec575b508082116129c2575b50505090565b6129cb916128a2565b8281116129d857806129bc565b909150818111156129e7575090565b905090565b9050386129b3565b5050906129ab565b505095612983565b50509561296c565b95939190949260405195602087019760ff60f81b9060f81b16885260018060601b03199060601b16602187015260018060c01b0319809260c01b16603587015260c01b16603d85015260458401526065830152608582015260858152612a71816125aa565b51902090565b906040519060208201928352604082015260408152612a7181612559565b6000908015612b53578080600114612b4b57600214612b43576001918261013383101683600b84101617612b335760028392935b808211612af657505082600019048211612ae257500290565b634e487b7160e01b81526011600452602490fd5b909380600019048111612b1f57818516612b16575b800293811c90612ac9565b80930292612b0b565b634e487b7160e01b83526011600452602483fd5b929150600283910a92612ae25750565b509060049150565b505050600190565b5090565b9060209081838203126124f45782516001600160401b03938482116124f4570181601f820112156124f4578051938411612543578360051b9060405194612ba0858401876125c5565b855283808601928201019283116124f4578301905b828210612bc3575050505090565b81518152908301908301612bb5565b908160209103126124f4575180151581036124f45790565b809291039161010083126124f45760405190612c0582612528565b60e0829482358452601f1901126124f45760405191612c238361258f565b602082013560ff811681036124f457835260408201356001600160a01b03811681036124f45760209260e09184860152612c5f606082016125e8565b6040860152612c70608082016125e8565b606086015260a0810135608086015260c081013560a0860152013560c08401520152565b92919091612ca0613892565b506040805163741d16c160e11b815260009590936004937f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316929088878781875afa968715611cf6578997612f57575b50865115612f4757612d09886138b7565b939086518096631f6d6ef760e01b8252818a6020998a935afa908115612f3d578c91612f10575b508060111b90808204620200001490151715612efd578951612d519161290f565b98875190878201908d828a8351919301915b8b828210612ee95750505050602183612dc593612d92612df199989796612dd49503601f1981018452836125c5565b8b8d5195869382612dac8187019a8b815193849201613a06565b600560fc1b908601938401525192839086840190613a06565b010360018101845201826125c5565b519020984815612ee157612de9904890612922565b995b89613e19565b95919490929a848c141580612ed5575b612eb9575487519384528383015280516001600160401b0390811684890152918101518216606084810191909152878201518316608085015201511660a0820152600360c082015260008051602061421a8339815191529060e090a47f0000000000000000000000000000000000000000000000000000000000000000612eac57505032331480612ea3575b612e9657505050565b612ea1924891613cdd565b565b50333b15612e8d565b516386657a5360e01b8152fd5b604489868e8b519263ac7411c960e01b84528301526024820152fd5b50600019851415612e01565b508a99612deb565b835185529384019390920191600101612d63565b634e487b7160e01b8c526011895260248cfd5b90508681813d8311612f36575b612f2781836125c5565b810103126115de575138612d30565b503d612f1d565b88513d8e823e3d90fd5b8451631e693f5b60e11b81528690fd5b612f6c9197503d808b833e6115af81836125c5565b9538612cf8565b90918060409360208452816020850152848401376000828201840152601f01601f1916010190565b92939190612fa7613892565b5081602801806028116128af577f000000000000000000000000000000000000000000000000000000000000000080821161334c575050612fe7856138b7565b90918315958615968761321a575b506040938451956020938185613014818b019586815193849201613a06565b89019186830137019561303584826000998a838201520380845201826125c5565b519020988554891061320957600154855163eca067ad60e01b81526001600160a01b0390911691908481600481865afa9081156131ff5788916131d2575b508a116131c15760848b886080948d948a519c8d96879563432cc52b60e11b875260048701526024860152604485015260648401525af19889156131b757859786998798889c61316b575b508755613159575b50808714158061314d575b6131305750835483519586528582015281516001600160401b039081168685015290820151811660608681019190915292820151811660808601529101511660a083015260c082015260008051602061421a8339815191529060e090a4565b8660449185519163ac7411c960e01b835260048301526024820152fd5b506000198114156130d1565b61316590884891613a29565b386130c6565b9a509a50975095506080883d82116131af575b8161318b608093836125c5565b810103126105d05787519582890151976060868b01519a0151979899979a386130be565b3d915061317e565b84513d87823e3d90fd5b855163925f8bd360e01b8152600490fd5b90508481813d83116131f8575b6131e981836125c5565b8101031261043d575138613073565b503d6131df565b87513d8a823e3d90fd5b8451633eb9f37d60e11b8152600490fd5b806132ea578235906001600160f81b031982168015801561333f575b8015613332575b8015613325575b8015613318575b1561330057506132ea57600160ff1b81161515806132df575b61329e575b606360f81b16151580613293575b6132815738612ff5565b604051633a205f0960e11b8152600490fd5b506059851415613277565b856021116124f457600183013580600052600860205260ff60406000205416156132c85750613269565b6024906040519062f20c5d60e01b82526004820152fd5b506021861015613264565b634e487b7160e01b600052603260045260246000fd5b6024906040519063359999ab60e11b82526004820152fd5b50600160fd1b811461324b565b50601160fb1b8114613244565b50606360f81b811461323d565b50600160ff1b8114613236565b6044925060405191634634691b60e01b835260048301526024820152fd5b949193929092613378613892565b5084602801806028116128af577f000000000000000000000000000000000000000000000000000000000000000080821161334c5750506133b8826138b7565b939086158015613603575b5060409485519360209289846133e28189019384815193849201613a06565b8701818b87830137019561340485826000998a838201520380845201826125c5565b519020855487106135f257600154885163eca067ad60e01b81526001600160a01b03909116908581600481855afa9081156135e85788916135bb575b5088116135aa5760809291876084928b51988995869463432cc52b60e11b865260048601528c6024860152604485015260648401525af19485156135a05784998580958198613553575b50829055808b141580613547575b61352a575060e0613525969488969460608d9560008051602061421a833981519152957ffe325ca1efe4c5c1062c981c3ee74b781debe4ea9440306a96d2a55759c66c209e9d9c519485528385015260018060401b038093818351168c8701528201511682850152828a82015116608085015201511660a0820152600160c0820152a45192839283612f73565b0390a2565b8a60449189519163ac7411c960e01b835260048301526024820152fd5b50600019811415613498565b96509650995092506080843d8211613598575b81613573608093836125c5565b810103126105d057835192828501519981606089880151970151959b9695979061348a565b3d9150613566565b86513d86823e3d90fd5b885163925f8bd360e01b8152600490fd5b90508581813d83116135e1575b6135d281836125c5565b8101031261043d575138613440565b503d6135c8565b8a513d8a823e3d90fd5b8751633eb9f37d60e11b8152600490fd5b806132ea578635906001600160f81b03198216801580156136d1575b80156136c4575b80156136b7575b80156136aa575b1561330057506132ea57600160ff1b811615158061369f575b613675575b606360f81b1615158061366a575b61328157386133c3565b506059871415613660565b876021116124f457600187013580600052600860205260ff60406000205416156132c85750613652565b50602188101561364d565b50600160fd1b8114613634565b50601160fb1b811461362d565b50606360f81b8114613626565b50600160ff1b811461361f565b6000548091116136ec575050565b6136f4613824565b158015613809575b613704575050565b600154604051636ab8cee160e11b815260048101929092526020926001600160a01b03929184908390602490829087165afa9182156137fd576000926137cc575b508061378e85613794935192019586519560ff87511691870151169560018060401b039687604083015116886060840151169060808401519260c060a086015195015195612a0c565b90612a77565b036137ba576137b3816040612ea1945101511661058061055e826128d2565b43166127e4565b60405163c334542d60e01b8152600490fd5b90918482813d83116137f6575b6137e381836125c5565b810103126108b757505190613794613745565b503d6137d9565b6040513d6000823e3d90fd5b50600c546001600160401b03604082901c81169116106136fc565b600c546138348160c01c436128a2565b60809190911c6001600160401b0316101590565b7f00000000000000000000000000000000000000000000000000000000000000009081613886575b50806138795790565b50613882613824565b1590565b90506000541038613870565b6040519061389f82612574565b60006060838281528260208201528260408201520152565b906138c0613892565b506138c9613892565b506139236138d5613892565b926138de612834565b92946001600160401b039493909291859161390791839081811642116139be575b5042166139ed565b958160208a019716875281811643116139a5575b5043166139ed565b9182166060860152845192516040860151926040519460018060c01b03199485809481809460c01b1660208a015260c01b16602888015260c01b16603086015260c01b16603884015260c01b1660408201526028815261398281612559565b602881510361398f579190565b634e487b7160e01b600052600160045260246000fd5b6139b1908243166139d4565b166040880152833861391b565b6139ca908242166139d4565b168a5282386138ff565b6001600160401b0391821690821603919082116128af57565b6001600160401b0391821690821601919082116128af57565b60005b838110613a195750506000910152565b8181015183820152602001613a09565b600e546001600160a01b03908116949391926000907f00000000000000000000000000000000000000000000000000000000000000008080613cd5575b613ccb577f0000000000000000000000000000000000000000000000000000000000000000613c4f575b6001600160401b038311613c3d5780613c34575b613bb9575b60009650604092835192602095869384860198428a523260601b8888015260548701526074860152609485015260018060c01b03199060c01b1660b4840152609c8352613af5836125aa565b600154166044835187208551998a938492637a88b10760e01b845232600485015260248401525af1938415613bae57600094613b7c575b7fff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b94959650613b6d8351948593818552519283809286015285850190613a06565b601f01601f19168101030190a2565b93958381813d8311613ba7575b613b9381836125c5565b810103126105cc5751949550859493613b2c565b503d613b89565b82513d6000823e3d90fd5b929560206000916004604051809481936339aa885b60e21b83525af19081156137fd57600091613c01575b50613bfa670de0b6b3a76400009160009861290f565b0492613aa9565b906020823d8211613c2c575b81613c1a602093836125c5565b810103126108b7575051613bfa613be4565b3d9150613c0d565b50861515613aa4565b60405163026aa80960e11b8152600490fd5b60405163637bef0760e11b81529092602082600481606c5afa908115613cbf578091613c89575b50613c8391504890612922565b91613a90565b90506020823d8211613cb7575b81613ca3602093836125c5565b810103126108b75750613c83905138613c76565b3d9150613c96565b604051903d90823e3d90fd5b5050505050509050565b508715613a66565b600e546001600160a01b0390811695949193929091907f00000000000000000000000000000000000000000000000000000000000000008080613e11575b613ccb577f0000000000000000000000000000000000000000000000000000000000000000613da7576001600160401b038311613c3d5780613c3457613bb95760009650604092835192602095869384860198428a523260601b8888015260548701526074860152609485015260018060c01b03199060c01b1660b4840152609c8352613af5836125aa565b9160405163637bef0760e11b8152602081600481606c5afa9081156137fd57600091613dde575b50906107a1613c83924890612922565b906020823d8211613e09575b81613df7602093836125c5565b810103126108b75750516107a1613dce565b3d9150613dea565b508715613d1b565b919392909260009485548510613f38576001546040805163eca067ad60e01b81529095916001600160a01b031690602081600481855afa9081156118ac578991613f07575b5087116131c15760809291886084928851978895869463432cc52b60e11b865260048601528b6024860152604485015260648401525af1938415613efd578594869487948892613eb2575b50509293949555565b955095505091506080833d8211613ef5575b81613ed1608093836125c5565b810103126105d0578251916060602085015195850151940151929493923880613ea9565b3d9150613ec4565b83513d87823e3d90fd5b90506020813d8211613f30575b81613f21602093836125c5565b8101031261050d575138613e5e565b3d9150613f14565b604051633eb9f37d60e11b8152600490fd5b600a546001600160401b039081169082168111156129e7575090565b7f0000000000000000000000000000000000000000000000000000000000000000156141435780516001600160401b03919082168015159081614133575b8161411f575b8161410e575b50156140fc5760408291600c805484811680159081156140ec575b506140d3575b5080548251908582169081878216106140c1575b5050602083015190825490600160801b600160c01b039060801b16916001861b600160801b0390861b16906001861b600160c01b0319161717905501511660018060401b0319600d541617600d556004602060018060a01b03600154166040519283809263eca067ad60e01b82525afa9081156137fd57600091614090575b50600054146140705750565b612ea190431661408261055e826128d2565b61408b8161280f565b6127e4565b906020823d82116140b9575b816140a9602093836125c5565b810103126108b757505138614064565b3d915061409c565b600180871b0319161782553880613fe5565b8460208401511690600180861b03191617815538613fd1565b9050856020850151161038613fcb565b604051636d0e475b60e11b8152600490fd5b905082602083015116101538613fb0565b905061271083604084015116111590613faa565b6020830151841615159150613fa4565b604051631192b39960e31b8152600490fd5b80516001600160401b0390811080156141fb575b80156141ee575b80156141e1575b6141cf57815160208301516040808501516060909501516001600160c01b031960c09190911b16600160801b600160c01b0360809690961b9590951693909216600160401b600160801b039190921b16171717600a55565b6040516309cfba7560e01b8152600490fd5b5080606083015111614177565b5080604083015111614170565b5080602083015111614169565b9060ff80198354169115151617905556fe7394f4a19a13c7b92b5bb71033245305946ef78452f7b4986ac1390b5df4ebd7ea8787f128d10b2cc0317b0c3960f9ad447f7f6c1ed189db1083ccffd20f456eabca9b7986bc22ad0160eb0cb88ae75411eacfba4052af0b457a9335ef655722a2646970667358221220cde831635131940211a6ee6efb9f4b2dd7ca71cbcdc643048986dffc3b0b48a164736f6c63430008130033",
}

// SequencerInboxABI is the input ABI used to generate the binding from.
// Deprecated: Use SequencerInboxMetaData.ABI instead.
var SequencerInboxABI = SequencerInboxMetaData.ABI

// SequencerInboxBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use SequencerInboxMetaData.Bin instead.
var SequencerInboxBin = SequencerInboxMetaData.Bin

// DeploySequencerInbox deploys a new Ethereum contract, binding an instance of SequencerInbox to it.
func DeploySequencerInbox(auth *bind.TransactOpts, backend bind.ContractBackend, _maxDataSize *big.Int, reader4844_ common.Address, _isUsingFeeToken bool, _isDelayBufferable bool) (common.Address, *types.Transaction, *SequencerInbox, error) {
	parsed, err := SequencerInboxMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(SequencerInboxBin), backend, _maxDataSize, reader4844_, _isUsingFeeToken, _isDelayBufferable)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SequencerInbox{SequencerInboxCaller: SequencerInboxCaller{contract: contract}, SequencerInboxTransactor: SequencerInboxTransactor{contract: contract}, SequencerInboxFilterer: SequencerInboxFilterer{contract: contract}}, nil
}

// SequencerInbox is an auto generated Go binding around an Ethereum contract.
type SequencerInbox struct {
	SequencerInboxCaller     // Read-only binding to the contract
	SequencerInboxTransactor // Write-only binding to the contract
	SequencerInboxFilterer   // Log filterer for contract events
}

// SequencerInboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type SequencerInboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SequencerInboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SequencerInboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SequencerInboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SequencerInboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SequencerInboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SequencerInboxSession struct {
	Contract     *SequencerInbox   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SequencerInboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SequencerInboxCallerSession struct {
	Contract *SequencerInboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// SequencerInboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SequencerInboxTransactorSession struct {
	Contract     *SequencerInboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// SequencerInboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type SequencerInboxRaw struct {
	Contract *SequencerInbox // Generic contract binding to access the raw methods on
}

// SequencerInboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SequencerInboxCallerRaw struct {
	Contract *SequencerInboxCaller // Generic read-only contract binding to access the raw methods on
}

// SequencerInboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SequencerInboxTransactorRaw struct {
	Contract *SequencerInboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSequencerInbox creates a new instance of SequencerInbox, bound to a specific deployed contract.
func NewSequencerInbox(address common.Address, backend bind.ContractBackend) (*SequencerInbox, error) {
	contract, err := bindSequencerInbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SequencerInbox{SequencerInboxCaller: SequencerInboxCaller{contract: contract}, SequencerInboxTransactor: SequencerInboxTransactor{contract: contract}, SequencerInboxFilterer: SequencerInboxFilterer{contract: contract}}, nil
}

// NewSequencerInboxCaller creates a new read-only instance of SequencerInbox, bound to a specific deployed contract.
func NewSequencerInboxCaller(address common.Address, caller bind.ContractCaller) (*SequencerInboxCaller, error) {
	contract, err := bindSequencerInbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SequencerInboxCaller{contract: contract}, nil
}

// NewSequencerInboxTransactor creates a new write-only instance of SequencerInbox, bound to a specific deployed contract.
func NewSequencerInboxTransactor(address common.Address, transactor bind.ContractTransactor) (*SequencerInboxTransactor, error) {
	contract, err := bindSequencerInbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SequencerInboxTransactor{contract: contract}, nil
}

// NewSequencerInboxFilterer creates a new log filterer instance of SequencerInbox, bound to a specific deployed contract.
func NewSequencerInboxFilterer(address common.Address, filterer bind.ContractFilterer) (*SequencerInboxFilterer, error) {
	contract, err := bindSequencerInbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SequencerInboxFilterer{contract: contract}, nil
}

// bindSequencerInbox binds a generic wrapper to an already deployed contract.
func bindSequencerInbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := SequencerInboxMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SequencerInbox *SequencerInboxRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SequencerInbox.Contract.SequencerInboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SequencerInbox *SequencerInboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SequencerInboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SequencerInbox *SequencerInboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SequencerInboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SequencerInbox *SequencerInboxCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _SequencerInbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SequencerInbox *SequencerInboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SequencerInbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SequencerInbox *SequencerInboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SequencerInbox.Contract.contract.Transact(opts, method, params...)
}

// BROTLIMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x16af91a7.
//
// Solidity: function BROTLI_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCaller) BROTLIMESSAGEHEADERFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "BROTLI_MESSAGE_HEADER_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// BROTLIMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x16af91a7.
//
// Solidity: function BROTLI_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxSession) BROTLIMESSAGEHEADERFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.BROTLIMESSAGEHEADERFLAG(&_SequencerInbox.CallOpts)
}

// BROTLIMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x16af91a7.
//
// Solidity: function BROTLI_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCallerSession) BROTLIMESSAGEHEADERFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.BROTLIMESSAGEHEADERFLAG(&_SequencerInbox.CallOpts)
}

// CELESTIAMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x5fd9e56d.
//
// Solidity: function CELESTIA_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCaller) CELESTIAMESSAGEHEADERFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "CELESTIA_MESSAGE_HEADER_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// CELESTIAMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x5fd9e56d.
//
// Solidity: function CELESTIA_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxSession) CELESTIAMESSAGEHEADERFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.CELESTIAMESSAGEHEADERFLAG(&_SequencerInbox.CallOpts)
}

// CELESTIAMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x5fd9e56d.
//
// Solidity: function CELESTIA_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCallerSession) CELESTIAMESSAGEHEADERFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.CELESTIAMESSAGEHEADERFLAG(&_SequencerInbox.CallOpts)
}

// DASMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0xf60a5091.
//
// Solidity: function DAS_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCaller) DASMESSAGEHEADERFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "DAS_MESSAGE_HEADER_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// DASMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0xf60a5091.
//
// Solidity: function DAS_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxSession) DASMESSAGEHEADERFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.DASMESSAGEHEADERFLAG(&_SequencerInbox.CallOpts)
}

// DASMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0xf60a5091.
//
// Solidity: function DAS_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCallerSession) DASMESSAGEHEADERFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.DASMESSAGEHEADERFLAG(&_SequencerInbox.CallOpts)
}

// DATAAUTHENTICATEDFLAG is a free data retrieval call binding the contract method 0xe5a358c8.
//
// Solidity: function DATA_AUTHENTICATED_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCaller) DATAAUTHENTICATEDFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "DATA_AUTHENTICATED_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// DATAAUTHENTICATEDFLAG is a free data retrieval call binding the contract method 0xe5a358c8.
//
// Solidity: function DATA_AUTHENTICATED_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxSession) DATAAUTHENTICATEDFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.DATAAUTHENTICATEDFLAG(&_SequencerInbox.CallOpts)
}

// DATAAUTHENTICATEDFLAG is a free data retrieval call binding the contract method 0xe5a358c8.
//
// Solidity: function DATA_AUTHENTICATED_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCallerSession) DATAAUTHENTICATEDFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.DATAAUTHENTICATEDFLAG(&_SequencerInbox.CallOpts)
}

// DATABLOBHEADERFLAG is a free data retrieval call binding the contract method 0x2cbf74e5.
//
// Solidity: function DATA_BLOB_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCaller) DATABLOBHEADERFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "DATA_BLOB_HEADER_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// DATABLOBHEADERFLAG is a free data retrieval call binding the contract method 0x2cbf74e5.
//
// Solidity: function DATA_BLOB_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxSession) DATABLOBHEADERFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.DATABLOBHEADERFLAG(&_SequencerInbox.CallOpts)
}

// DATABLOBHEADERFLAG is a free data retrieval call binding the contract method 0x2cbf74e5.
//
// Solidity: function DATA_BLOB_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCallerSession) DATABLOBHEADERFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.DATABLOBHEADERFLAG(&_SequencerInbox.CallOpts)
}

// HEADERLENGTH is a free data retrieval call binding the contract method 0x27957a49.
//
// Solidity: function HEADER_LENGTH() view returns(uint256)
func (_SequencerInbox *SequencerInboxCaller) HEADERLENGTH(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "HEADER_LENGTH")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// HEADERLENGTH is a free data retrieval call binding the contract method 0x27957a49.
//
// Solidity: function HEADER_LENGTH() view returns(uint256)
func (_SequencerInbox *SequencerInboxSession) HEADERLENGTH() (*big.Int, error) {
	return _SequencerInbox.Contract.HEADERLENGTH(&_SequencerInbox.CallOpts)
}

// HEADERLENGTH is a free data retrieval call binding the contract method 0x27957a49.
//
// Solidity: function HEADER_LENGTH() view returns(uint256)
func (_SequencerInbox *SequencerInboxCallerSession) HEADERLENGTH() (*big.Int, error) {
	return _SequencerInbox.Contract.HEADERLENGTH(&_SequencerInbox.CallOpts)
}

// TREEDASMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x6c890450.
//
// Solidity: function TREE_DAS_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCaller) TREEDASMESSAGEHEADERFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "TREE_DAS_MESSAGE_HEADER_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// TREEDASMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x6c890450.
//
// Solidity: function TREE_DAS_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxSession) TREEDASMESSAGEHEADERFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.TREEDASMESSAGEHEADERFLAG(&_SequencerInbox.CallOpts)
}

// TREEDASMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x6c890450.
//
// Solidity: function TREE_DAS_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCallerSession) TREEDASMESSAGEHEADERFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.TREEDASMESSAGEHEADERFLAG(&_SequencerInbox.CallOpts)
}

// ZEROHEAVYMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x02c99275.
//
// Solidity: function ZERO_HEAVY_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCaller) ZEROHEAVYMESSAGEHEADERFLAG(opts *bind.CallOpts) ([1]byte, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "ZERO_HEAVY_MESSAGE_HEADER_FLAG")

	if err != nil {
		return *new([1]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)

	return out0, err

}

// ZEROHEAVYMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x02c99275.
//
// Solidity: function ZERO_HEAVY_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxSession) ZEROHEAVYMESSAGEHEADERFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.ZEROHEAVYMESSAGEHEADERFLAG(&_SequencerInbox.CallOpts)
}

// ZEROHEAVYMESSAGEHEADERFLAG is a free data retrieval call binding the contract method 0x02c99275.
//
// Solidity: function ZERO_HEAVY_MESSAGE_HEADER_FLAG() view returns(bytes1)
func (_SequencerInbox *SequencerInboxCallerSession) ZEROHEAVYMESSAGEHEADERFLAG() ([1]byte, error) {
	return _SequencerInbox.Contract.ZEROHEAVYMESSAGEHEADERFLAG(&_SequencerInbox.CallOpts)
}

// AddSequencerL2BatchFromOrigin6f12b0c9 is a free data retrieval call binding the contract method 0x6f12b0c9.
//
// Solidity: function addSequencerL2BatchFromOrigin(uint256 , bytes , uint256 , address ) pure returns()
func (_SequencerInbox *SequencerInboxCaller) AddSequencerL2BatchFromOrigin6f12b0c9(opts *bind.CallOpts, arg0 *big.Int, arg1 []byte, arg2 *big.Int, arg3 common.Address) error {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "addSequencerL2BatchFromOrigin", arg0, arg1, arg2, arg3)

	if err != nil {
		return err
	}

	return err

}

// AddSequencerL2BatchFromOrigin6f12b0c9 is a free data retrieval call binding the contract method 0x6f12b0c9.
//
// Solidity: function addSequencerL2BatchFromOrigin(uint256 , bytes , uint256 , address ) pure returns()
func (_SequencerInbox *SequencerInboxSession) AddSequencerL2BatchFromOrigin6f12b0c9(arg0 *big.Int, arg1 []byte, arg2 *big.Int, arg3 common.Address) error {
	return _SequencerInbox.Contract.AddSequencerL2BatchFromOrigin6f12b0c9(&_SequencerInbox.CallOpts, arg0, arg1, arg2, arg3)
}

// AddSequencerL2BatchFromOrigin6f12b0c9 is a free data retrieval call binding the contract method 0x6f12b0c9.
//
// Solidity: function addSequencerL2BatchFromOrigin(uint256 , bytes , uint256 , address ) pure returns()
func (_SequencerInbox *SequencerInboxCallerSession) AddSequencerL2BatchFromOrigin6f12b0c9(arg0 *big.Int, arg1 []byte, arg2 *big.Int, arg3 common.Address) error {
	return _SequencerInbox.Contract.AddSequencerL2BatchFromOrigin6f12b0c9(&_SequencerInbox.CallOpts, arg0, arg1, arg2, arg3)
}

// BatchCount is a free data retrieval call binding the contract method 0x06f13056.
//
// Solidity: function batchCount() view returns(uint256)
func (_SequencerInbox *SequencerInboxCaller) BatchCount(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "batchCount")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BatchCount is a free data retrieval call binding the contract method 0x06f13056.
//
// Solidity: function batchCount() view returns(uint256)
func (_SequencerInbox *SequencerInboxSession) BatchCount() (*big.Int, error) {
	return _SequencerInbox.Contract.BatchCount(&_SequencerInbox.CallOpts)
}

// BatchCount is a free data retrieval call binding the contract method 0x06f13056.
//
// Solidity: function batchCount() view returns(uint256)
func (_SequencerInbox *SequencerInboxCallerSession) BatchCount() (*big.Int, error) {
	return _SequencerInbox.Contract.BatchCount(&_SequencerInbox.CallOpts)
}

// BatchPosterManager is a free data retrieval call binding the contract method 0xcc2a1a0c.
//
// Solidity: function batchPosterManager() view returns(address)
func (_SequencerInbox *SequencerInboxCaller) BatchPosterManager(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "batchPosterManager")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// BatchPosterManager is a free data retrieval call binding the contract method 0xcc2a1a0c.
//
// Solidity: function batchPosterManager() view returns(address)
func (_SequencerInbox *SequencerInboxSession) BatchPosterManager() (common.Address, error) {
	return _SequencerInbox.Contract.BatchPosterManager(&_SequencerInbox.CallOpts)
}

// BatchPosterManager is a free data retrieval call binding the contract method 0xcc2a1a0c.
//
// Solidity: function batchPosterManager() view returns(address)
func (_SequencerInbox *SequencerInboxCallerSession) BatchPosterManager() (common.Address, error) {
	return _SequencerInbox.Contract.BatchPosterManager(&_SequencerInbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_SequencerInbox *SequencerInboxCaller) Bridge(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "bridge")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_SequencerInbox *SequencerInboxSession) Bridge() (common.Address, error) {
	return _SequencerInbox.Contract.Bridge(&_SequencerInbox.CallOpts)
}

// Bridge is a free data retrieval call binding the contract method 0xe78cea92.
//
// Solidity: function bridge() view returns(address)
func (_SequencerInbox *SequencerInboxCallerSession) Bridge() (common.Address, error) {
	return _SequencerInbox.Contract.Bridge(&_SequencerInbox.CallOpts)
}

// Buffer is a free data retrieval call binding the contract method 0xedaafe20.
//
// Solidity: function buffer() view returns(uint64 bufferBlocks, uint64 max, uint64 threshold, uint64 prevBlockNumber, uint64 replenishRateInBasis, uint64 prevSequencedBlockNumber)
func (_SequencerInbox *SequencerInboxCaller) Buffer(opts *bind.CallOpts) (struct {
	BufferBlocks             uint64
	Max                      uint64
	Threshold                uint64
	PrevBlockNumber          uint64
	ReplenishRateInBasis     uint64
	PrevSequencedBlockNumber uint64
}, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "buffer")

	outstruct := new(struct {
		BufferBlocks             uint64
		Max                      uint64
		Threshold                uint64
		PrevBlockNumber          uint64
		ReplenishRateInBasis     uint64
		PrevSequencedBlockNumber uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.BufferBlocks = *abi.ConvertType(out[0], new(uint64)).(*uint64)
	outstruct.Max = *abi.ConvertType(out[1], new(uint64)).(*uint64)
	outstruct.Threshold = *abi.ConvertType(out[2], new(uint64)).(*uint64)
	outstruct.PrevBlockNumber = *abi.ConvertType(out[3], new(uint64)).(*uint64)
	outstruct.ReplenishRateInBasis = *abi.ConvertType(out[4], new(uint64)).(*uint64)
	outstruct.PrevSequencedBlockNumber = *abi.ConvertType(out[5], new(uint64)).(*uint64)

	return *outstruct, err

}

// Buffer is a free data retrieval call binding the contract method 0xedaafe20.
//
// Solidity: function buffer() view returns(uint64 bufferBlocks, uint64 max, uint64 threshold, uint64 prevBlockNumber, uint64 replenishRateInBasis, uint64 prevSequencedBlockNumber)
func (_SequencerInbox *SequencerInboxSession) Buffer() (struct {
	BufferBlocks             uint64
	Max                      uint64
	Threshold                uint64
	PrevBlockNumber          uint64
	ReplenishRateInBasis     uint64
	PrevSequencedBlockNumber uint64
}, error) {
	return _SequencerInbox.Contract.Buffer(&_SequencerInbox.CallOpts)
}

// Buffer is a free data retrieval call binding the contract method 0xedaafe20.
//
// Solidity: function buffer() view returns(uint64 bufferBlocks, uint64 max, uint64 threshold, uint64 prevBlockNumber, uint64 replenishRateInBasis, uint64 prevSequencedBlockNumber)
func (_SequencerInbox *SequencerInboxCallerSession) Buffer() (struct {
	BufferBlocks             uint64
	Max                      uint64
	Threshold                uint64
	PrevBlockNumber          uint64
	ReplenishRateInBasis     uint64
	PrevSequencedBlockNumber uint64
}, error) {
	return _SequencerInbox.Contract.Buffer(&_SequencerInbox.CallOpts)
}

// DasKeySetInfo is a free data retrieval call binding the contract method 0x715ea34b.
//
// Solidity: function dasKeySetInfo(bytes32 ) view returns(bool isValidKeyset, uint64 creationBlock)
func (_SequencerInbox *SequencerInboxCaller) DasKeySetInfo(opts *bind.CallOpts, arg0 [32]byte) (struct {
	IsValidKeyset bool
	CreationBlock uint64
}, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "dasKeySetInfo", arg0)

	outstruct := new(struct {
		IsValidKeyset bool
		CreationBlock uint64
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.IsValidKeyset = *abi.ConvertType(out[0], new(bool)).(*bool)
	outstruct.CreationBlock = *abi.ConvertType(out[1], new(uint64)).(*uint64)

	return *outstruct, err

}

// DasKeySetInfo is a free data retrieval call binding the contract method 0x715ea34b.
//
// Solidity: function dasKeySetInfo(bytes32 ) view returns(bool isValidKeyset, uint64 creationBlock)
func (_SequencerInbox *SequencerInboxSession) DasKeySetInfo(arg0 [32]byte) (struct {
	IsValidKeyset bool
	CreationBlock uint64
}, error) {
	return _SequencerInbox.Contract.DasKeySetInfo(&_SequencerInbox.CallOpts, arg0)
}

// DasKeySetInfo is a free data retrieval call binding the contract method 0x715ea34b.
//
// Solidity: function dasKeySetInfo(bytes32 ) view returns(bool isValidKeyset, uint64 creationBlock)
func (_SequencerInbox *SequencerInboxCallerSession) DasKeySetInfo(arg0 [32]byte) (struct {
	IsValidKeyset bool
	CreationBlock uint64
}, error) {
	return _SequencerInbox.Contract.DasKeySetInfo(&_SequencerInbox.CallOpts, arg0)
}

// FeeTokenPricer is a free data retrieval call binding the contract method 0x22291e8d.
//
// Solidity: function feeTokenPricer() view returns(address)
func (_SequencerInbox *SequencerInboxCaller) FeeTokenPricer(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "feeTokenPricer")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// FeeTokenPricer is a free data retrieval call binding the contract method 0x22291e8d.
//
// Solidity: function feeTokenPricer() view returns(address)
func (_SequencerInbox *SequencerInboxSession) FeeTokenPricer() (common.Address, error) {
	return _SequencerInbox.Contract.FeeTokenPricer(&_SequencerInbox.CallOpts)
}

// FeeTokenPricer is a free data retrieval call binding the contract method 0x22291e8d.
//
// Solidity: function feeTokenPricer() view returns(address)
func (_SequencerInbox *SequencerInboxCallerSession) FeeTokenPricer() (common.Address, error) {
	return _SequencerInbox.Contract.FeeTokenPricer(&_SequencerInbox.CallOpts)
}

// ForceInclusionDeadline is a free data retrieval call binding the contract method 0xdd44e6e0.
//
// Solidity: function forceInclusionDeadline(uint64 blockNumber) view returns(uint64)
func (_SequencerInbox *SequencerInboxCaller) ForceInclusionDeadline(opts *bind.CallOpts, blockNumber uint64) (uint64, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "forceInclusionDeadline", blockNumber)

	if err != nil {
		return *new(uint64), err
	}

	out0 := *abi.ConvertType(out[0], new(uint64)).(*uint64)

	return out0, err

}

// ForceInclusionDeadline is a free data retrieval call binding the contract method 0xdd44e6e0.
//
// Solidity: function forceInclusionDeadline(uint64 blockNumber) view returns(uint64)
func (_SequencerInbox *SequencerInboxSession) ForceInclusionDeadline(blockNumber uint64) (uint64, error) {
	return _SequencerInbox.Contract.ForceInclusionDeadline(&_SequencerInbox.CallOpts, blockNumber)
}

// ForceInclusionDeadline is a free data retrieval call binding the contract method 0xdd44e6e0.
//
// Solidity: function forceInclusionDeadline(uint64 blockNumber) view returns(uint64)
func (_SequencerInbox *SequencerInboxCallerSession) ForceInclusionDeadline(blockNumber uint64) (uint64, error) {
	return _SequencerInbox.Contract.ForceInclusionDeadline(&_SequencerInbox.CallOpts, blockNumber)
}

// GetKeysetCreationBlock is a free data retrieval call binding the contract method 0x258f0495.
//
// Solidity: function getKeysetCreationBlock(bytes32 ksHash) view returns(uint256)
func (_SequencerInbox *SequencerInboxCaller) GetKeysetCreationBlock(opts *bind.CallOpts, ksHash [32]byte) (*big.Int, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "getKeysetCreationBlock", ksHash)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetKeysetCreationBlock is a free data retrieval call binding the contract method 0x258f0495.
//
// Solidity: function getKeysetCreationBlock(bytes32 ksHash) view returns(uint256)
func (_SequencerInbox *SequencerInboxSession) GetKeysetCreationBlock(ksHash [32]byte) (*big.Int, error) {
	return _SequencerInbox.Contract.GetKeysetCreationBlock(&_SequencerInbox.CallOpts, ksHash)
}

// GetKeysetCreationBlock is a free data retrieval call binding the contract method 0x258f0495.
//
// Solidity: function getKeysetCreationBlock(bytes32 ksHash) view returns(uint256)
func (_SequencerInbox *SequencerInboxCallerSession) GetKeysetCreationBlock(ksHash [32]byte) (*big.Int, error) {
	return _SequencerInbox.Contract.GetKeysetCreationBlock(&_SequencerInbox.CallOpts, ksHash)
}

// InboxAccs is a free data retrieval call binding the contract method 0xd9dd67ab.
//
// Solidity: function inboxAccs(uint256 index) view returns(bytes32)
func (_SequencerInbox *SequencerInboxCaller) InboxAccs(opts *bind.CallOpts, index *big.Int) ([32]byte, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "inboxAccs", index)

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// InboxAccs is a free data retrieval call binding the contract method 0xd9dd67ab.
//
// Solidity: function inboxAccs(uint256 index) view returns(bytes32)
func (_SequencerInbox *SequencerInboxSession) InboxAccs(index *big.Int) ([32]byte, error) {
	return _SequencerInbox.Contract.InboxAccs(&_SequencerInbox.CallOpts, index)
}

// InboxAccs is a free data retrieval call binding the contract method 0xd9dd67ab.
//
// Solidity: function inboxAccs(uint256 index) view returns(bytes32)
func (_SequencerInbox *SequencerInboxCallerSession) InboxAccs(index *big.Int) ([32]byte, error) {
	return _SequencerInbox.Contract.InboxAccs(&_SequencerInbox.CallOpts, index)
}

// IsBatchPoster is a free data retrieval call binding the contract method 0x71c3e6fe.
//
// Solidity: function isBatchPoster(address ) view returns(bool)
func (_SequencerInbox *SequencerInboxCaller) IsBatchPoster(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "isBatchPoster", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsBatchPoster is a free data retrieval call binding the contract method 0x71c3e6fe.
//
// Solidity: function isBatchPoster(address ) view returns(bool)
func (_SequencerInbox *SequencerInboxSession) IsBatchPoster(arg0 common.Address) (bool, error) {
	return _SequencerInbox.Contract.IsBatchPoster(&_SequencerInbox.CallOpts, arg0)
}

// IsBatchPoster is a free data retrieval call binding the contract method 0x71c3e6fe.
//
// Solidity: function isBatchPoster(address ) view returns(bool)
func (_SequencerInbox *SequencerInboxCallerSession) IsBatchPoster(arg0 common.Address) (bool, error) {
	return _SequencerInbox.Contract.IsBatchPoster(&_SequencerInbox.CallOpts, arg0)
}

// IsDelayBufferable is a free data retrieval call binding the contract method 0x4b678a66.
//
// Solidity: function isDelayBufferable() view returns(bool)
func (_SequencerInbox *SequencerInboxCaller) IsDelayBufferable(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "isDelayBufferable")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsDelayBufferable is a free data retrieval call binding the contract method 0x4b678a66.
//
// Solidity: function isDelayBufferable() view returns(bool)
func (_SequencerInbox *SequencerInboxSession) IsDelayBufferable() (bool, error) {
	return _SequencerInbox.Contract.IsDelayBufferable(&_SequencerInbox.CallOpts)
}

// IsDelayBufferable is a free data retrieval call binding the contract method 0x4b678a66.
//
// Solidity: function isDelayBufferable() view returns(bool)
func (_SequencerInbox *SequencerInboxCallerSession) IsDelayBufferable() (bool, error) {
	return _SequencerInbox.Contract.IsDelayBufferable(&_SequencerInbox.CallOpts)
}

// IsSequencer is a free data retrieval call binding the contract method 0x6d46e987.
//
// Solidity: function isSequencer(address ) view returns(bool)
func (_SequencerInbox *SequencerInboxCaller) IsSequencer(opts *bind.CallOpts, arg0 common.Address) (bool, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "isSequencer", arg0)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsSequencer is a free data retrieval call binding the contract method 0x6d46e987.
//
// Solidity: function isSequencer(address ) view returns(bool)
func (_SequencerInbox *SequencerInboxSession) IsSequencer(arg0 common.Address) (bool, error) {
	return _SequencerInbox.Contract.IsSequencer(&_SequencerInbox.CallOpts, arg0)
}

// IsSequencer is a free data retrieval call binding the contract method 0x6d46e987.
//
// Solidity: function isSequencer(address ) view returns(bool)
func (_SequencerInbox *SequencerInboxCallerSession) IsSequencer(arg0 common.Address) (bool, error) {
	return _SequencerInbox.Contract.IsSequencer(&_SequencerInbox.CallOpts, arg0)
}

// IsUsingFeeToken is a free data retrieval call binding the contract method 0x92d9f782.
//
// Solidity: function isUsingFeeToken() view returns(bool)
func (_SequencerInbox *SequencerInboxCaller) IsUsingFeeToken(opts *bind.CallOpts) (bool, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "isUsingFeeToken")

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsUsingFeeToken is a free data retrieval call binding the contract method 0x92d9f782.
//
// Solidity: function isUsingFeeToken() view returns(bool)
func (_SequencerInbox *SequencerInboxSession) IsUsingFeeToken() (bool, error) {
	return _SequencerInbox.Contract.IsUsingFeeToken(&_SequencerInbox.CallOpts)
}

// IsUsingFeeToken is a free data retrieval call binding the contract method 0x92d9f782.
//
// Solidity: function isUsingFeeToken() view returns(bool)
func (_SequencerInbox *SequencerInboxCallerSession) IsUsingFeeToken() (bool, error) {
	return _SequencerInbox.Contract.IsUsingFeeToken(&_SequencerInbox.CallOpts)
}

// IsValidKeysetHash is a free data retrieval call binding the contract method 0x1637be48.
//
// Solidity: function isValidKeysetHash(bytes32 ksHash) view returns(bool)
func (_SequencerInbox *SequencerInboxCaller) IsValidKeysetHash(opts *bind.CallOpts, ksHash [32]byte) (bool, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "isValidKeysetHash", ksHash)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// IsValidKeysetHash is a free data retrieval call binding the contract method 0x1637be48.
//
// Solidity: function isValidKeysetHash(bytes32 ksHash) view returns(bool)
func (_SequencerInbox *SequencerInboxSession) IsValidKeysetHash(ksHash [32]byte) (bool, error) {
	return _SequencerInbox.Contract.IsValidKeysetHash(&_SequencerInbox.CallOpts, ksHash)
}

// IsValidKeysetHash is a free data retrieval call binding the contract method 0x1637be48.
//
// Solidity: function isValidKeysetHash(bytes32 ksHash) view returns(bool)
func (_SequencerInbox *SequencerInboxCallerSession) IsValidKeysetHash(ksHash [32]byte) (bool, error) {
	return _SequencerInbox.Contract.IsValidKeysetHash(&_SequencerInbox.CallOpts, ksHash)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_SequencerInbox *SequencerInboxCaller) MaxDataSize(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "maxDataSize")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_SequencerInbox *SequencerInboxSession) MaxDataSize() (*big.Int, error) {
	return _SequencerInbox.Contract.MaxDataSize(&_SequencerInbox.CallOpts)
}

// MaxDataSize is a free data retrieval call binding the contract method 0xe8eb1dc3.
//
// Solidity: function maxDataSize() view returns(uint256)
func (_SequencerInbox *SequencerInboxCallerSession) MaxDataSize() (*big.Int, error) {
	return _SequencerInbox.Contract.MaxDataSize(&_SequencerInbox.CallOpts)
}

// MaxTimeVariation is a free data retrieval call binding the contract method 0xebea461d.
//
// Solidity: function maxTimeVariation() view returns(uint256, uint256, uint256, uint256)
func (_SequencerInbox *SequencerInboxCaller) MaxTimeVariation(opts *bind.CallOpts) (*big.Int, *big.Int, *big.Int, *big.Int, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "maxTimeVariation")

	if err != nil {
		return *new(*big.Int), *new(*big.Int), *new(*big.Int), *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)
	out1 := *abi.ConvertType(out[1], new(*big.Int)).(**big.Int)
	out2 := *abi.ConvertType(out[2], new(*big.Int)).(**big.Int)
	out3 := *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)

	return out0, out1, out2, out3, err

}

// MaxTimeVariation is a free data retrieval call binding the contract method 0xebea461d.
//
// Solidity: function maxTimeVariation() view returns(uint256, uint256, uint256, uint256)
func (_SequencerInbox *SequencerInboxSession) MaxTimeVariation() (*big.Int, *big.Int, *big.Int, *big.Int, error) {
	return _SequencerInbox.Contract.MaxTimeVariation(&_SequencerInbox.CallOpts)
}

// MaxTimeVariation is a free data retrieval call binding the contract method 0xebea461d.
//
// Solidity: function maxTimeVariation() view returns(uint256, uint256, uint256, uint256)
func (_SequencerInbox *SequencerInboxCallerSession) MaxTimeVariation() (*big.Int, *big.Int, *big.Int, *big.Int, error) {
	return _SequencerInbox.Contract.MaxTimeVariation(&_SequencerInbox.CallOpts)
}

// Reader4844 is a free data retrieval call binding the contract method 0x8d910dde.
//
// Solidity: function reader4844() view returns(address)
func (_SequencerInbox *SequencerInboxCaller) Reader4844(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "reader4844")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Reader4844 is a free data retrieval call binding the contract method 0x8d910dde.
//
// Solidity: function reader4844() view returns(address)
func (_SequencerInbox *SequencerInboxSession) Reader4844() (common.Address, error) {
	return _SequencerInbox.Contract.Reader4844(&_SequencerInbox.CallOpts)
}

// Reader4844 is a free data retrieval call binding the contract method 0x8d910dde.
//
// Solidity: function reader4844() view returns(address)
func (_SequencerInbox *SequencerInboxCallerSession) Reader4844() (common.Address, error) {
	return _SequencerInbox.Contract.Reader4844(&_SequencerInbox.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_SequencerInbox *SequencerInboxCaller) Rollup(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "rollup")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_SequencerInbox *SequencerInboxSession) Rollup() (common.Address, error) {
	return _SequencerInbox.Contract.Rollup(&_SequencerInbox.CallOpts)
}

// Rollup is a free data retrieval call binding the contract method 0xcb23bcb5.
//
// Solidity: function rollup() view returns(address)
func (_SequencerInbox *SequencerInboxCallerSession) Rollup() (common.Address, error) {
	return _SequencerInbox.Contract.Rollup(&_SequencerInbox.CallOpts)
}

// TotalDelayedMessagesRead is a free data retrieval call binding the contract method 0x7fa3a40e.
//
// Solidity: function totalDelayedMessagesRead() view returns(uint256)
func (_SequencerInbox *SequencerInboxCaller) TotalDelayedMessagesRead(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _SequencerInbox.contract.Call(opts, &out, "totalDelayedMessagesRead")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalDelayedMessagesRead is a free data retrieval call binding the contract method 0x7fa3a40e.
//
// Solidity: function totalDelayedMessagesRead() view returns(uint256)
func (_SequencerInbox *SequencerInboxSession) TotalDelayedMessagesRead() (*big.Int, error) {
	return _SequencerInbox.Contract.TotalDelayedMessagesRead(&_SequencerInbox.CallOpts)
}

// TotalDelayedMessagesRead is a free data retrieval call binding the contract method 0x7fa3a40e.
//
// Solidity: function totalDelayedMessagesRead() view returns(uint256)
func (_SequencerInbox *SequencerInboxCallerSession) TotalDelayedMessagesRead() (*big.Int, error) {
	return _SequencerInbox.Contract.TotalDelayedMessagesRead(&_SequencerInbox.CallOpts)
}

// AddSequencerL2Batch is a paid mutator transaction binding the contract method 0xe0bc9729.
//
// Solidity: function addSequencerL2Batch(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_SequencerInbox *SequencerInboxTransactor) AddSequencerL2Batch(opts *bind.TransactOpts, sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "addSequencerL2Batch", sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2Batch is a paid mutator transaction binding the contract method 0xe0bc9729.
//
// Solidity: function addSequencerL2Batch(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_SequencerInbox *SequencerInboxSession) AddSequencerL2Batch(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _SequencerInbox.Contract.AddSequencerL2Batch(&_SequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2Batch is a paid mutator transaction binding the contract method 0xe0bc9729.
//
// Solidity: function addSequencerL2Batch(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) AddSequencerL2Batch(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _SequencerInbox.Contract.AddSequencerL2Batch(&_SequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchDelayProof is a paid mutator transaction binding the contract method 0x6e620055.
//
// Solidity: function addSequencerL2BatchDelayProof(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_SequencerInbox *SequencerInboxTransactor) AddSequencerL2BatchDelayProof(opts *bind.TransactOpts, sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "addSequencerL2BatchDelayProof", sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchDelayProof is a paid mutator transaction binding the contract method 0x6e620055.
//
// Solidity: function addSequencerL2BatchDelayProof(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_SequencerInbox *SequencerInboxSession) AddSequencerL2BatchDelayProof(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _SequencerInbox.Contract.AddSequencerL2BatchDelayProof(&_SequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchDelayProof is a paid mutator transaction binding the contract method 0x6e620055.
//
// Solidity: function addSequencerL2BatchDelayProof(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) AddSequencerL2BatchDelayProof(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _SequencerInbox.Contract.AddSequencerL2BatchDelayProof(&_SequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchFromBlobs is a paid mutator transaction binding the contract method 0x3e5aa082.
//
// Solidity: function addSequencerL2BatchFromBlobs(uint256 sequenceNumber, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_SequencerInbox *SequencerInboxTransactor) AddSequencerL2BatchFromBlobs(opts *bind.TransactOpts, sequenceNumber *big.Int, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "addSequencerL2BatchFromBlobs", sequenceNumber, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchFromBlobs is a paid mutator transaction binding the contract method 0x3e5aa082.
//
// Solidity: function addSequencerL2BatchFromBlobs(uint256 sequenceNumber, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_SequencerInbox *SequencerInboxSession) AddSequencerL2BatchFromBlobs(sequenceNumber *big.Int, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _SequencerInbox.Contract.AddSequencerL2BatchFromBlobs(&_SequencerInbox.TransactOpts, sequenceNumber, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchFromBlobs is a paid mutator transaction binding the contract method 0x3e5aa082.
//
// Solidity: function addSequencerL2BatchFromBlobs(uint256 sequenceNumber, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) AddSequencerL2BatchFromBlobs(sequenceNumber *big.Int, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _SequencerInbox.Contract.AddSequencerL2BatchFromBlobs(&_SequencerInbox.TransactOpts, sequenceNumber, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchFromBlobsDelayProof is a paid mutator transaction binding the contract method 0x917cf8ac.
//
// Solidity: function addSequencerL2BatchFromBlobsDelayProof(uint256 sequenceNumber, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_SequencerInbox *SequencerInboxTransactor) AddSequencerL2BatchFromBlobsDelayProof(opts *bind.TransactOpts, sequenceNumber *big.Int, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "addSequencerL2BatchFromBlobsDelayProof", sequenceNumber, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchFromBlobsDelayProof is a paid mutator transaction binding the contract method 0x917cf8ac.
//
// Solidity: function addSequencerL2BatchFromBlobsDelayProof(uint256 sequenceNumber, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_SequencerInbox *SequencerInboxSession) AddSequencerL2BatchFromBlobsDelayProof(sequenceNumber *big.Int, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _SequencerInbox.Contract.AddSequencerL2BatchFromBlobsDelayProof(&_SequencerInbox.TransactOpts, sequenceNumber, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchFromBlobsDelayProof is a paid mutator transaction binding the contract method 0x917cf8ac.
//
// Solidity: function addSequencerL2BatchFromBlobsDelayProof(uint256 sequenceNumber, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) AddSequencerL2BatchFromBlobsDelayProof(sequenceNumber *big.Int, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _SequencerInbox.Contract.AddSequencerL2BatchFromBlobsDelayProof(&_SequencerInbox.TransactOpts, sequenceNumber, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchFromOrigin8f111f3c is a paid mutator transaction binding the contract method 0x8f111f3c.
//
// Solidity: function addSequencerL2BatchFromOrigin(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_SequencerInbox *SequencerInboxTransactor) AddSequencerL2BatchFromOrigin8f111f3c(opts *bind.TransactOpts, sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "addSequencerL2BatchFromOrigin0", sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchFromOrigin8f111f3c is a paid mutator transaction binding the contract method 0x8f111f3c.
//
// Solidity: function addSequencerL2BatchFromOrigin(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_SequencerInbox *SequencerInboxSession) AddSequencerL2BatchFromOrigin8f111f3c(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _SequencerInbox.Contract.AddSequencerL2BatchFromOrigin8f111f3c(&_SequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchFromOrigin8f111f3c is a paid mutator transaction binding the contract method 0x8f111f3c.
//
// Solidity: function addSequencerL2BatchFromOrigin(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) AddSequencerL2BatchFromOrigin8f111f3c(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int) (*types.Transaction, error) {
	return _SequencerInbox.Contract.AddSequencerL2BatchFromOrigin8f111f3c(&_SequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount)
}

// AddSequencerL2BatchFromOriginDelayProof is a paid mutator transaction binding the contract method 0x69cacded.
//
// Solidity: function addSequencerL2BatchFromOriginDelayProof(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_SequencerInbox *SequencerInboxTransactor) AddSequencerL2BatchFromOriginDelayProof(opts *bind.TransactOpts, sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "addSequencerL2BatchFromOriginDelayProof", sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchFromOriginDelayProof is a paid mutator transaction binding the contract method 0x69cacded.
//
// Solidity: function addSequencerL2BatchFromOriginDelayProof(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_SequencerInbox *SequencerInboxSession) AddSequencerL2BatchFromOriginDelayProof(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _SequencerInbox.Contract.AddSequencerL2BatchFromOriginDelayProof(&_SequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// AddSequencerL2BatchFromOriginDelayProof is a paid mutator transaction binding the contract method 0x69cacded.
//
// Solidity: function addSequencerL2BatchFromOriginDelayProof(uint256 sequenceNumber, bytes data, uint256 afterDelayedMessagesRead, address gasRefunder, uint256 prevMessageCount, uint256 newMessageCount, (bytes32,(uint8,address,uint64,uint64,uint256,uint256,bytes32)) delayProof) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) AddSequencerL2BatchFromOriginDelayProof(sequenceNumber *big.Int, data []byte, afterDelayedMessagesRead *big.Int, gasRefunder common.Address, prevMessageCount *big.Int, newMessageCount *big.Int, delayProof DelayProof) (*types.Transaction, error) {
	return _SequencerInbox.Contract.AddSequencerL2BatchFromOriginDelayProof(&_SequencerInbox.TransactOpts, sequenceNumber, data, afterDelayedMessagesRead, gasRefunder, prevMessageCount, newMessageCount, delayProof)
}

// ForceInclusion is a paid mutator transaction binding the contract method 0xf1981578.
//
// Solidity: function forceInclusion(uint256 _totalDelayedMessagesRead, uint8 kind, uint64[2] l1BlockAndTime, uint256 baseFeeL1, address sender, bytes32 messageDataHash) returns()
func (_SequencerInbox *SequencerInboxTransactor) ForceInclusion(opts *bind.TransactOpts, _totalDelayedMessagesRead *big.Int, kind uint8, l1BlockAndTime [2]uint64, baseFeeL1 *big.Int, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "forceInclusion", _totalDelayedMessagesRead, kind, l1BlockAndTime, baseFeeL1, sender, messageDataHash)
}

// ForceInclusion is a paid mutator transaction binding the contract method 0xf1981578.
//
// Solidity: function forceInclusion(uint256 _totalDelayedMessagesRead, uint8 kind, uint64[2] l1BlockAndTime, uint256 baseFeeL1, address sender, bytes32 messageDataHash) returns()
func (_SequencerInbox *SequencerInboxSession) ForceInclusion(_totalDelayedMessagesRead *big.Int, kind uint8, l1BlockAndTime [2]uint64, baseFeeL1 *big.Int, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _SequencerInbox.Contract.ForceInclusion(&_SequencerInbox.TransactOpts, _totalDelayedMessagesRead, kind, l1BlockAndTime, baseFeeL1, sender, messageDataHash)
}

// ForceInclusion is a paid mutator transaction binding the contract method 0xf1981578.
//
// Solidity: function forceInclusion(uint256 _totalDelayedMessagesRead, uint8 kind, uint64[2] l1BlockAndTime, uint256 baseFeeL1, address sender, bytes32 messageDataHash) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) ForceInclusion(_totalDelayedMessagesRead *big.Int, kind uint8, l1BlockAndTime [2]uint64, baseFeeL1 *big.Int, sender common.Address, messageDataHash [32]byte) (*types.Transaction, error) {
	return _SequencerInbox.Contract.ForceInclusion(&_SequencerInbox.TransactOpts, _totalDelayedMessagesRead, kind, l1BlockAndTime, baseFeeL1, sender, messageDataHash)
}

// Initialize is a paid mutator transaction binding the contract method 0xa84840b7.
//
// Solidity: function initialize(address bridge_, (uint256,uint256,uint256,uint256) maxTimeVariation_, (uint64,uint64,uint64) bufferConfig_, address feeTokenPricer_) returns()
func (_SequencerInbox *SequencerInboxTransactor) Initialize(opts *bind.TransactOpts, bridge_ common.Address, maxTimeVariation_ ISequencerInboxMaxTimeVariation, bufferConfig_ BufferConfig, feeTokenPricer_ common.Address) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "initialize", bridge_, maxTimeVariation_, bufferConfig_, feeTokenPricer_)
}

// Initialize is a paid mutator transaction binding the contract method 0xa84840b7.
//
// Solidity: function initialize(address bridge_, (uint256,uint256,uint256,uint256) maxTimeVariation_, (uint64,uint64,uint64) bufferConfig_, address feeTokenPricer_) returns()
func (_SequencerInbox *SequencerInboxSession) Initialize(bridge_ common.Address, maxTimeVariation_ ISequencerInboxMaxTimeVariation, bufferConfig_ BufferConfig, feeTokenPricer_ common.Address) (*types.Transaction, error) {
	return _SequencerInbox.Contract.Initialize(&_SequencerInbox.TransactOpts, bridge_, maxTimeVariation_, bufferConfig_, feeTokenPricer_)
}

// Initialize is a paid mutator transaction binding the contract method 0xa84840b7.
//
// Solidity: function initialize(address bridge_, (uint256,uint256,uint256,uint256) maxTimeVariation_, (uint64,uint64,uint64) bufferConfig_, address feeTokenPricer_) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) Initialize(bridge_ common.Address, maxTimeVariation_ ISequencerInboxMaxTimeVariation, bufferConfig_ BufferConfig, feeTokenPricer_ common.Address) (*types.Transaction, error) {
	return _SequencerInbox.Contract.Initialize(&_SequencerInbox.TransactOpts, bridge_, maxTimeVariation_, bufferConfig_, feeTokenPricer_)
}

// InvalidateKeysetHash is a paid mutator transaction binding the contract method 0x84420860.
//
// Solidity: function invalidateKeysetHash(bytes32 ksHash) returns()
func (_SequencerInbox *SequencerInboxTransactor) InvalidateKeysetHash(opts *bind.TransactOpts, ksHash [32]byte) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "invalidateKeysetHash", ksHash)
}

// InvalidateKeysetHash is a paid mutator transaction binding the contract method 0x84420860.
//
// Solidity: function invalidateKeysetHash(bytes32 ksHash) returns()
func (_SequencerInbox *SequencerInboxSession) InvalidateKeysetHash(ksHash [32]byte) (*types.Transaction, error) {
	return _SequencerInbox.Contract.InvalidateKeysetHash(&_SequencerInbox.TransactOpts, ksHash)
}

// InvalidateKeysetHash is a paid mutator transaction binding the contract method 0x84420860.
//
// Solidity: function invalidateKeysetHash(bytes32 ksHash) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) InvalidateKeysetHash(ksHash [32]byte) (*types.Transaction, error) {
	return _SequencerInbox.Contract.InvalidateKeysetHash(&_SequencerInbox.TransactOpts, ksHash)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0xa655d937.
//
// Solidity: function postUpgradeInit((uint64,uint64,uint64) bufferConfig_) returns()
func (_SequencerInbox *SequencerInboxTransactor) PostUpgradeInit(opts *bind.TransactOpts, bufferConfig_ BufferConfig) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "postUpgradeInit", bufferConfig_)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0xa655d937.
//
// Solidity: function postUpgradeInit((uint64,uint64,uint64) bufferConfig_) returns()
func (_SequencerInbox *SequencerInboxSession) PostUpgradeInit(bufferConfig_ BufferConfig) (*types.Transaction, error) {
	return _SequencerInbox.Contract.PostUpgradeInit(&_SequencerInbox.TransactOpts, bufferConfig_)
}

// PostUpgradeInit is a paid mutator transaction binding the contract method 0xa655d937.
//
// Solidity: function postUpgradeInit((uint64,uint64,uint64) bufferConfig_) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) PostUpgradeInit(bufferConfig_ BufferConfig) (*types.Transaction, error) {
	return _SequencerInbox.Contract.PostUpgradeInit(&_SequencerInbox.TransactOpts, bufferConfig_)
}

// RemoveDelayAfterFork is a paid mutator transaction binding the contract method 0x96cc5c78.
//
// Solidity: function removeDelayAfterFork() returns()
func (_SequencerInbox *SequencerInboxTransactor) RemoveDelayAfterFork(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "removeDelayAfterFork")
}

// RemoveDelayAfterFork is a paid mutator transaction binding the contract method 0x96cc5c78.
//
// Solidity: function removeDelayAfterFork() returns()
func (_SequencerInbox *SequencerInboxSession) RemoveDelayAfterFork() (*types.Transaction, error) {
	return _SequencerInbox.Contract.RemoveDelayAfterFork(&_SequencerInbox.TransactOpts)
}

// RemoveDelayAfterFork is a paid mutator transaction binding the contract method 0x96cc5c78.
//
// Solidity: function removeDelayAfterFork() returns()
func (_SequencerInbox *SequencerInboxTransactorSession) RemoveDelayAfterFork() (*types.Transaction, error) {
	return _SequencerInbox.Contract.RemoveDelayAfterFork(&_SequencerInbox.TransactOpts)
}

// SetBatchPosterManager is a paid mutator transaction binding the contract method 0x1ff64790.
//
// Solidity: function setBatchPosterManager(address newBatchPosterManager) returns()
func (_SequencerInbox *SequencerInboxTransactor) SetBatchPosterManager(opts *bind.TransactOpts, newBatchPosterManager common.Address) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "setBatchPosterManager", newBatchPosterManager)
}

// SetBatchPosterManager is a paid mutator transaction binding the contract method 0x1ff64790.
//
// Solidity: function setBatchPosterManager(address newBatchPosterManager) returns()
func (_SequencerInbox *SequencerInboxSession) SetBatchPosterManager(newBatchPosterManager common.Address) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetBatchPosterManager(&_SequencerInbox.TransactOpts, newBatchPosterManager)
}

// SetBatchPosterManager is a paid mutator transaction binding the contract method 0x1ff64790.
//
// Solidity: function setBatchPosterManager(address newBatchPosterManager) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) SetBatchPosterManager(newBatchPosterManager common.Address) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetBatchPosterManager(&_SequencerInbox.TransactOpts, newBatchPosterManager)
}

// SetBufferConfig is a paid mutator transaction binding the contract method 0x2f3985a7.
//
// Solidity: function setBufferConfig((uint64,uint64,uint64) bufferConfig_) returns()
func (_SequencerInbox *SequencerInboxTransactor) SetBufferConfig(opts *bind.TransactOpts, bufferConfig_ BufferConfig) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "setBufferConfig", bufferConfig_)
}

// SetBufferConfig is a paid mutator transaction binding the contract method 0x2f3985a7.
//
// Solidity: function setBufferConfig((uint64,uint64,uint64) bufferConfig_) returns()
func (_SequencerInbox *SequencerInboxSession) SetBufferConfig(bufferConfig_ BufferConfig) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetBufferConfig(&_SequencerInbox.TransactOpts, bufferConfig_)
}

// SetBufferConfig is a paid mutator transaction binding the contract method 0x2f3985a7.
//
// Solidity: function setBufferConfig((uint64,uint64,uint64) bufferConfig_) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) SetBufferConfig(bufferConfig_ BufferConfig) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetBufferConfig(&_SequencerInbox.TransactOpts, bufferConfig_)
}

// SetFeeTokenPricer is a paid mutator transaction binding the contract method 0x036f7ed3.
//
// Solidity: function setFeeTokenPricer(address feeTokenPricer_) returns()
func (_SequencerInbox *SequencerInboxTransactor) SetFeeTokenPricer(opts *bind.TransactOpts, feeTokenPricer_ common.Address) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "setFeeTokenPricer", feeTokenPricer_)
}

// SetFeeTokenPricer is a paid mutator transaction binding the contract method 0x036f7ed3.
//
// Solidity: function setFeeTokenPricer(address feeTokenPricer_) returns()
func (_SequencerInbox *SequencerInboxSession) SetFeeTokenPricer(feeTokenPricer_ common.Address) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetFeeTokenPricer(&_SequencerInbox.TransactOpts, feeTokenPricer_)
}

// SetFeeTokenPricer is a paid mutator transaction binding the contract method 0x036f7ed3.
//
// Solidity: function setFeeTokenPricer(address feeTokenPricer_) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) SetFeeTokenPricer(feeTokenPricer_ common.Address) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetFeeTokenPricer(&_SequencerInbox.TransactOpts, feeTokenPricer_)
}

// SetIsBatchPoster is a paid mutator transaction binding the contract method 0x6e7df3e7.
//
// Solidity: function setIsBatchPoster(address addr, bool isBatchPoster_) returns()
func (_SequencerInbox *SequencerInboxTransactor) SetIsBatchPoster(opts *bind.TransactOpts, addr common.Address, isBatchPoster_ bool) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "setIsBatchPoster", addr, isBatchPoster_)
}

// SetIsBatchPoster is a paid mutator transaction binding the contract method 0x6e7df3e7.
//
// Solidity: function setIsBatchPoster(address addr, bool isBatchPoster_) returns()
func (_SequencerInbox *SequencerInboxSession) SetIsBatchPoster(addr common.Address, isBatchPoster_ bool) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetIsBatchPoster(&_SequencerInbox.TransactOpts, addr, isBatchPoster_)
}

// SetIsBatchPoster is a paid mutator transaction binding the contract method 0x6e7df3e7.
//
// Solidity: function setIsBatchPoster(address addr, bool isBatchPoster_) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) SetIsBatchPoster(addr common.Address, isBatchPoster_ bool) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetIsBatchPoster(&_SequencerInbox.TransactOpts, addr, isBatchPoster_)
}

// SetIsSequencer is a paid mutator transaction binding the contract method 0x1f956632.
//
// Solidity: function setIsSequencer(address addr, bool isSequencer_) returns()
func (_SequencerInbox *SequencerInboxTransactor) SetIsSequencer(opts *bind.TransactOpts, addr common.Address, isSequencer_ bool) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "setIsSequencer", addr, isSequencer_)
}

// SetIsSequencer is a paid mutator transaction binding the contract method 0x1f956632.
//
// Solidity: function setIsSequencer(address addr, bool isSequencer_) returns()
func (_SequencerInbox *SequencerInboxSession) SetIsSequencer(addr common.Address, isSequencer_ bool) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetIsSequencer(&_SequencerInbox.TransactOpts, addr, isSequencer_)
}

// SetIsSequencer is a paid mutator transaction binding the contract method 0x1f956632.
//
// Solidity: function setIsSequencer(address addr, bool isSequencer_) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) SetIsSequencer(addr common.Address, isSequencer_ bool) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetIsSequencer(&_SequencerInbox.TransactOpts, addr, isSequencer_)
}

// SetMaxTimeVariation is a paid mutator transaction binding the contract method 0xb31761f8.
//
// Solidity: function setMaxTimeVariation((uint256,uint256,uint256,uint256) maxTimeVariation_) returns()
func (_SequencerInbox *SequencerInboxTransactor) SetMaxTimeVariation(opts *bind.TransactOpts, maxTimeVariation_ ISequencerInboxMaxTimeVariation) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "setMaxTimeVariation", maxTimeVariation_)
}

// SetMaxTimeVariation is a paid mutator transaction binding the contract method 0xb31761f8.
//
// Solidity: function setMaxTimeVariation((uint256,uint256,uint256,uint256) maxTimeVariation_) returns()
func (_SequencerInbox *SequencerInboxSession) SetMaxTimeVariation(maxTimeVariation_ ISequencerInboxMaxTimeVariation) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetMaxTimeVariation(&_SequencerInbox.TransactOpts, maxTimeVariation_)
}

// SetMaxTimeVariation is a paid mutator transaction binding the contract method 0xb31761f8.
//
// Solidity: function setMaxTimeVariation((uint256,uint256,uint256,uint256) maxTimeVariation_) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) SetMaxTimeVariation(maxTimeVariation_ ISequencerInboxMaxTimeVariation) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetMaxTimeVariation(&_SequencerInbox.TransactOpts, maxTimeVariation_)
}

// SetValidKeyset is a paid mutator transaction binding the contract method 0xd1ce8da8.
//
// Solidity: function setValidKeyset(bytes keysetBytes) returns()
func (_SequencerInbox *SequencerInboxTransactor) SetValidKeyset(opts *bind.TransactOpts, keysetBytes []byte) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "setValidKeyset", keysetBytes)
}

// SetValidKeyset is a paid mutator transaction binding the contract method 0xd1ce8da8.
//
// Solidity: function setValidKeyset(bytes keysetBytes) returns()
func (_SequencerInbox *SequencerInboxSession) SetValidKeyset(keysetBytes []byte) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetValidKeyset(&_SequencerInbox.TransactOpts, keysetBytes)
}

// SetValidKeyset is a paid mutator transaction binding the contract method 0xd1ce8da8.
//
// Solidity: function setValidKeyset(bytes keysetBytes) returns()
func (_SequencerInbox *SequencerInboxTransactorSession) SetValidKeyset(keysetBytes []byte) (*types.Transaction, error) {
	return _SequencerInbox.Contract.SetValidKeyset(&_SequencerInbox.TransactOpts, keysetBytes)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_SequencerInbox *SequencerInboxTransactor) UpdateRollupAddress(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SequencerInbox.contract.Transact(opts, "updateRollupAddress")
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_SequencerInbox *SequencerInboxSession) UpdateRollupAddress() (*types.Transaction, error) {
	return _SequencerInbox.Contract.UpdateRollupAddress(&_SequencerInbox.TransactOpts)
}

// UpdateRollupAddress is a paid mutator transaction binding the contract method 0x6ae71f12.
//
// Solidity: function updateRollupAddress() returns()
func (_SequencerInbox *SequencerInboxTransactorSession) UpdateRollupAddress() (*types.Transaction, error) {
	return _SequencerInbox.Contract.UpdateRollupAddress(&_SequencerInbox.TransactOpts)
}

// SequencerInboxBatchPosterManagerSetIterator is returned from FilterBatchPosterManagerSet and is used to iterate over the raw logs and unpacked data for BatchPosterManagerSet events raised by the SequencerInbox contract.
type SequencerInboxBatchPosterManagerSetIterator struct {
	Event *SequencerInboxBatchPosterManagerSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxBatchPosterManagerSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxBatchPosterManagerSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxBatchPosterManagerSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxBatchPosterManagerSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxBatchPosterManagerSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxBatchPosterManagerSet represents a BatchPosterManagerSet event raised by the SequencerInbox contract.
type SequencerInboxBatchPosterManagerSet struct {
	NewBatchPosterManager common.Address
	Raw                   types.Log // Blockchain specific contextual infos
}

// FilterBatchPosterManagerSet is a free log retrieval operation binding the contract event 0x3cd6c184800297a0f2b00926a683cbe76890bb7fd01480ac0a10ed6c8f7f6659.
//
// Solidity: event BatchPosterManagerSet(address newBatchPosterManager)
func (_SequencerInbox *SequencerInboxFilterer) FilterBatchPosterManagerSet(opts *bind.FilterOpts) (*SequencerInboxBatchPosterManagerSetIterator, error) {

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "BatchPosterManagerSet")
	if err != nil {
		return nil, err
	}
	return &SequencerInboxBatchPosterManagerSetIterator{contract: _SequencerInbox.contract, event: "BatchPosterManagerSet", logs: logs, sub: sub}, nil
}

// WatchBatchPosterManagerSet is a free log subscription operation binding the contract event 0x3cd6c184800297a0f2b00926a683cbe76890bb7fd01480ac0a10ed6c8f7f6659.
//
// Solidity: event BatchPosterManagerSet(address newBatchPosterManager)
func (_SequencerInbox *SequencerInboxFilterer) WatchBatchPosterManagerSet(opts *bind.WatchOpts, sink chan<- *SequencerInboxBatchPosterManagerSet) (event.Subscription, error) {

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "BatchPosterManagerSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxBatchPosterManagerSet)
				if err := _SequencerInbox.contract.UnpackLog(event, "BatchPosterManagerSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBatchPosterManagerSet is a log parse operation binding the contract event 0x3cd6c184800297a0f2b00926a683cbe76890bb7fd01480ac0a10ed6c8f7f6659.
//
// Solidity: event BatchPosterManagerSet(address newBatchPosterManager)
func (_SequencerInbox *SequencerInboxFilterer) ParseBatchPosterManagerSet(log types.Log) (*SequencerInboxBatchPosterManagerSet, error) {
	event := new(SequencerInboxBatchPosterManagerSet)
	if err := _SequencerInbox.contract.UnpackLog(event, "BatchPosterManagerSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxBatchPosterSetIterator is returned from FilterBatchPosterSet and is used to iterate over the raw logs and unpacked data for BatchPosterSet events raised by the SequencerInbox contract.
type SequencerInboxBatchPosterSetIterator struct {
	Event *SequencerInboxBatchPosterSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxBatchPosterSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxBatchPosterSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxBatchPosterSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxBatchPosterSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxBatchPosterSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxBatchPosterSet represents a BatchPosterSet event raised by the SequencerInbox contract.
type SequencerInboxBatchPosterSet struct {
	BatchPoster   common.Address
	IsBatchPoster bool
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterBatchPosterSet is a free log retrieval operation binding the contract event 0x28bcc5626d357efe966b4b0876aa1ee8ab99e26da4f131f6a2623f1800701c21.
//
// Solidity: event BatchPosterSet(address batchPoster, bool isBatchPoster)
func (_SequencerInbox *SequencerInboxFilterer) FilterBatchPosterSet(opts *bind.FilterOpts) (*SequencerInboxBatchPosterSetIterator, error) {

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "BatchPosterSet")
	if err != nil {
		return nil, err
	}
	return &SequencerInboxBatchPosterSetIterator{contract: _SequencerInbox.contract, event: "BatchPosterSet", logs: logs, sub: sub}, nil
}

// WatchBatchPosterSet is a free log subscription operation binding the contract event 0x28bcc5626d357efe966b4b0876aa1ee8ab99e26da4f131f6a2623f1800701c21.
//
// Solidity: event BatchPosterSet(address batchPoster, bool isBatchPoster)
func (_SequencerInbox *SequencerInboxFilterer) WatchBatchPosterSet(opts *bind.WatchOpts, sink chan<- *SequencerInboxBatchPosterSet) (event.Subscription, error) {

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "BatchPosterSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxBatchPosterSet)
				if err := _SequencerInbox.contract.UnpackLog(event, "BatchPosterSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBatchPosterSet is a log parse operation binding the contract event 0x28bcc5626d357efe966b4b0876aa1ee8ab99e26da4f131f6a2623f1800701c21.
//
// Solidity: event BatchPosterSet(address batchPoster, bool isBatchPoster)
func (_SequencerInbox *SequencerInboxFilterer) ParseBatchPosterSet(log types.Log) (*SequencerInboxBatchPosterSet, error) {
	event := new(SequencerInboxBatchPosterSet)
	if err := _SequencerInbox.contract.UnpackLog(event, "BatchPosterSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxBufferConfigSetIterator is returned from FilterBufferConfigSet and is used to iterate over the raw logs and unpacked data for BufferConfigSet events raised by the SequencerInbox contract.
type SequencerInboxBufferConfigSetIterator struct {
	Event *SequencerInboxBufferConfigSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxBufferConfigSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxBufferConfigSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxBufferConfigSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxBufferConfigSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxBufferConfigSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxBufferConfigSet represents a BufferConfigSet event raised by the SequencerInbox contract.
type SequencerInboxBufferConfigSet struct {
	BufferConfig BufferConfig
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterBufferConfigSet is a free log retrieval operation binding the contract event 0xaa7a2d8175dee3b637814ad6346005dfcc357165396fb8327f649effe8abcf85.
//
// Solidity: event BufferConfigSet((uint64,uint64,uint64) bufferConfig)
func (_SequencerInbox *SequencerInboxFilterer) FilterBufferConfigSet(opts *bind.FilterOpts) (*SequencerInboxBufferConfigSetIterator, error) {

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "BufferConfigSet")
	if err != nil {
		return nil, err
	}
	return &SequencerInboxBufferConfigSetIterator{contract: _SequencerInbox.contract, event: "BufferConfigSet", logs: logs, sub: sub}, nil
}

// WatchBufferConfigSet is a free log subscription operation binding the contract event 0xaa7a2d8175dee3b637814ad6346005dfcc357165396fb8327f649effe8abcf85.
//
// Solidity: event BufferConfigSet((uint64,uint64,uint64) bufferConfig)
func (_SequencerInbox *SequencerInboxFilterer) WatchBufferConfigSet(opts *bind.WatchOpts, sink chan<- *SequencerInboxBufferConfigSet) (event.Subscription, error) {

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "BufferConfigSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxBufferConfigSet)
				if err := _SequencerInbox.contract.UnpackLog(event, "BufferConfigSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBufferConfigSet is a log parse operation binding the contract event 0xaa7a2d8175dee3b637814ad6346005dfcc357165396fb8327f649effe8abcf85.
//
// Solidity: event BufferConfigSet((uint64,uint64,uint64) bufferConfig)
func (_SequencerInbox *SequencerInboxFilterer) ParseBufferConfigSet(log types.Log) (*SequencerInboxBufferConfigSet, error) {
	event := new(SequencerInboxBufferConfigSet)
	if err := _SequencerInbox.contract.UnpackLog(event, "BufferConfigSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxFeeTokenPricerSetIterator is returned from FilterFeeTokenPricerSet and is used to iterate over the raw logs and unpacked data for FeeTokenPricerSet events raised by the SequencerInbox contract.
type SequencerInboxFeeTokenPricerSetIterator struct {
	Event *SequencerInboxFeeTokenPricerSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxFeeTokenPricerSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxFeeTokenPricerSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxFeeTokenPricerSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxFeeTokenPricerSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxFeeTokenPricerSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxFeeTokenPricerSet represents a FeeTokenPricerSet event raised by the SequencerInbox contract.
type SequencerInboxFeeTokenPricerSet struct {
	FeeTokenPricer common.Address
	Raw            types.Log // Blockchain specific contextual infos
}

// FilterFeeTokenPricerSet is a free log retrieval operation binding the contract event 0xe83d6153add50e41b8ee6c1115c4178687349bb12bc3902a50b1f6ad78a0c541.
//
// Solidity: event FeeTokenPricerSet(address feeTokenPricer)
func (_SequencerInbox *SequencerInboxFilterer) FilterFeeTokenPricerSet(opts *bind.FilterOpts) (*SequencerInboxFeeTokenPricerSetIterator, error) {

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "FeeTokenPricerSet")
	if err != nil {
		return nil, err
	}
	return &SequencerInboxFeeTokenPricerSetIterator{contract: _SequencerInbox.contract, event: "FeeTokenPricerSet", logs: logs, sub: sub}, nil
}

// WatchFeeTokenPricerSet is a free log subscription operation binding the contract event 0xe83d6153add50e41b8ee6c1115c4178687349bb12bc3902a50b1f6ad78a0c541.
//
// Solidity: event FeeTokenPricerSet(address feeTokenPricer)
func (_SequencerInbox *SequencerInboxFilterer) WatchFeeTokenPricerSet(opts *bind.WatchOpts, sink chan<- *SequencerInboxFeeTokenPricerSet) (event.Subscription, error) {

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "FeeTokenPricerSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxFeeTokenPricerSet)
				if err := _SequencerInbox.contract.UnpackLog(event, "FeeTokenPricerSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseFeeTokenPricerSet is a log parse operation binding the contract event 0xe83d6153add50e41b8ee6c1115c4178687349bb12bc3902a50b1f6ad78a0c541.
//
// Solidity: event FeeTokenPricerSet(address feeTokenPricer)
func (_SequencerInbox *SequencerInboxFilterer) ParseFeeTokenPricerSet(log types.Log) (*SequencerInboxFeeTokenPricerSet, error) {
	event := new(SequencerInboxFeeTokenPricerSet)
	if err := _SequencerInbox.contract.UnpackLog(event, "FeeTokenPricerSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxInboxMessageDeliveredIterator is returned from FilterInboxMessageDelivered and is used to iterate over the raw logs and unpacked data for InboxMessageDelivered events raised by the SequencerInbox contract.
type SequencerInboxInboxMessageDeliveredIterator struct {
	Event *SequencerInboxInboxMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxInboxMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxInboxMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxInboxMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxInboxMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxInboxMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxInboxMessageDelivered represents a InboxMessageDelivered event raised by the SequencerInbox contract.
type SequencerInboxInboxMessageDelivered struct {
	MessageNum *big.Int
	Data       []byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDelivered is a free log retrieval operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_SequencerInbox *SequencerInboxFilterer) FilterInboxMessageDelivered(opts *bind.FilterOpts, messageNum []*big.Int) (*SequencerInboxInboxMessageDeliveredIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &SequencerInboxInboxMessageDeliveredIterator{contract: _SequencerInbox.contract, event: "InboxMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDelivered is a free log subscription operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_SequencerInbox *SequencerInboxFilterer) WatchInboxMessageDelivered(opts *bind.WatchOpts, sink chan<- *SequencerInboxInboxMessageDelivered, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "InboxMessageDelivered", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxInboxMessageDelivered)
				if err := _SequencerInbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDelivered is a log parse operation binding the contract event 0xff64905f73a67fb594e0f940a8075a860db489ad991e032f48c81123eb52d60b.
//
// Solidity: event InboxMessageDelivered(uint256 indexed messageNum, bytes data)
func (_SequencerInbox *SequencerInboxFilterer) ParseInboxMessageDelivered(log types.Log) (*SequencerInboxInboxMessageDelivered, error) {
	event := new(SequencerInboxInboxMessageDelivered)
	if err := _SequencerInbox.contract.UnpackLog(event, "InboxMessageDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxInboxMessageDeliveredFromOriginIterator is returned from FilterInboxMessageDeliveredFromOrigin and is used to iterate over the raw logs and unpacked data for InboxMessageDeliveredFromOrigin events raised by the SequencerInbox contract.
type SequencerInboxInboxMessageDeliveredFromOriginIterator struct {
	Event *SequencerInboxInboxMessageDeliveredFromOrigin // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxInboxMessageDeliveredFromOriginIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxInboxMessageDeliveredFromOrigin)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxInboxMessageDeliveredFromOrigin)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxInboxMessageDeliveredFromOriginIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxInboxMessageDeliveredFromOriginIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxInboxMessageDeliveredFromOrigin represents a InboxMessageDeliveredFromOrigin event raised by the SequencerInbox contract.
type SequencerInboxInboxMessageDeliveredFromOrigin struct {
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInboxMessageDeliveredFromOrigin is a free log retrieval operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_SequencerInbox *SequencerInboxFilterer) FilterInboxMessageDeliveredFromOrigin(opts *bind.FilterOpts, messageNum []*big.Int) (*SequencerInboxInboxMessageDeliveredFromOriginIterator, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return &SequencerInboxInboxMessageDeliveredFromOriginIterator{contract: _SequencerInbox.contract, event: "InboxMessageDeliveredFromOrigin", logs: logs, sub: sub}, nil
}

// WatchInboxMessageDeliveredFromOrigin is a free log subscription operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_SequencerInbox *SequencerInboxFilterer) WatchInboxMessageDeliveredFromOrigin(opts *bind.WatchOpts, sink chan<- *SequencerInboxInboxMessageDeliveredFromOrigin, messageNum []*big.Int) (event.Subscription, error) {

	var messageNumRule []interface{}
	for _, messageNumItem := range messageNum {
		messageNumRule = append(messageNumRule, messageNumItem)
	}

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "InboxMessageDeliveredFromOrigin", messageNumRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxInboxMessageDeliveredFromOrigin)
				if err := _SequencerInbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInboxMessageDeliveredFromOrigin is a log parse operation binding the contract event 0xab532385be8f1005a4b6ba8fa20a2245facb346134ac739fe9a5198dc1580b9c.
//
// Solidity: event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum)
func (_SequencerInbox *SequencerInboxFilterer) ParseInboxMessageDeliveredFromOrigin(log types.Log) (*SequencerInboxInboxMessageDeliveredFromOrigin, error) {
	event := new(SequencerInboxInboxMessageDeliveredFromOrigin)
	if err := _SequencerInbox.contract.UnpackLog(event, "InboxMessageDeliveredFromOrigin", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxInvalidateKeysetIterator is returned from FilterInvalidateKeyset and is used to iterate over the raw logs and unpacked data for InvalidateKeyset events raised by the SequencerInbox contract.
type SequencerInboxInvalidateKeysetIterator struct {
	Event *SequencerInboxInvalidateKeyset // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxInvalidateKeysetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxInvalidateKeyset)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxInvalidateKeyset)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxInvalidateKeysetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxInvalidateKeysetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxInvalidateKeyset represents a InvalidateKeyset event raised by the SequencerInbox contract.
type SequencerInboxInvalidateKeyset struct {
	KeysetHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterInvalidateKeyset is a free log retrieval operation binding the contract event 0x5cb4218b272fd214168ac43e90fb4d05d6c36f0b17ffb4c2dd07c234d744eb2a.
//
// Solidity: event InvalidateKeyset(bytes32 indexed keysetHash)
func (_SequencerInbox *SequencerInboxFilterer) FilterInvalidateKeyset(opts *bind.FilterOpts, keysetHash [][32]byte) (*SequencerInboxInvalidateKeysetIterator, error) {

	var keysetHashRule []interface{}
	for _, keysetHashItem := range keysetHash {
		keysetHashRule = append(keysetHashRule, keysetHashItem)
	}

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "InvalidateKeyset", keysetHashRule)
	if err != nil {
		return nil, err
	}
	return &SequencerInboxInvalidateKeysetIterator{contract: _SequencerInbox.contract, event: "InvalidateKeyset", logs: logs, sub: sub}, nil
}

// WatchInvalidateKeyset is a free log subscription operation binding the contract event 0x5cb4218b272fd214168ac43e90fb4d05d6c36f0b17ffb4c2dd07c234d744eb2a.
//
// Solidity: event InvalidateKeyset(bytes32 indexed keysetHash)
func (_SequencerInbox *SequencerInboxFilterer) WatchInvalidateKeyset(opts *bind.WatchOpts, sink chan<- *SequencerInboxInvalidateKeyset, keysetHash [][32]byte) (event.Subscription, error) {

	var keysetHashRule []interface{}
	for _, keysetHashItem := range keysetHash {
		keysetHashRule = append(keysetHashRule, keysetHashItem)
	}

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "InvalidateKeyset", keysetHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxInvalidateKeyset)
				if err := _SequencerInbox.contract.UnpackLog(event, "InvalidateKeyset", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInvalidateKeyset is a log parse operation binding the contract event 0x5cb4218b272fd214168ac43e90fb4d05d6c36f0b17ffb4c2dd07c234d744eb2a.
//
// Solidity: event InvalidateKeyset(bytes32 indexed keysetHash)
func (_SequencerInbox *SequencerInboxFilterer) ParseInvalidateKeyset(log types.Log) (*SequencerInboxInvalidateKeyset, error) {
	event := new(SequencerInboxInvalidateKeyset)
	if err := _SequencerInbox.contract.UnpackLog(event, "InvalidateKeyset", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxMaxTimeVariationSetIterator is returned from FilterMaxTimeVariationSet and is used to iterate over the raw logs and unpacked data for MaxTimeVariationSet events raised by the SequencerInbox contract.
type SequencerInboxMaxTimeVariationSetIterator struct {
	Event *SequencerInboxMaxTimeVariationSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxMaxTimeVariationSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxMaxTimeVariationSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxMaxTimeVariationSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxMaxTimeVariationSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxMaxTimeVariationSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxMaxTimeVariationSet represents a MaxTimeVariationSet event raised by the SequencerInbox contract.
type SequencerInboxMaxTimeVariationSet struct {
	MaxTimeVariation ISequencerInboxMaxTimeVariation
	Raw              types.Log // Blockchain specific contextual infos
}

// FilterMaxTimeVariationSet is a free log retrieval operation binding the contract event 0xaa6a58dad31128ff7ecc2b80987ee6e003df80bc50cd8d0b0d1af0e07da6d19d.
//
// Solidity: event MaxTimeVariationSet((uint256,uint256,uint256,uint256) maxTimeVariation)
func (_SequencerInbox *SequencerInboxFilterer) FilterMaxTimeVariationSet(opts *bind.FilterOpts) (*SequencerInboxMaxTimeVariationSetIterator, error) {

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "MaxTimeVariationSet")
	if err != nil {
		return nil, err
	}
	return &SequencerInboxMaxTimeVariationSetIterator{contract: _SequencerInbox.contract, event: "MaxTimeVariationSet", logs: logs, sub: sub}, nil
}

// WatchMaxTimeVariationSet is a free log subscription operation binding the contract event 0xaa6a58dad31128ff7ecc2b80987ee6e003df80bc50cd8d0b0d1af0e07da6d19d.
//
// Solidity: event MaxTimeVariationSet((uint256,uint256,uint256,uint256) maxTimeVariation)
func (_SequencerInbox *SequencerInboxFilterer) WatchMaxTimeVariationSet(opts *bind.WatchOpts, sink chan<- *SequencerInboxMaxTimeVariationSet) (event.Subscription, error) {

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "MaxTimeVariationSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxMaxTimeVariationSet)
				if err := _SequencerInbox.contract.UnpackLog(event, "MaxTimeVariationSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMaxTimeVariationSet is a log parse operation binding the contract event 0xaa6a58dad31128ff7ecc2b80987ee6e003df80bc50cd8d0b0d1af0e07da6d19d.
//
// Solidity: event MaxTimeVariationSet((uint256,uint256,uint256,uint256) maxTimeVariation)
func (_SequencerInbox *SequencerInboxFilterer) ParseMaxTimeVariationSet(log types.Log) (*SequencerInboxMaxTimeVariationSet, error) {
	event := new(SequencerInboxMaxTimeVariationSet)
	if err := _SequencerInbox.contract.UnpackLog(event, "MaxTimeVariationSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxOwnerFunctionCalledIterator is returned from FilterOwnerFunctionCalled and is used to iterate over the raw logs and unpacked data for OwnerFunctionCalled events raised by the SequencerInbox contract.
type SequencerInboxOwnerFunctionCalledIterator struct {
	Event *SequencerInboxOwnerFunctionCalled // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxOwnerFunctionCalledIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxOwnerFunctionCalled)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxOwnerFunctionCalled)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxOwnerFunctionCalledIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxOwnerFunctionCalledIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxOwnerFunctionCalled represents a OwnerFunctionCalled event raised by the SequencerInbox contract.
type SequencerInboxOwnerFunctionCalled struct {
	Id  *big.Int
	Raw types.Log // Blockchain specific contextual infos
}

// FilterOwnerFunctionCalled is a free log retrieval operation binding the contract event 0xea8787f128d10b2cc0317b0c3960f9ad447f7f6c1ed189db1083ccffd20f456e.
//
// Solidity: event OwnerFunctionCalled(uint256 indexed id)
func (_SequencerInbox *SequencerInboxFilterer) FilterOwnerFunctionCalled(opts *bind.FilterOpts, id []*big.Int) (*SequencerInboxOwnerFunctionCalledIterator, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "OwnerFunctionCalled", idRule)
	if err != nil {
		return nil, err
	}
	return &SequencerInboxOwnerFunctionCalledIterator{contract: _SequencerInbox.contract, event: "OwnerFunctionCalled", logs: logs, sub: sub}, nil
}

// WatchOwnerFunctionCalled is a free log subscription operation binding the contract event 0xea8787f128d10b2cc0317b0c3960f9ad447f7f6c1ed189db1083ccffd20f456e.
//
// Solidity: event OwnerFunctionCalled(uint256 indexed id)
func (_SequencerInbox *SequencerInboxFilterer) WatchOwnerFunctionCalled(opts *bind.WatchOpts, sink chan<- *SequencerInboxOwnerFunctionCalled, id []*big.Int) (event.Subscription, error) {

	var idRule []interface{}
	for _, idItem := range id {
		idRule = append(idRule, idItem)
	}

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "OwnerFunctionCalled", idRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxOwnerFunctionCalled)
				if err := _SequencerInbox.contract.UnpackLog(event, "OwnerFunctionCalled", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnerFunctionCalled is a log parse operation binding the contract event 0xea8787f128d10b2cc0317b0c3960f9ad447f7f6c1ed189db1083ccffd20f456e.
//
// Solidity: event OwnerFunctionCalled(uint256 indexed id)
func (_SequencerInbox *SequencerInboxFilterer) ParseOwnerFunctionCalled(log types.Log) (*SequencerInboxOwnerFunctionCalled, error) {
	event := new(SequencerInboxOwnerFunctionCalled)
	if err := _SequencerInbox.contract.UnpackLog(event, "OwnerFunctionCalled", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxSequencerBatchDataIterator is returned from FilterSequencerBatchData and is used to iterate over the raw logs and unpacked data for SequencerBatchData events raised by the SequencerInbox contract.
type SequencerInboxSequencerBatchDataIterator struct {
	Event *SequencerInboxSequencerBatchData // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxSequencerBatchDataIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxSequencerBatchData)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxSequencerBatchData)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxSequencerBatchDataIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxSequencerBatchDataIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxSequencerBatchData represents a SequencerBatchData event raised by the SequencerInbox contract.
type SequencerInboxSequencerBatchData struct {
	BatchSequenceNumber *big.Int
	Data                []byte
	Raw                 types.Log // Blockchain specific contextual infos
}

// FilterSequencerBatchData is a free log retrieval operation binding the contract event 0xfe325ca1efe4c5c1062c981c3ee74b781debe4ea9440306a96d2a55759c66c20.
//
// Solidity: event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data)
func (_SequencerInbox *SequencerInboxFilterer) FilterSequencerBatchData(opts *bind.FilterOpts, batchSequenceNumber []*big.Int) (*SequencerInboxSequencerBatchDataIterator, error) {

	var batchSequenceNumberRule []interface{}
	for _, batchSequenceNumberItem := range batchSequenceNumber {
		batchSequenceNumberRule = append(batchSequenceNumberRule, batchSequenceNumberItem)
	}

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "SequencerBatchData", batchSequenceNumberRule)
	if err != nil {
		return nil, err
	}
	return &SequencerInboxSequencerBatchDataIterator{contract: _SequencerInbox.contract, event: "SequencerBatchData", logs: logs, sub: sub}, nil
}

// WatchSequencerBatchData is a free log subscription operation binding the contract event 0xfe325ca1efe4c5c1062c981c3ee74b781debe4ea9440306a96d2a55759c66c20.
//
// Solidity: event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data)
func (_SequencerInbox *SequencerInboxFilterer) WatchSequencerBatchData(opts *bind.WatchOpts, sink chan<- *SequencerInboxSequencerBatchData, batchSequenceNumber []*big.Int) (event.Subscription, error) {

	var batchSequenceNumberRule []interface{}
	for _, batchSequenceNumberItem := range batchSequenceNumber {
		batchSequenceNumberRule = append(batchSequenceNumberRule, batchSequenceNumberItem)
	}

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "SequencerBatchData", batchSequenceNumberRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxSequencerBatchData)
				if err := _SequencerInbox.contract.UnpackLog(event, "SequencerBatchData", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSequencerBatchData is a log parse operation binding the contract event 0xfe325ca1efe4c5c1062c981c3ee74b781debe4ea9440306a96d2a55759c66c20.
//
// Solidity: event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data)
func (_SequencerInbox *SequencerInboxFilterer) ParseSequencerBatchData(log types.Log) (*SequencerInboxSequencerBatchData, error) {
	event := new(SequencerInboxSequencerBatchData)
	if err := _SequencerInbox.contract.UnpackLog(event, "SequencerBatchData", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxSequencerBatchDeliveredIterator is returned from FilterSequencerBatchDelivered and is used to iterate over the raw logs and unpacked data for SequencerBatchDelivered events raised by the SequencerInbox contract.
type SequencerInboxSequencerBatchDeliveredIterator struct {
	Event *SequencerInboxSequencerBatchDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxSequencerBatchDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxSequencerBatchDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxSequencerBatchDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxSequencerBatchDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxSequencerBatchDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxSequencerBatchDelivered represents a SequencerBatchDelivered event raised by the SequencerInbox contract.
type SequencerInboxSequencerBatchDelivered struct {
	BatchSequenceNumber      *big.Int
	BeforeAcc                [32]byte
	AfterAcc                 [32]byte
	DelayedAcc               [32]byte
	AfterDelayedMessagesRead *big.Int
	TimeBounds               IBridgeTimeBounds
	DataLocation             uint8
	Raw                      types.Log // Blockchain specific contextual infos
}

// FilterSequencerBatchDelivered is a free log retrieval operation binding the contract event 0x7394f4a19a13c7b92b5bb71033245305946ef78452f7b4986ac1390b5df4ebd7.
//
// Solidity: event SequencerBatchDelivered(uint256 indexed batchSequenceNumber, bytes32 indexed beforeAcc, bytes32 indexed afterAcc, bytes32 delayedAcc, uint256 afterDelayedMessagesRead, (uint64,uint64,uint64,uint64) timeBounds, uint8 dataLocation)
func (_SequencerInbox *SequencerInboxFilterer) FilterSequencerBatchDelivered(opts *bind.FilterOpts, batchSequenceNumber []*big.Int, beforeAcc [][32]byte, afterAcc [][32]byte) (*SequencerInboxSequencerBatchDeliveredIterator, error) {

	var batchSequenceNumberRule []interface{}
	for _, batchSequenceNumberItem := range batchSequenceNumber {
		batchSequenceNumberRule = append(batchSequenceNumberRule, batchSequenceNumberItem)
	}
	var beforeAccRule []interface{}
	for _, beforeAccItem := range beforeAcc {
		beforeAccRule = append(beforeAccRule, beforeAccItem)
	}
	var afterAccRule []interface{}
	for _, afterAccItem := range afterAcc {
		afterAccRule = append(afterAccRule, afterAccItem)
	}

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "SequencerBatchDelivered", batchSequenceNumberRule, beforeAccRule, afterAccRule)
	if err != nil {
		return nil, err
	}
	return &SequencerInboxSequencerBatchDeliveredIterator{contract: _SequencerInbox.contract, event: "SequencerBatchDelivered", logs: logs, sub: sub}, nil
}

// WatchSequencerBatchDelivered is a free log subscription operation binding the contract event 0x7394f4a19a13c7b92b5bb71033245305946ef78452f7b4986ac1390b5df4ebd7.
//
// Solidity: event SequencerBatchDelivered(uint256 indexed batchSequenceNumber, bytes32 indexed beforeAcc, bytes32 indexed afterAcc, bytes32 delayedAcc, uint256 afterDelayedMessagesRead, (uint64,uint64,uint64,uint64) timeBounds, uint8 dataLocation)
func (_SequencerInbox *SequencerInboxFilterer) WatchSequencerBatchDelivered(opts *bind.WatchOpts, sink chan<- *SequencerInboxSequencerBatchDelivered, batchSequenceNumber []*big.Int, beforeAcc [][32]byte, afterAcc [][32]byte) (event.Subscription, error) {

	var batchSequenceNumberRule []interface{}
	for _, batchSequenceNumberItem := range batchSequenceNumber {
		batchSequenceNumberRule = append(batchSequenceNumberRule, batchSequenceNumberItem)
	}
	var beforeAccRule []interface{}
	for _, beforeAccItem := range beforeAcc {
		beforeAccRule = append(beforeAccRule, beforeAccItem)
	}
	var afterAccRule []interface{}
	for _, afterAccItem := range afterAcc {
		afterAccRule = append(afterAccRule, afterAccItem)
	}

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "SequencerBatchDelivered", batchSequenceNumberRule, beforeAccRule, afterAccRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxSequencerBatchDelivered)
				if err := _SequencerInbox.contract.UnpackLog(event, "SequencerBatchDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSequencerBatchDelivered is a log parse operation binding the contract event 0x7394f4a19a13c7b92b5bb71033245305946ef78452f7b4986ac1390b5df4ebd7.
//
// Solidity: event SequencerBatchDelivered(uint256 indexed batchSequenceNumber, bytes32 indexed beforeAcc, bytes32 indexed afterAcc, bytes32 delayedAcc, uint256 afterDelayedMessagesRead, (uint64,uint64,uint64,uint64) timeBounds, uint8 dataLocation)
func (_SequencerInbox *SequencerInboxFilterer) ParseSequencerBatchDelivered(log types.Log) (*SequencerInboxSequencerBatchDelivered, error) {
	event := new(SequencerInboxSequencerBatchDelivered)
	if err := _SequencerInbox.contract.UnpackLog(event, "SequencerBatchDelivered", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxSequencerSetIterator is returned from FilterSequencerSet and is used to iterate over the raw logs and unpacked data for SequencerSet events raised by the SequencerInbox contract.
type SequencerInboxSequencerSetIterator struct {
	Event *SequencerInboxSequencerSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxSequencerSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxSequencerSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxSequencerSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxSequencerSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxSequencerSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxSequencerSet represents a SequencerSet event raised by the SequencerInbox contract.
type SequencerInboxSequencerSet struct {
	Addr        common.Address
	IsSequencer bool
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSequencerSet is a free log retrieval operation binding the contract event 0xeb12a9a53eec138c91b27b4f912a257bd690c18fc8bde744be92a0365eb9b87e.
//
// Solidity: event SequencerSet(address addr, bool isSequencer)
func (_SequencerInbox *SequencerInboxFilterer) FilterSequencerSet(opts *bind.FilterOpts) (*SequencerInboxSequencerSetIterator, error) {

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "SequencerSet")
	if err != nil {
		return nil, err
	}
	return &SequencerInboxSequencerSetIterator{contract: _SequencerInbox.contract, event: "SequencerSet", logs: logs, sub: sub}, nil
}

// WatchSequencerSet is a free log subscription operation binding the contract event 0xeb12a9a53eec138c91b27b4f912a257bd690c18fc8bde744be92a0365eb9b87e.
//
// Solidity: event SequencerSet(address addr, bool isSequencer)
func (_SequencerInbox *SequencerInboxFilterer) WatchSequencerSet(opts *bind.WatchOpts, sink chan<- *SequencerInboxSequencerSet) (event.Subscription, error) {

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "SequencerSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxSequencerSet)
				if err := _SequencerInbox.contract.UnpackLog(event, "SequencerSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSequencerSet is a log parse operation binding the contract event 0xeb12a9a53eec138c91b27b4f912a257bd690c18fc8bde744be92a0365eb9b87e.
//
// Solidity: event SequencerSet(address addr, bool isSequencer)
func (_SequencerInbox *SequencerInboxFilterer) ParseSequencerSet(log types.Log) (*SequencerInboxSequencerSet, error) {
	event := new(SequencerInboxSequencerSet)
	if err := _SequencerInbox.contract.UnpackLog(event, "SequencerSet", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// SequencerInboxSetValidKeysetIterator is returned from FilterSetValidKeyset and is used to iterate over the raw logs and unpacked data for SetValidKeyset events raised by the SequencerInbox contract.
type SequencerInboxSetValidKeysetIterator struct {
	Event *SequencerInboxSetValidKeyset // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SequencerInboxSetValidKeysetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SequencerInboxSetValidKeyset)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SequencerInboxSetValidKeyset)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SequencerInboxSetValidKeysetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SequencerInboxSetValidKeysetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SequencerInboxSetValidKeyset represents a SetValidKeyset event raised by the SequencerInbox contract.
type SequencerInboxSetValidKeyset struct {
	KeysetHash  [32]byte
	KeysetBytes []byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterSetValidKeyset is a free log retrieval operation binding the contract event 0xabca9b7986bc22ad0160eb0cb88ae75411eacfba4052af0b457a9335ef655722.
//
// Solidity: event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes)
func (_SequencerInbox *SequencerInboxFilterer) FilterSetValidKeyset(opts *bind.FilterOpts, keysetHash [][32]byte) (*SequencerInboxSetValidKeysetIterator, error) {

	var keysetHashRule []interface{}
	for _, keysetHashItem := range keysetHash {
		keysetHashRule = append(keysetHashRule, keysetHashItem)
	}

	logs, sub, err := _SequencerInbox.contract.FilterLogs(opts, "SetValidKeyset", keysetHashRule)
	if err != nil {
		return nil, err
	}
	return &SequencerInboxSetValidKeysetIterator{contract: _SequencerInbox.contract, event: "SetValidKeyset", logs: logs, sub: sub}, nil
}

// WatchSetValidKeyset is a free log subscription operation binding the contract event 0xabca9b7986bc22ad0160eb0cb88ae75411eacfba4052af0b457a9335ef655722.
//
// Solidity: event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes)
func (_SequencerInbox *SequencerInboxFilterer) WatchSetValidKeyset(opts *bind.WatchOpts, sink chan<- *SequencerInboxSetValidKeyset, keysetHash [][32]byte) (event.Subscription, error) {

	var keysetHashRule []interface{}
	for _, keysetHashItem := range keysetHash {
		keysetHashRule = append(keysetHashRule, keysetHashItem)
	}

	logs, sub, err := _SequencerInbox.contract.WatchLogs(opts, "SetValidKeyset", keysetHashRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SequencerInboxSetValidKeyset)
				if err := _SequencerInbox.contract.UnpackLog(event, "SetValidKeyset", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSetValidKeyset is a log parse operation binding the contract event 0xabca9b7986bc22ad0160eb0cb88ae75411eacfba4052af0b457a9335ef655722.
//
// Solidity: event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes)
func (_SequencerInbox *SequencerInboxFilterer) ParseSetValidKeyset(log types.Log) (*SequencerInboxSetValidKeyset, error) {
	event := new(SequencerInboxSetValidKeyset)
	if err := _SequencerInbox.contract.UnpackLog(event, "SetValidKeyset", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
